/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////
#pragma once

#include "events.hpp"

#include <vector>

namespace gaia 
{
/**
 * \addtogroup Gaia
 * @{
 */

namespace rules 
{

/**
 * \addtogroup Rules
 * @{
 * 
 * Provides facilities for subscribing and unsubscribing rules
 * to events.
 */

class context_base_t;

/**
 * All rules must adhere to this prototype.  Since the preamble of the rule
 * is generated by a GaiaProcessor, the context parameter should
 * be cast to the appropriate derived context before use.
 */
typedef void (* gaia_rule_fn)(const context_base_t * context);

/**
 * The caller supplies a rule_binding to subscribe/unsubscribe rules to/from events.
 * The caller must supply the ruleset_name and the function pointer for the rule.
 * Gaia will supply the actual rule_name on the subscribtion call to ensure that the
 * ruleset_name plus the rule_name is unique across all the rules in the system.
 */
struct rule_binding_t {
    const char * ruleset_name;
    const char * rule_name;
    gaia_rule_fn rule;
};

/**
 * Rule contexts map 1:1 to each rule that is bound to an event.  A single
 * event may be bound to multiple rules.  Rules may also be invoked
 * both synchronously or asynchronously.  For this reason,
 * events and rules are decoupled in the system.
 * 
 * The rule binding is included for debugging and may be removed in a later
 * iteration.
 */
class context_base_t 
{
public:            
    context_base_t(rule_binding_t& binding, events::event_type type) 
    : rule_binding(binding), event_type(type) {}
    virtual ~context_base_t() = default;

    context_base_t() = delete;

    const events::event_type event_type;
    const rule_binding_t& rule_binding;
};

/**
 * A transaction context only has the event type for now.  Currently
 * the system does nothing with this event type.
 */
class transaction_context_t : public context_base_t
{
public:
    transaction_context_t(rule_binding_t& binding, events::event_type type) 
    : context_base_t(binding, type) {}
};

/**
 * A table context contains the row that the operation affected
 */
class table_context_t : public context_base_t
{
public:
    table_context_t(rule_binding_t& binding, events::event_type type, gaia::api::gaia_base * row)
    : context_base_t(binding, type), row(row) {}
    
    gaia::api::gaia_base * row;
};


/**
 * Subscribes this rule to the specified table event scoped to the gaia_type. 
 *  
 * Note that it is valid to bind multiple different rules to the same event.  
 * It is also valid to bind the same rule to multiple different events.
 * 
 * @param gaia_type table type to bind the rule to
 * @param type the event type to bind this rule to
 * @param rule_binding caller-supplied rule information; this call will populate rule_name
 * @return true on success, false on failure. Failure can occure for the following reasons:
 *      invalid event type (must be a table event)
 *      invalid rule_binding (no ruleset_name or no rule)
 *      duplicate rule_binding (if the ruleset_name/rule_name pair already has been subscribed
 *      to the event on the same gaia_type)
 */
bool subscribe_table_rule(gaia::api::gaia_type_t gaia_type, gaia::events::event_type type, rule_binding_t& rule_binding);


/**
 * Subscribes this rule to the specified transaction event.  
 * 
 * It is legal to bind multiple different rules to the same event.  
 * It is also possible to bind the same rule to multiple different events.
 * 
 * @param type the transaction event type to bind this rule to
 * @param rule_binding caller-supplied rule information; this call will populate rule_name
 * @return true on success, false on failure. Failure can occure for the following reasons:
 *      invalid event type (must be a transaction event)
 *      invalid rule_binding (no ruleset_name, no rule)
 *      duplicate rule_binding (if the ruleset_name/rule_name pair already has been subscribed
 *      to the transaction event)
 */
bool subscribe_transaction_rule(gaia::events::event_type type, rule_binding_t& rule_binding);


/**
 * Unsubscribes this rule from the specified table event scoped by the gaia_type.
 * 
 * @param gaia_type table type to bind the rule to
 * @param type the event type to bind this rule to
 * @param rule_binding caller-supplied rule information
 * @return true on success, false on failure. Failure can occure for the following reasons:
 *      invalid event type (must be a table event)
 *      invalid rule_binding (no ruleset_name or no rule_name)
 *      rule was never subscribed
 */
bool unsubscribe_table_rule(gaia::api::gaia_type_t gaia_type, gaia::events::event_type type, const rule_binding_t& rule_binding);

/**
 * Unsubscribes this rule from the specified transaction event.  
 * 
 * @param type the transaction event type to bind this rule to
 * @param rule_binding caller-supplied rule information
 * @return true on success, false on failure. Failure can occure for the following reasons:
 *      invalid event type (must be a transaction event)
 *      invalid rule_binding (no ruleset_name, no rule)
 *      duplicate rule_binding (if the ruleset_name/rule_name pair already has been subscribed
 *      to the transaction event)
 */
bool unsubscribe_transaction_rule(gaia::events::event_type type, const rule_binding_t& rule_binding);

/**
 * List all rules already subscribed to events.  
 * 
 * Enable filtering on ruleset name, gaia_type, and event_type.
 * 
 * @param ruleset_name Scope returned rules to specified rulset if provided.  May be null.
 * @param gaia_type Filter results by the object they refer to.  May be null.
 * @param type Filter by event_type.  May be null.  If a transaction even type then the gaia_type filter
 *      will be ignored.
 * @param rule_names Caller provided vector to hold the results.  This method will clear any existing
 *      entries before adding new ones.
 */
void list_subscribed_rules(const char * ruleset_name, const gaia::api::gaia_type_t * gaia_type, const gaia::events::event_type * type,
    std::vector<const char *>& rule_names);

/*@}*/
}
/*@}*/
}
