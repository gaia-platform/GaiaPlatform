/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

// Automatically generated by the Gaia Data Classes code generator.
// Do not modify.

#ifndef GAIA_GENERATED_addr_book_H_
#define GAIA_GENERATED_addr_book_H_

#include <iterator>
#include <gaia/direct_access/edc_object.hpp>
#include <gaia/direct_access/edc_iterators.hpp>
#include <addr_book_generated.h>

namespace gaia {
namespace addr_book {

// The initial size of the flatbuffer builder buffer.
constexpr int c_flatbuffer_builder_size = 128;

// Constants contained in the B object.
constexpr uint32_t c_gaia_type_B = 7u;
constexpr int c_B_parent_a = 0;
constexpr int c_B_next_a = 1;

// Constants contained in the A object.
constexpr uint32_t c_gaia_type_A = 6u;
constexpr int c_A_first_b = 0;

// Constants contained in the customer object.
constexpr uint32_t c_gaia_type_customer = 5u;

// Constants contained in the internet_contract object.
constexpr uint32_t c_gaia_type_internet_contract = 4u;
constexpr int c_internet_contract_parent_address = 0;
constexpr int c_internet_contract_next_address = 1;

// Constants contained in the phone object.
constexpr uint32_t c_gaia_type_phone = 3u;
constexpr int c_phone_parent_address = 0;
constexpr int c_phone_next_address = 1;
constexpr int c_phone_parent_owner = 2;
constexpr int c_phone_next_owner = 3;

// Constants contained in the address object.
constexpr uint32_t c_gaia_type_address = 2u;
constexpr int c_address_parent_owner = 0;
constexpr int c_address_next_owner = 1;
constexpr int c_address_first_phones = 2;
constexpr int c_address_first_internet_contract = 3;

// Constants contained in the employee object.
constexpr uint32_t c_gaia_type_employee = 1u;
constexpr int c_employee_first_reportees = 0;
constexpr int c_employee_parent_manager = 1;
constexpr int c_employee_next_manager = 2;
constexpr int c_employee_first_addresses = 3;
constexpr int c_employee_first_phones = 4;


class B_t;
class A_t;
class customer_t;
class internet_contract_t;
class phone_t;
class address_t;
class employee_t;

typedef gaia::direct_access::edc_writer_t<c_gaia_type_B, B_t, internal::B, internal::BT> B_writer;
class B_t : public gaia::direct_access::edc_object_t<c_gaia_type_B, B_t, internal::B, internal::BT> {
public:
    B_t() : edc_object_t("B_t") {}
    static gaia::common::gaia_id_t insert_row(const char* str_val, int32_t num_val);
    static gaia::direct_access::edc_container_t<c_gaia_type_B, B_t> list();
    const char* str_val() const;
    int32_t num_val() const;
    A_t a() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<B_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<B_t, const char*> str_val;
        static gaia::direct_access::expression_t<B_t, int32_t> num_val;
        static gaia::direct_access::expression_t<B_t, A_t> a;
    };
    using expr = expr_<void>;
private:
    explicit B_t(gaia::common::gaia_id_t id) : edc_object_t(id, "B_t") {}
    friend class edc_object_t<c_gaia_type_B, B_t, internal::B, internal::BT>;
};
namespace B_expr {
    static auto& gaia_id = B_t::expr::gaia_id;
    static auto& str_val = B_t::expr::str_val;
    static auto& num_val = B_t::expr::num_val;
    static auto& a = B_t::expr::a;
};

template<class unused_t> gaia::direct_access::expression_t<B_t, gaia::common::gaia_id_t> B_t::expr_<unused_t>::gaia_id{&B_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<B_t, const char*> B_t::expr_<unused_t>::str_val{&B_t::str_val};
template<class unused_t> gaia::direct_access::expression_t<B_t, int32_t> B_t::expr_<unused_t>::num_val{&B_t::num_val};
template<class unused_t> gaia::direct_access::expression_t<B_t, A_t> B_t::expr_<unused_t>::a{&B_t::a};


typedef gaia::direct_access::edc_writer_t<c_gaia_type_A, A_t, internal::A, internal::AT> A_writer;
class A_t : public gaia::direct_access::edc_object_t<c_gaia_type_A, A_t, internal::A, internal::AT> {
public:
    typedef gaia::direct_access::reference_chain_container_t<B_t> b_list_t;
    A_t() : edc_object_t("A_t") {}
    static gaia::common::gaia_id_t insert_row(const char* str_val, int32_t num_val);
    static gaia::direct_access::edc_container_t<c_gaia_type_A, A_t> list();
    const char* str_val() const;
    int32_t num_val() const;
    b_list_t b() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<A_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<A_t, const char*> str_val;
        static gaia::direct_access::expression_t<A_t, int32_t> num_val;
        static gaia::direct_access::expression_t<A_t, A_t::b_list_t> b;
    };
    using expr = expr_<void>;
private:
    explicit A_t(gaia::common::gaia_id_t id) : edc_object_t(id, "A_t") {}
    friend class edc_object_t<c_gaia_type_A, A_t, internal::A, internal::AT>;
};
namespace A_expr {
    static auto& gaia_id = A_t::expr::gaia_id;
    static auto& str_val = A_t::expr::str_val;
    static auto& num_val = A_t::expr::num_val;
    static auto& b = A_t::expr::b;
};

template<class unused_t> gaia::direct_access::expression_t<A_t, gaia::common::gaia_id_t> A_t::expr_<unused_t>::gaia_id{&A_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<A_t, const char*> A_t::expr_<unused_t>::str_val{&A_t::str_val};
template<class unused_t> gaia::direct_access::expression_t<A_t, int32_t> A_t::expr_<unused_t>::num_val{&A_t::num_val};
template<class unused_t> gaia::direct_access::expression_t<A_t, A_t::b_list_t> A_t::expr_<unused_t>::b{&A_t::b};


typedef gaia::direct_access::edc_writer_t<c_gaia_type_customer, customer_t, internal::customer, internal::customerT> customer_writer;
class customer_t : public gaia::direct_access::edc_object_t<c_gaia_type_customer, customer_t, internal::customer, internal::customerT> {
public:
    customer_t() : edc_object_t("customer_t") {}
    static gaia::common::gaia_id_t insert_row(const char* name, const std::vector<int32_t>& sales_by_quarter);
    static gaia::direct_access::edc_container_t<c_gaia_type_customer, customer_t> list();
    const char* name() const;
    gaia::direct_access::edc_vector_t<int32_t> sales_by_quarter() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<customer_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<customer_t, const char*> name;
        static gaia::direct_access::expression_t<customer_t, gaia::direct_access::edc_vector_t<int32_t>> sales_by_quarter;
    };
    using expr = expr_<void>;
private:
    explicit customer_t(gaia::common::gaia_id_t id) : edc_object_t(id, "customer_t") {}
    friend class edc_object_t<c_gaia_type_customer, customer_t, internal::customer, internal::customerT>;
};
namespace customer_expr {
    static auto& gaia_id = customer_t::expr::gaia_id;
    static auto& name = customer_t::expr::name;
    static auto& sales_by_quarter = customer_t::expr::sales_by_quarter;
};

template<class unused_t> gaia::direct_access::expression_t<customer_t, gaia::common::gaia_id_t> customer_t::expr_<unused_t>::gaia_id{&customer_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<customer_t, const char*> customer_t::expr_<unused_t>::name{&customer_t::name};
template<class unused_t> gaia::direct_access::expression_t<customer_t, gaia::direct_access::edc_vector_t<int32_t>> customer_t::expr_<unused_t>::sales_by_quarter{&customer_t::sales_by_quarter};


typedef gaia::direct_access::edc_writer_t<c_gaia_type_internet_contract, internet_contract_t, internal::internet_contract, internal::internet_contractT> internet_contract_writer;
class internet_contract_t : public gaia::direct_access::edc_object_t<c_gaia_type_internet_contract, internet_contract_t, internal::internet_contract, internal::internet_contractT> {
public:
    internet_contract_t() : edc_object_t("internet_contract_t") {}
    static gaia::common::gaia_id_t insert_row(const char* provider, const char* contract_id);
    static gaia::direct_access::edc_container_t<c_gaia_type_internet_contract, internet_contract_t> list();
    const char* provider() const;
    const char* contract_id() const;
    address_t address() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<internet_contract_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<internet_contract_t, const char*> provider;
        static gaia::direct_access::expression_t<internet_contract_t, const char*> contract_id;
        static gaia::direct_access::expression_t<internet_contract_t, address_t> address;
    };
    using expr = expr_<void>;
private:
    explicit internet_contract_t(gaia::common::gaia_id_t id) : edc_object_t(id, "internet_contract_t") {}
    friend class edc_object_t<c_gaia_type_internet_contract, internet_contract_t, internal::internet_contract, internal::internet_contractT>;
};
namespace internet_contract_expr {
    static auto& gaia_id = internet_contract_t::expr::gaia_id;
    static auto& provider = internet_contract_t::expr::provider;
    static auto& contract_id = internet_contract_t::expr::contract_id;
    static auto& address = internet_contract_t::expr::address;
};

template<class unused_t> gaia::direct_access::expression_t<internet_contract_t, gaia::common::gaia_id_t> internet_contract_t::expr_<unused_t>::gaia_id{&internet_contract_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<internet_contract_t, const char*> internet_contract_t::expr_<unused_t>::provider{&internet_contract_t::provider};
template<class unused_t> gaia::direct_access::expression_t<internet_contract_t, const char*> internet_contract_t::expr_<unused_t>::contract_id{&internet_contract_t::contract_id};
template<class unused_t> gaia::direct_access::expression_t<internet_contract_t, address_t> internet_contract_t::expr_<unused_t>::address{&internet_contract_t::address};


typedef gaia::direct_access::edc_writer_t<c_gaia_type_phone, phone_t, internal::phone, internal::phoneT> phone_writer;
class phone_t : public gaia::direct_access::edc_object_t<c_gaia_type_phone, phone_t, internal::phone, internal::phoneT> {
public:
    phone_t() : edc_object_t("phone_t") {}
    static gaia::common::gaia_id_t insert_row(const char* phone_number, const char* type, bool primary);
    static gaia::direct_access::edc_container_t<c_gaia_type_phone, phone_t> list();
    const char* phone_number() const;
    const char* type() const;
    bool primary() const;
    employee_t owner() const;
    address_t address() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<phone_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<phone_t, const char*> phone_number;
        static gaia::direct_access::expression_t<phone_t, const char*> type;
        static gaia::direct_access::expression_t<phone_t, bool> primary;
        static gaia::direct_access::expression_t<phone_t, employee_t> owner;
        static gaia::direct_access::expression_t<phone_t, address_t> address;
    };
    using expr = expr_<void>;
private:
    explicit phone_t(gaia::common::gaia_id_t id) : edc_object_t(id, "phone_t") {}
    friend class edc_object_t<c_gaia_type_phone, phone_t, internal::phone, internal::phoneT>;
};
namespace phone_expr {
    static auto& gaia_id = phone_t::expr::gaia_id;
    static auto& phone_number = phone_t::expr::phone_number;
    static auto& type = phone_t::expr::type;
    static auto& primary = phone_t::expr::primary;
    static auto& owner = phone_t::expr::owner;
    static auto& address = phone_t::expr::address;
};

template<class unused_t> gaia::direct_access::expression_t<phone_t, gaia::common::gaia_id_t> phone_t::expr_<unused_t>::gaia_id{&phone_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<phone_t, const char*> phone_t::expr_<unused_t>::phone_number{&phone_t::phone_number};
template<class unused_t> gaia::direct_access::expression_t<phone_t, const char*> phone_t::expr_<unused_t>::type{&phone_t::type};
template<class unused_t> gaia::direct_access::expression_t<phone_t, bool> phone_t::expr_<unused_t>::primary{&phone_t::primary};
template<class unused_t> gaia::direct_access::expression_t<phone_t, employee_t> phone_t::expr_<unused_t>::owner{&phone_t::owner};
template<class unused_t> gaia::direct_access::expression_t<phone_t, address_t> phone_t::expr_<unused_t>::address{&phone_t::address};


typedef gaia::direct_access::edc_writer_t<c_gaia_type_address, address_t, internal::address, internal::addressT> address_writer;
class address_t : public gaia::direct_access::edc_object_t<c_gaia_type_address, address_t, internal::address, internal::addressT> {
public:
    typedef gaia::direct_access::reference_chain_container_t<internet_contract_t> internet_contract_list_t;
    typedef gaia::direct_access::reference_chain_container_t<phone_t> phones_list_t;
    address_t() : edc_object_t("address_t") {}
    static gaia::common::gaia_id_t insert_row(const char* street, const char* apt_suite, const char* city, const char* state, const char* postal, const char* country, bool current);
    static gaia::direct_access::edc_container_t<c_gaia_type_address, address_t> list();
    const char* street() const;
    const char* apt_suite() const;
    const char* city() const;
    const char* state() const;
    const char* postal() const;
    const char* country() const;
    bool current() const;
    employee_t owner() const;
    internet_contract_list_t internet_contract() const;
    phones_list_t phones() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<address_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<address_t, const char*> street;
        static gaia::direct_access::expression_t<address_t, const char*> apt_suite;
        static gaia::direct_access::expression_t<address_t, const char*> city;
        static gaia::direct_access::expression_t<address_t, const char*> state;
        static gaia::direct_access::expression_t<address_t, const char*> postal;
        static gaia::direct_access::expression_t<address_t, const char*> country;
        static gaia::direct_access::expression_t<address_t, bool> current;
        static gaia::direct_access::expression_t<address_t, employee_t> owner;
        static gaia::direct_access::expression_t<address_t, address_t::internet_contract_list_t> internet_contract;
        static gaia::direct_access::expression_t<address_t, address_t::phones_list_t> phones;
    };
    using expr = expr_<void>;
private:
    explicit address_t(gaia::common::gaia_id_t id) : edc_object_t(id, "address_t") {}
    friend class edc_object_t<c_gaia_type_address, address_t, internal::address, internal::addressT>;
};
namespace address_expr {
    static auto& gaia_id = address_t::expr::gaia_id;
    static auto& street = address_t::expr::street;
    static auto& apt_suite = address_t::expr::apt_suite;
    static auto& city = address_t::expr::city;
    static auto& state = address_t::expr::state;
    static auto& postal = address_t::expr::postal;
    static auto& country = address_t::expr::country;
    static auto& current = address_t::expr::current;
    static auto& owner = address_t::expr::owner;
    static auto& internet_contract = address_t::expr::internet_contract;
    static auto& phones = address_t::expr::phones;
};

template<class unused_t> gaia::direct_access::expression_t<address_t, gaia::common::gaia_id_t> address_t::expr_<unused_t>::gaia_id{&address_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<address_t, const char*> address_t::expr_<unused_t>::street{&address_t::street};
template<class unused_t> gaia::direct_access::expression_t<address_t, const char*> address_t::expr_<unused_t>::apt_suite{&address_t::apt_suite};
template<class unused_t> gaia::direct_access::expression_t<address_t, const char*> address_t::expr_<unused_t>::city{&address_t::city};
template<class unused_t> gaia::direct_access::expression_t<address_t, const char*> address_t::expr_<unused_t>::state{&address_t::state};
template<class unused_t> gaia::direct_access::expression_t<address_t, const char*> address_t::expr_<unused_t>::postal{&address_t::postal};
template<class unused_t> gaia::direct_access::expression_t<address_t, const char*> address_t::expr_<unused_t>::country{&address_t::country};
template<class unused_t> gaia::direct_access::expression_t<address_t, bool> address_t::expr_<unused_t>::current{&address_t::current};
template<class unused_t> gaia::direct_access::expression_t<address_t, employee_t> address_t::expr_<unused_t>::owner{&address_t::owner};
template<class unused_t> gaia::direct_access::expression_t<address_t, address_t::internet_contract_list_t> address_t::expr_<unused_t>::internet_contract{&address_t::internet_contract};
template<class unused_t> gaia::direct_access::expression_t<address_t, address_t::phones_list_t> address_t::expr_<unused_t>::phones{&address_t::phones};


typedef gaia::direct_access::edc_writer_t<c_gaia_type_employee, employee_t, internal::employee, internal::employeeT> employee_writer;
class employee_t : public gaia::direct_access::edc_object_t<c_gaia_type_employee, employee_t, internal::employee, internal::employeeT> {
public:
    typedef gaia::direct_access::reference_chain_container_t<phone_t> phones_list_t;
    typedef gaia::direct_access::reference_chain_container_t<address_t> addresses_list_t;
    typedef gaia::direct_access::reference_chain_container_t<employee_t> reportees_list_t;
    employee_t() : edc_object_t("employee_t") {}
    static gaia::common::gaia_id_t insert_row(const char* name_first, const char* name_last, const char* ssn, int64_t hire_date, const char* email, const char* web);
    static gaia::direct_access::edc_container_t<c_gaia_type_employee, employee_t> list();
    const char* name_first() const;
    const char* name_last() const;
    const char* ssn() const;
    int64_t hire_date() const;
    const char* email() const;
    const char* web() const;
    employee_t manager() const;
    phones_list_t phones() const;
    addresses_list_t addresses() const;
    reportees_list_t reportees() const;

    template<class unused_t>
    struct expr_ {
        static gaia::direct_access::expression_t<employee_t, gaia::common::gaia_id_t> gaia_id;
        static gaia::direct_access::expression_t<employee_t, const char*> name_first;
        static gaia::direct_access::expression_t<employee_t, const char*> name_last;
        static gaia::direct_access::expression_t<employee_t, const char*> ssn;
        static gaia::direct_access::expression_t<employee_t, int64_t> hire_date;
        static gaia::direct_access::expression_t<employee_t, const char*> email;
        static gaia::direct_access::expression_t<employee_t, const char*> web;
        static gaia::direct_access::expression_t<employee_t, employee_t> manager;
        static gaia::direct_access::expression_t<employee_t, employee_t::phones_list_t> phones;
        static gaia::direct_access::expression_t<employee_t, employee_t::addresses_list_t> addresses;
        static gaia::direct_access::expression_t<employee_t, employee_t::reportees_list_t> reportees;
    };
    using expr = expr_<void>;
private:
    explicit employee_t(gaia::common::gaia_id_t id) : edc_object_t(id, "employee_t") {}
    friend class edc_object_t<c_gaia_type_employee, employee_t, internal::employee, internal::employeeT>;
};
namespace employee_expr {
    static auto& gaia_id = employee_t::expr::gaia_id;
    static auto& name_first = employee_t::expr::name_first;
    static auto& name_last = employee_t::expr::name_last;
    static auto& ssn = employee_t::expr::ssn;
    static auto& hire_date = employee_t::expr::hire_date;
    static auto& email = employee_t::expr::email;
    static auto& web = employee_t::expr::web;
    static auto& manager = employee_t::expr::manager;
    static auto& phones = employee_t::expr::phones;
    static auto& addresses = employee_t::expr::addresses;
    static auto& reportees = employee_t::expr::reportees;
};

template<class unused_t> gaia::direct_access::expression_t<employee_t, gaia::common::gaia_id_t> employee_t::expr_<unused_t>::gaia_id{&employee_t::gaia_id};
template<class unused_t> gaia::direct_access::expression_t<employee_t, const char*> employee_t::expr_<unused_t>::name_first{&employee_t::name_first};
template<class unused_t> gaia::direct_access::expression_t<employee_t, const char*> employee_t::expr_<unused_t>::name_last{&employee_t::name_last};
template<class unused_t> gaia::direct_access::expression_t<employee_t, const char*> employee_t::expr_<unused_t>::ssn{&employee_t::ssn};
template<class unused_t> gaia::direct_access::expression_t<employee_t, int64_t> employee_t::expr_<unused_t>::hire_date{&employee_t::hire_date};
template<class unused_t> gaia::direct_access::expression_t<employee_t, const char*> employee_t::expr_<unused_t>::email{&employee_t::email};
template<class unused_t> gaia::direct_access::expression_t<employee_t, const char*> employee_t::expr_<unused_t>::web{&employee_t::web};
template<class unused_t> gaia::direct_access::expression_t<employee_t, employee_t> employee_t::expr_<unused_t>::manager{&employee_t::manager};
template<class unused_t> gaia::direct_access::expression_t<employee_t, employee_t::phones_list_t> employee_t::expr_<unused_t>::phones{&employee_t::phones};
template<class unused_t> gaia::direct_access::expression_t<employee_t, employee_t::addresses_list_t> employee_t::expr_<unused_t>::addresses{&employee_t::addresses};
template<class unused_t> gaia::direct_access::expression_t<employee_t, employee_t::reportees_list_t> employee_t::expr_<unused_t>::reportees{&employee_t::reportees};


}  // namespace addr_book
}  // namespace gaia

#endif  // GAIA_GENERATED_addr_book_H_

