/////////////////////////////////////////////
//// Copyright (c) Gaia Platform LLC
//// All rights reserved.
///////////////////////////////////////////////
#include "gaia_catalog.h"
#include "catalog_manager.hpp"
#include "code_writer.hpp"
#include <memory>
#include <vector>
#include <set>

using namespace std;

namespace gaia {
namespace catalog {

const string indent_string("    ");

typedef struct {
    string name;
    data_type_t type;
} field_strings_t;

typedef vector<field_strings_t> field_vec;

typedef struct {
    string name;
    string ref_name;
} table_references_t;

typedef vector<table_references_t> references_vec;
typedef map<gaia_id_t, references_vec> references_map;

// Build the two reference maps, one for the 1: side of the relationship, another for the :N side.
static void build_references_maps(references_map& references_1, references_map& references_n) {
    for (auto table_id : list_tables()) {
        field_vec field_strings;
        auto table_record = gaia_table_t::get(table_id);
        for (auto ref_id : list_references(table_id)) {
            gaia_field_t ref_record = gaia_field_t::get(ref_id);
            auto owner_record = gaia_table_t::get(ref_record.type_id());
            references_1[ref_record.type_id()].push_back({table_record.name(), ref_record.name()});
            references_n[table_id].push_back({owner_record.name(), ref_record.name()});
        }
    }
}

static string field_cpp_type_string(data_type_t data_type) {
    switch (data_type) {
    case data_type_t::e_bool:
        return "bool";
    case data_type_t::e_int8:
        return "int8_t";
    case data_type_t::e_uint8:
        return "uint8_t";
    case data_type_t::e_int16:
        return "int16_t";
    case data_type_t::e_uint16:
        return "uint16_t";
    case data_type_t::e_int32:
        return "int32_t";
    case data_type_t::e_uint32:
        return "uint32_t";
    case data_type_t::e_int64:
        return "int64_t";
    case data_type_t::e_uint64:
        return "uint64_t";
    case data_type_t::e_float32:
        return "float32_t";
    case data_type_t::e_float64:
        return "float64_t";
    case data_type_t::e_string:
        return "const char*";
    default:
        throw gaia::common::gaia_exception("Unknown type");
    }
}

static string generate_boilerplate_top(string dbname) {
    code_writer code(indent_string);
    code.set_value("DBNAME", dbname);
    code += "/////////////////////////////////////////////";
    code += "// Copyright (c) Gaia Platform LLC";
    code += "// All rights reserved.";
    code += "/////////////////////////////////////////////";
    code += "";
    code += "// Automatically generated by Gaia Data Classes code generator, do not modify.";
    code += "";
    code += "#include <iterator>";
    code += "";
    code += "#ifndef GAIA_GENERATED_{{DBNAME}}_H_";
    code += "#define GAIA_GENERATED_{{DBNAME}}_H_";
    code += "";
    code += "#include \"gaia_object.hpp\"";
    code += "#include \"{{DBNAME}}_generated.h\"";
    code += "#include \"gaia_iterators.hpp\"";
    code += "";
    code += "using namespace std;";
    code += "using namespace gaia::direct_access;";
    code += "";
    code += "namespace gaia {";
    code += "namespace {{DBNAME}} {";
    string str = code.to_string();
    return str;
}

static string generate_boilerplate_bottom(string dbname) {
    code_writer code(indent_string);
    code.set_value("DBNAME", dbname);
    code += "}  // namespace {{DBNAME}}";
    code += "}  // namespace gaia";
    code += "";
    code += "#endif  // GAIA_GENERATED_{{DBNAME}}_H_";
    string str = code.to_string();
    return str;
}

// Generate the list of constants referred to by the class definitions and templates.
static string generate_constant_list(references_map& references_1, references_map& references_n) {
    code_writer code(indent_string);
    // A fixed constant is used for the flatbuffer builder constructor.
    code += "";
    code += "// The initial size of the flatbuffer builder buffer.";
    code += "constexpr int c_flatbuffer_builder_size = 128;";
    code += "";
    for (auto table_id : list_tables()) {
        auto table_record = gaia_table_t::get(table_id);
        auto const_count = 0;
        code.set_value("TABLE_NAME", table_record.name());
        code += "// Constants contained in the {{TABLE_NAME}} object.";
        for (auto ref : references_1[table_id]) {
            code.set_value("REF_TABLE", ref.name);
            code.set_value("REF_NAME", ref.ref_name);
            code.set_value("CONST_VALUE", to_string(const_count++));
            code += "constexpr int c_first_{{REF_NAME}}_{{REF_TABLE}} = {{CONST_VALUE}};";
        }
        for (auto ref : references_n[table_id]) {
            code.set_value("REF_TABLE", ref.name);
            code.set_value("REF_NAME", ref.ref_name);
            code.set_value("CONST_VALUE", to_string(const_count++));
            code += "constexpr int c_parent_{{REF_NAME}}_{{REF_TABLE}} = {{CONST_VALUE}};";
            code.set_value("CONST_VALUE", to_string(const_count++));
            code += "constexpr int c_next_{{REF_NAME}}_{{TABLE_NAME}} = {{CONST_VALUE}};";
        }
        code.set_value("CONST_VALUE", to_string(const_count++));
        code += "constexpr int c_num_{{TABLE_NAME}}_ptrs = {{CONST_VALUE}};";
        code += "";
    }
    string str = code.to_string();
    return str;
}

static string generate_declarations() {
    code_writer code(indent_string);

    for (auto table_id : list_tables()) {
        auto table_record = gaia_table_t::get(table_id);
        code.set_value("TABLE_NAME", table_record.name());
        code += "struct {{TABLE_NAME}}_t;";
    }
    code += "";
    string str = code.to_string();
    return str;
}

static string generate_edc_struct(gaia_type_t table_type_id, string table_name, field_vec& field_strings,
    references_vec& references_1, references_vec& references_n)
{
    code_writer code(indent_string);

    // Struct statement.
    code.set_value("TABLE_NAME", table_name);
    code.set_value("POSITION", to_string(table_type_id));
    code += "typedef gaia_writer_t<{{POSITION}}llu,{{TABLE_NAME}}_t,{{TABLE_NAME}},{{TABLE_NAME}}T,c_num_{{TABLE_NAME}}_ptrs> {{TABLE_NAME}}_writer;";
    code += "struct {{TABLE_NAME}}_t : public gaia_object_t<{{POSITION}}llu,{{TABLE_NAME}}_t,{{TABLE_NAME}},{{TABLE_NAME}}T,c_num_{{TABLE_NAME}}_ptrs> {";

    code.increment_indent_level();

    // Below, a flatbuffer method is invoked as Create{{TABLE_NAME}}() or
    // as Create{{TABLE_NAME}}Direct. The choice is determined by whether any of the
    // fields are strings. If at least one is a string, than the Direct variation
    // is used.
    // NOTE: There may be a third variation of this if any of the fields are vectors
    // or possibly arrays.
    bool has_string = false;
    // Accessors.
    for (auto f : field_strings) {
        code.set_value("TYPE", field_cpp_type_string(f.type));
        code.set_value("FIELD_NAME", f.name);
        if (f.type == data_type_t::e_string) {
            has_string = true;
            code.set_value("FCN_NAME", "GET_STR");
        }
        else {
            code.set_value("FCN_NAME", "GET");
        }
        code += "{{TYPE}} {{FIELD_NAME}}() const {return {{FCN_NAME}}({{FIELD_NAME}});}";
    }

    code += "using gaia_object_t::insert_row;";

    // The typed insert_row().
    string param_list("static gaia_id_t insert_row(");
    bool first = true;
    for (auto f : field_strings) {
        if (!first) {
            param_list += ", ";
        }
        else {
            first = false;
        }
        param_list += field_cpp_type_string(f.type) + " ";
        param_list += f.name;
    }
    code += param_list + ") {";
    code.increment_indent_level();
    code += "flatbuffers::FlatBufferBuilder b(c_flatbuffer_builder_size);";
    code.set_value("DIRECT", has_string ? "Direct" : "");
    param_list = "b.Finish(Create{{TABLE_NAME}}{{DIRECT}}(b";
    for (auto f : field_strings) {
        param_list += ", ";
        param_list += f.name;
    }
    param_list += "));";
    code += param_list;
    code += "return gaia_object_t::insert_row(b);";
    code.decrement_indent_level();
    code += "}";

    // The reference to the parent records.
    for (auto ref : references_n) {
        if (ref.ref_name.length()) {
            code.set_value("REF_NAME", ref.ref_name);
        }
        else {
            // This relationship is anonymous.
            code.set_value("REF_NAME", ref.name);
        }
        code.set_value("REF_TABLE", ref.name);
        code += "{{REF_TABLE}}_t {{REF_NAME}}() {";
        code.increment_indent_level();
        code += "return {{REF_TABLE}}_t::get(this->references()[c_parent_{{REF_NAME}}_{{REF_TABLE}}]);";
        code.decrement_indent_level();
        code += "}";
    }

    // The table range.
    code += "static gaia_container_t<{{POSITION}}llu, {{TABLE_NAME}}_t>& list() {";
    code.increment_indent_level();
    code += "static gaia_container_t<{{POSITION}}llu, {{TABLE_NAME}}_t> list;";
    code += "return list;";
    code.decrement_indent_level();
    code += "}";

    // Iterator objects to scan rows pointed to by this one.
    for (auto ref : references_1) {
        if (ref.ref_name.length()) {
            code.set_value("REF_NAME", ref.ref_name);
        }
        else {
            code.set_value("REF_NAME", ref.name);
        }
        code.set_value("REF_TABLE", ref.name);
        code += "reference_chain_container_t<{{TABLE_NAME}}_t,{{REF_TABLE}}_t,c_parent_{{REF_NAME}}_{{TABLE_NAME}},"
            "c_first_{{REF_NAME}}_{{REF_TABLE}},c_next_{{REF_NAME}}_{{REF_TABLE}}> m_{{REF_NAME}}_list;";
        code += "reference_chain_container_t<{{TABLE_NAME}}_t,{{REF_TABLE}}_t,c_parent_{{REF_NAME}}_{{TABLE_NAME}},"
            "c_first_{{REF_NAME}}_{{REF_TABLE}},c_next_{{REF_NAME}}_{{REF_TABLE}}>& {{REF_NAME}}_list() {";
        code.increment_indent_level();
        code += "return m_{{REF_NAME}}_list;";
        code.decrement_indent_level();
        code += "}";
    }

    // The private area.
    code.decrement_indent_level();
    code += "private:";
    code.increment_indent_level();
    code += "friend struct gaia_object_t<{{POSITION}}llu, {{TABLE_NAME}}_t, {{TABLE_NAME}}, {{TABLE_NAME}}T, c_num_{{TABLE_NAME}}_ptrs>;";

    // The constructor.
    code += "{{TABLE_NAME}}_t(gaia_id_t id) : gaia_object_t(id, \"{{TABLE_NAME}}_t\") {";
    code.increment_indent_level();
    for (auto ref : references_1) {
        if (ref.ref_name.length()) {
            code.set_value("REF_NAME", ref.ref_name);
        }
        else {
            code.set_value("REF_NAME", ref.name);
        }
        code += "m_{{REF_NAME}}_list.set_outer(gaia_id());";
    }
    code.decrement_indent_level();
    code += "}";

    // Finishing brace.
    code.decrement_indent_level();
    code += "};";
    code += "";

    string str = code.to_string();
    return str;
}

string gaia_generate(string dbname) {

    references_map references_1;
    references_map references_n;
    string code_lines;
    begin_transaction();
    build_references_maps(references_1, references_n);

    code_lines = generate_boilerplate_top(dbname);

    code_lines += generate_constant_list(references_1, references_n);

    code_lines += generate_declarations();

    for (auto table_id : list_tables()) {
        field_vec field_strings;
        auto table_record = gaia_table_t::get(table_id);
        for (auto field_id : list_fields(table_id)) {
            gaia_field_t field_record(gaia_field_t::get(field_id));
            field_strings.push_back(field_strings_t{field_record.name(), static_cast<data_type_t>(field_record.type())});
        }
        for (auto ref_id : list_references(table_id)) {
            gaia_field_t ref_record = gaia_field_t::get(ref_id);
        }
        code_lines += generate_edc_struct(table_id, table_record.name(), field_strings, references_1[table_id], references_n[table_id]);
    }
    commit_transaction();

    code_lines += generate_boilerplate_bottom(dbname);

    return code_lines;
}
}
}
