namespace gaia.db.messages;

enum session_state_t: uint8 {
    ANY,
    CONNECTED,
    DISCONNECTED,
    TXN_IN_PROGRESS,
    TXN_COMMITTING,
}

enum session_event_t: uint8 {
    NOP,
    CONNECT,
    // For now we signal shutdown on either side by calling shutdown(SHUT_WR),
    // which makes the other side return 0 from read(). However, we might later
    // decide to signal shutdown in an explicit DISCONNECT message.
    CLIENT_SHUTDOWN,
    SERVER_SHUTDOWN,
    BEGIN_TXN,
    ROLLBACK_TXN,
    COMMIT_TXN,
    DECIDE_TXN_COMMIT,
    DECIDE_TXN_ABORT,
    REQUEST_STREAM,
    REQUEST_MEMORY,
}

// FlatBuffers doesn't allow scalar fields in a union.
table table_scan_info_t {
    type_id: uint64;
}

union request_data_t {
    table_scan: table_scan_info_t,
    memory_info: memory_allocation_info_t,
}

table client_request_t {
    event: session_event_t;
    data: request_data_t;
}

table stack_allocator_info_t {
    stack_allocator_offset: uint64;
    stack_allocator_size: uint64;
}

table memory_allocation_info_t {
    stack_allocator_list: [stack_allocator_info_t];
    // Number of stack allocators to request from the server.
    memory_request_size_hint: uint64;
}

// FlatBuffers doesn't allow scalar fields in a union.
table transaction_info_t {
    transaction_id: uint64;
}

union reply_data_t {
    transaction_info: transaction_info_t,
}

table server_reply_t {
    // This can either be the client's original request event,
    // or a server-generated event in response to the client's request.
    event: session_event_t;
    old_state: session_state_t;
    new_state: session_state_t;
    data: reply_data_t;
    session_memory_allocation_info: memory_allocation_info_t;
}

union any_message_t {
    request: client_request_t,
    reply: server_reply_t,
}

table message_t {
    msg: any_message_t;
}

root_type message_t;
