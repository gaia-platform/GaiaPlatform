namespace gaia.db.messages;

enum session_state_t: uint8 {
    ANY,
    CONNECTED,
    DISCONNECTED,
    TXN_IN_PROGRESS,
    TXN_COMMITTING,
}

enum session_event_t: uint8 {
    NOP,
    CONNECT,
    // For now we signal shutdown on either side by calling shutdown(SHUT_WR),
    // which makes the other side return 0 from read(). However, we might later
    // decide to signal shutdown in an explicit DISCONNECT message.
    CLIENT_SHUTDOWN,
    SERVER_SHUTDOWN,
    BEGIN_TXN,
    ROLLBACK_TXN,
    COMMIT_TXN,
    DECIDE_TXN_COMMIT,
    DECIDE_TXN_ABORT,
    REQUEST_STREAM,
    DECIDE_TXN_ROLLBACK_FOR_ERROR,
    CONNECT_DDL,
    CONNECT_PING,
}

union index_query_t {index_range_query_t, index_point_read_query_t, index_equal_range_query_t}

// Range queries return all results between the lower bound (inclusive) and the upper bound (inclusive).
// For range queries, unspecified keys mean that there is no lower/upper-bound.
// If both keys are unspecified, this query will be equivalent to a full scan.
//
// For exclusive bounds, do additional filtering on the client.
table index_range_query_t {
    lower_bound_key: [byte];
    upper_bound_key: [byte];
}

// A point read query returns at most a single result matching the specified key.
// The query can return no results.

table index_point_read_query_t {
    key: [byte];
}

// Returns all results matching a specified key.
table index_equal_range_query_t {
    key: [byte];
}

table index_scan_info_t {
    index_id: uint64;
    txn_id: uint64;
    query: index_query_t;
}

union request_data_t {
    index_scan: index_scan_info_t,
}

table client_request_t {
    event: session_event_t;
    data: request_data_t;
}

struct transaction_log_info_t {
    transaction_id: uint64;
    commit_timestamp: uint64;
    log_offset: uint16;
}

table transaction_info_t {
    transaction_id: uint64;
    transaction_log_offset: uint16;
    transaction_logs_to_apply: [transaction_log_info_t];
}

table transaction_error_t {
    error_message: string;
}

union reply_data_t {
    transaction_info: transaction_info_t,
    transaction_error: transaction_error_t,
}

table server_reply_t {
    // This can either be the client's original request event,
    // or a server-generated event in response to the client's request.
    event: session_event_t;
    old_state: session_state_t;
    new_state: session_state_t;
    data: reply_data_t;
}

union any_message_t {
    request: client_request_t,
    reply: server_reply_t,
}

table message_t {
    msg: any_message_t;
}

root_type message_t;
