/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include <iostream>
#include <fstream>

#include "gtest/gtest.h"

#include "flatbuffers/idl.h"

using namespace std;


const char* const c_fbs_filename = "test_record.fbs";
const char* const c_json_filename = "test_record_data.json";
const char* const c_programmatic_bin_filename = "programmatic_test_record_data.bin";
const char* const c_build_bin_filename = "test_record_data.bin";

TEST(flatbuffers, json_compilation)
{
    // Load flatbuffers schema.
    string schema;
    flatbuffers::LoadFile(c_fbs_filename, true, &schema);

    // Load JSON file.
    string json;
    flatbuffers::LoadFile(c_json_filename, true, &json);

    // Set up parser.
    flatbuffers::IDLOptions options;
    options.force_defaults = true;
    flatbuffers::Parser parser(options);

    // Parse schema.
    bool result = parser.Parse(schema.c_str());
    ASSERT_EQ(true, result);

    // We don't want to generate code for the schema.
    parser.MarkGenerated();

    // Parse JSON.
    result = parser.Parse(json.c_str());
    ASSERT_EQ(true, result);

    // Output serialization corresponding to JSON data.
    result = flatbuffers::SaveFile(
        c_programmatic_bin_filename,
        reinterpret_cast<char *>(parser.builder_.GetBufferPointer()),
        parser.builder_.GetSize(),
        true);
    ASSERT_EQ(true, result);

    // Load the serialization generated by the build using the flatc tool
    // (see command for producing target test_record_data_bin in CMakeLists.txt).
    string build_output;
    flatbuffers::LoadFile(c_build_bin_filename, true, &build_output);

    // Load the serialization that we just generated programmatically.
    string our_output;
    flatbuffers::LoadFile(c_programmatic_bin_filename, true, &our_output);

    // Check that the outputs are identical.
    ASSERT_EQ(build_output.size(), our_output.size());
    ASSERT_EQ(0, build_output.compare(our_output));
}
