// RUN: %gaiat %s --

#include "tags_test.h"

// #define TEST_FAILURES

ruleset test
{
}

ruleset test1
{
    on_update(min_temp)
    {
        min_temp += 1;
    }
}

ruleset test2
{
    on_update(max_temp)
    {
        max_temp++;
    }
}

ruleset test3
{
    on_update(animal.age)
    {
        animal.age++;
    }
}

typedef enum
{
    undefined = 0,
    actuators = 1,
    sensors = 2,
    incubators = 3
} hardware_type;

ruleset test5
{
    {
        if (@actuator.value < 5)
        {
            actuator.value = 5;
        }
    }
}

typedef enum
{
    values = 0,
    types = 1,
    defs = 2
} testEnum;

ruleset test6 : tables(sensor)
{
    {
        if (@value < 5)
        {
            value = 5;
        }
    }
}

class test
{
public:
    void delete_row()
    {
    }
};

// GAIAPLAT-911
ruleset test7
{
    on_change(sensor)
    {
        auto t = sensor.gaia_id();
        if (sensor.value == 5)
        {
            test t;
            t.delete_row();
        }
    }
}

ruleset test8
{
    {
        auto rule_name = rule_context.rule_name;
        auto ruleset_name = rule_context.ruleset_name;
        // NOTE: cannot use 'event_type' (hides catalog field entry of the same name).
        auto context_event_type = rule_context.event_type;
        auto gaia_type = rule_context.gaia_type;

        if (@actuator.value < 5 && sensor.value > 10)
        {
            actuator.value = 5;
        }
    }
}

void on_update()
{}

ruleset test9
{
    on_update(sensor)
    {
        on_update();
    }
}

ruleset test10
{
    on_insert(incubator)
    {
        min_temp = 98.6;
    }
}

// This is legal? But has error (duplicate 'name' fields).
// GAIAPLAT-796
#ifdef TEST_FAILURES
ruleset test11 : tables(sensor)
{
    on_update(name)
    {
        use_string(name);
    }
}
#endif

ruleset test12
{
    on_insert(sensor)
    {
        int i = 0;
        if (incubator.max_temp > 99.0)
        {
            i = 1;
        }
// GAIAPLAT-988
        nomatch
        {
            i = 2;
        }
    }
}

// Verify that these are all allowable rule constructs and don't
// incorrectly cause the translation engine to think that these
// are multi-anchor rules.
ruleset test13
{
    on_insert(sensor.value, sensor.timestamp)
    {
    }

    on_insert(sensor, sensor)
    {
    }

    on_change(sensor, sensor.timestamp)
    {
    }

    on_change(min_temp, max_temp)
    {
    }

    on_update(min_temp, max_temp)
    {
    }

    on_update(actuator, actuator)
    {
    }

    on_update(actuator, actuator.timestamp)
    {
    }

    {
        if (@actuator.value > 0 && @actuator.timestamp == 0)
        {
        }
    }
}
