// RUN: %gaiat %s --

#include "tags_test.h"

// #define TEST_FAILURES

// TESTCASE: for() with a table scan
ruleset test1
{
    OnInsert(incubator)
    {
        float temp = 0;
        for (/I:incubator)
        {
            temp += I.max_temp;
        }
    }
}

// GAIAPLAT-1042 (fixed)
// TESTCASE: Use for statement to scan a table near the anchor.
ruleset test1_1
{
    OnInsert(incubator)
    {
        float temp = 0;
        for (/S:sensor)
        {
            temp += S.value;
        }
    }
}

// TESTCASE: Use an implicit query in a for statement.
// NOTE: This implicit query from incubator to feeding goes through
//       raised and animal. This is the same distance as a path
//       that goes through farmer and yield. The selection of this
//       path is arbitrary, and would produce different results if
//       the other path was chosen. Should there be a warning?
// NOTE: Most recent decision is to make this an error. By rearranging
//       the order or table definitions in the DDL, the selection of
//       the implicit path may change - that would be bad. By making
//       this an error, the programmer can correct the code to have
//       an explicit component to the path.
// GAIAPLAT-1050 (fixed)
ruleset test1_2
{
    OnInsert(incubator)
    {
        int total_portion = 0;
        for (animal->F:feeding)
        {
            total_portion += F.portion;
        }
    }
}

// TESTCASE: Use for statement to scan a table not near the anchor.
ruleset test1_3
{
    OnInsert(incubator)
    {
        int total_portion = 0;
        for (/F:feeding)
        {
            total_portion += F.portion;
        }
    }
}

// TESTCASE: Path moves from M to 1 in if with nomatch.
// GAIAPLAT-1005 (fixed)
ruleset test1_4
{
    OnInsert(sensor)
    {
        if (sensor->incubator.min_temp < 95.0)
        {
            sensor.value += 3.0;
        }
        nomatch
        {
            sensor.value += 5;
        }
    }
}

// TESTCASE: Path moves from M to 1 in if without nomatch.
ruleset test1_5
{
    OnInsert(sensor)
    {
        if (sensor->incubator.min_temp < 95.0)
        {
            sensor.value += 3.0;
        }
    }
}

// TESTCASE: for() with an active field in the braces
ruleset test2
{
    {
        float temp = 0;
        // This looks like a loop, but the incubator is the anchor.
        for (incubator)
        {
            temp += @max_temp;
        }
    }
}

// TESTCASE: for-if with active field in the braces
ruleset test3
{
    {
        float temp = 0;
        for (I:incubator) if (I.min_temp < 50.0)
        {
            temp += @max_temp;
        }
    }
}

// TESTCASE: if() with active field in the braces
ruleset test4
{
    {
        float temp = 0;
        if (incubator.min_temp < 50.0)
        {
            temp += @max_temp;
        }
    }
}

// TESTCASE: if() with implicit iteration on an active field
ruleset test5
{
    {
        float temp = 0;
        if (incubator.min_temp < 50.0)
        {
            temp += @sensor.value;
        }
    }
}

// TESTCASE: if() with implicit iteration and OnInsert
ruleset test6
{
    OnInsert(incubator)
    {
        float temp = 0;
        if (incubator.min_temp < 50.0)
        {
            temp += sensor.value;
        }
    }
}

// TESTCASE: if-else with implicit iteration in both closures
ruleset test7
{
    OnInsert(incubator)
    {
        float temp = 0;
        if (incubator.min_temp < 50.0)
        {
            temp += sensor.value;
        }
        else
        {
            temp -= sensor.value;
        }
    }
}

// TESTCASE: if-else with navigation
ruleset test8
{
    // Questionable code generation on this one.
    OnInsert(incubator)
    {
        float temp = 0;
        // Navigates down to a child row (sensor), then back up to the parent (incubator),
        // and back down again to another child (actuator).
        if (sensor->incubator->actuator.value > 0.0)
        {
            temp += sensor.value;
        }
        else
        {
            temp -= sensor.value;
        }
    }
}

// TESTCASE: if-else-nomatch with navigation
ruleset test9
{
    OnInsert(incubator)
    {
        float temp = 0;
        if (sensor->incubator->actuator.value > 0.0)
        {
            temp += sensor.value;
        }
// GAIAPLAT-947 (fixed)
        else
        {
            temp -= sensor.value;
        }
// GAIAPLAT-988
        nomatch
        {
            temp += 10.0;
        }
    }
}

// TESTCASE: if-else navigation with tags
ruleset test10
{
    OnInsert(incubator)
    {
        float temp = 0;
        if (S:sensor->I:incubator->A:actuator.value > 0.0)
        {
            temp += S.value + I.min_temp + A.value;
        }
        else
        {
            temp -= I.max_temp - A.value - S.value;
        }
    }
}

// TESTCASE: if() and else-if() both with table scans and an active field in the if()
ruleset test11
{
    {
        int total_acres;
        if (/@F:farmer.acreage > 10)
        {
            total_acres = 10;
        }
        else if (/farmer.acreage < 5)
        {
            total_acres = 5;
        }
        else
        {
            total_acres = F.acreage;
        }
    }
}

// TESTCASE: if() with a table scan + active field and else-if() with navigation
ruleset test12
{
    {
        int total_acres;
        if (/@F:farmer.acreage > 10)
        {
            total_acres = 10;
        }
        else if (F->yield->crop.acres < 5)
        {
            total_acres = 5;
        }
        else
        {
            total_acres = F.acreage;
        }
    }
}

// TESTCASE: if-elseif tag scoping, using a function inside a declarative statement
int strcmp(const char*, const char*);

ruleset test13
{
    {
        int total_acres;
        if (@farmer->Y:yield->feeding.portion > 10)
        {
            total_acres = 10;
        }
        else if (strcmp(Y->farmer->raised.birthdate, "20140530") == 0)
        {
            total_acres = 5;
        }
        else
        {
            total_acres += Y->feeding.portion;
        }
    }
}

// TESTCASE: else-ifs with table scans unrelated to the OnInsert anchor row's table.
ruleset test14
{
    OnInsert(isolated)
    {
        int answer;
        if (/incubator->actuator.value > 0.5)
        {
            answer = 10;
        }
        else if (/farmer->yield.bushels > 10)
        {
            answer = 5;
        }
        else if (/raised->animal.age < 3)
        {
            answer += /feeding.portion;
        }
    }
}

// TESTCASE: multiple else-ifs with sequential nomatches.
ruleset test15
{
    OnInsert(isolated)
    {
        int answer;
        if (/incubator->actuator.value > 0.5)
        {
            answer = 10;
        }
        else if (/farmer->yield.bushels > 10)
        {
            answer = 5;
        }
        else if (/raised->animal.age < 3)
        {
            answer += /feeding.portion;
        }
// GAIAPLAT-988
        nomatch
        {
            answer = 15;
        }
        nomatch
        {
            answer = 30;
        }
        nomatch
        {
            answer = 20;
        }
    }
}

// TESTCASE: single-cardinality reference in for()
ruleset test16
{
    OnInsert(incubator)
    {
        for (int i = 0; i < farmer.acreage; i++)
        {
            farmer.acreage++;
        }
    }
}

// TESTCASE: multiple-cardinality reference in for() with tag declaration
ruleset test17
{
    OnInsert(incubator)
    {
        for (float f = 0.0; f < S:sensor.value; f += 1.3)
        {
            S.timestamp++;
        }
    }
}

// TESTCASE: braceless nested if-else-nomatches with implicit iteration
ruleset test18
{
    OnInsert(incubator)
    {
        bool here = false;
        if (incubator.max_temp > 99.0)
            if (actuator.value < 97.3)
                if (sensor.value > 82.1)
                    here = true;
// GAIAPLAT-988
                nomatch
                    here = false;
            else
                here = false;
            nomatch
                here = true;
        nomatch
            here = false;
    }
}

// TESTCASE: prodcedural for() but with a query on all three of its header statements
ruleset test19
{
    OnInsert(feeding)
    {
        // Another convoluted set of queries.
        // Note that the translated code is not yet correct.
        long some_number = 0;
        long i = 0;
        for (i += farmer.acreage; i < farmer->yield->feeding.portion; i += /crop.acres)
        {
            some_number += i;
        }
    }
}

// TESTCASE: expression with navigation on both sides
ruleset test20
{
    OnInsert(feeding)
    {
        // Note that the translated code is not yet correct.
        farmer->incubator->raised.birthdate += crop->yield->feeding.portion;
    }
}

// TESTCASE: navigation with tags in function parameters
void sprintf(char*, const char*, const char*, float, float);

ruleset test21
{
    OnInsert(feeding)
    {
        char str[200];
        sprintf(str, "%ld,%f,%f", farmer->I:incubator->raised.birthdate, I->A:actuator.value, A->incubator->sensor.value);
    }
}

// TESTCASE: declaring a tag in the OnInsert statement
ruleset test22
{
    OnInsert(I:incubator)
    {
        if (incubator.max_temp > 99.8)
        {
            I.min_temp -= 1.0;
        }
        nomatch
        {
            I.min_temp = 97.0;
        }
    }
}

// TESTCASE: implicit iteration in if-else-nomatch from a navigation path
ruleset test23
{
    OnInsert(incubator)
    {
        float temp = 0;
        if (incubator->raised->animal->feeding.portion > 1)
        {
            temp += sensor.value;
        }
        else
        {
            temp -= sensor.value;
        }
        nomatch
        {
            temp += 10.0;
        }
    }
}

// TESTCASE: checking if procedural while() and if() still work
ruleset test24
{
    OnInsert(incubator)
    {
        const char* s = "just a string";
        int i = 0;
        while (*s++)
        {
            max_temp += 1;
        }
        if (i < 5)
        {
            i = 1;
        }
    }
}

// TESTCASE: declarative statement inside a braceless procedural while()
ruleset test25
{
    OnInsert(incubator)
    {
        const char* s = "just a string";
        int i = 0;
        while (*s++)
            max_temp += 1;
    }
}

// TESTCASE: delcaring a tag in an if() and using it in the else{} and nomatch{}
ruleset test26
{
    {
        int total_acres;
        if (/@F:farmer.acreage > 10)
        {
            total_acres = 10;
        }
        else if (/farmer.acreage < 5)
        {
            total_acres = 5;
        }
        else
        {
            total_acres = F.acreage;
        }
        nomatch
        {
            // This nomatch is for the inner 'if' so F is in scope
            total_acres = F.acreage;
        }
    }
}

// TESTCASE: procedural do-while that does not reference any rows
ruleset test27
{
    OnInsert(incubator)
    {
        int count = 0;
        do
        {
            count += 1;
        }
        while (count < 10);
    }
}

// TESTCASE: procedural do-while referencing an active field on the anchor row
ruleset test28
{
    {
        int count = 0;
        do
        {
            count += 1;
        }
        while (@animal.age < 10);
    }
}

// TESTCASE: procedural do-while using a tag declared in the OnInsert
ruleset test29
{
    OnInsert(A:animal)
    {
        int count = 0;
        do
        {
            count += A.age;
        }
        while (A.age > 0);
    }
}

// TESTCASE: procedural do-while with a tag used in the do{} but not the while()
ruleset test30
{
    OnInsert(A:animal)
    {
        int count = 0;
        do
        {
            count += A.age;
        }
        while (count < 10);
    }
}

// TESTCASE: declaring a tag in an if() and using it in a while()
ruleset test31
{
    {
        if (@C:crop.acres > 10)
        {
            int num = 0;
            while (C.acres > num)
            {
                num += C.acres;
            }
        }
    }
}

// TESTCASE: declaring a tag in an if() and using it in a do-while
ruleset test32
{
    {
        if (@C:crop.acres > 10)
        {
            int num = 0;
            do
            {
                num += C.acres;
            }
            while (C.acres > num);
        }
    }
}

// TESTCASE: declaring and using a tag inside the do{} of a do-while
ruleset test33
{
    OnInsert(animal)
    {
        int num = 0;
        do
        {
            if(A:animal.age > 10)
            {
                num += A.age;
            }
        }
        while(num < 10);
    }
}

#ifdef FUTURE_SUCCESS

// TESTCASE: 1-to-1 navigation in a while() is legal
ruleset future_success_test_1
{
    OnInsert(TODO_PARENT)
    {
        int num = 0;
        while(TODO_PARENT->TODO_CHILD.TODO_FIELD < 10)
        {
            num++;
        }
    }
}

// TESTCASE: 1-to-1 navigation in a do-while is legal
ruleset future_success_test_2
{
    OnInsert(TODO_PARENT)
    {
        int num = 0;
        do
        {
            num++;
        }
        while(TODO_PARENT->TODO_CHILD.TODO_FIELD < 10);
    }
}

#endif // #ifdef FUTURE_SUCCESS

#define SHOULD_FAIL

#ifdef SHOULD_FAIL

// TESTCASE: while() with navigation and tags
ruleset fail_test2
{
    OnInsert(incubator)
    {
        float temp = 0;
        while (S:sensor->I:incubator->A:actuator.value > 0.0)
        {
            temp += S.value + I.min_temp + A.value;
        }
    }
}

// TESTCASE: nested while() loops with navigation and tags
ruleset fail_test3
{
    OnInsert(incubator)
    {
        float temp = 0;
        while (S:sensor->I:incubator->A:actuator.value > 0.0)
        {
            while (A->II:incubator->SS:sensor.value < 100.0)
            {
                temp += S.value + II.min_temp + A.value;
            }
        }
    }
}

// TESTCASE: if() inside of while(), both with complex navigation, using OnInsert
ruleset fail_test4
{
    OnInsert(farmer)
    {
        float temp = 0;
        while (farmer->incubator->raised->animal->feeding->yield->crop.acres)
        {
            if (farmer->yield->feeding->animal->raised->incubator.max_temp < 100.0)
            {
                temp += 1.0;
            }
        }
    }
}

// TESTCASE: if() inside of while(), both with complex navigation, active field in the while()
ruleset fail_test5
{
    {
        float temp = 0;
        while (@farmer->incubator->raised->animal->feeding->yield->crop.acres)
        {
            if (farmer->yield->feeding->animal->raised->incubator.max_temp < 100.0)
            {
                temp += 1.0;
            }
        }
    }
}

// TESTCASE: arbitrarily deep navigation with tags in a for() containing a while()
ruleset fail_test6
{
    OnInsert(incubator)
    {
        long tot_acres = 0;
        long tot_feed = 0;
        long tot_age = 0;
        for (int i = 0; i < /F:farmer->R:raised->A:animal->FE:feeding->Y:yield->C:crop.acres; i++)
        {
            tot_acres = crop.acres;
            while (A->FE2:feeding.portion > 0)
            {
                tot_feed += FE2.portion;
            }
            tot_age += Y->feeding->animal.age;
        }
    }
}

// TESTCASE: braceless while() with tag declarations
ruleset fail_test7
{
    OnInsert(incubator)
    {
        float temp = 0;
        while (S:sensor->I:incubator->A:actuator.value > 0.0)
            temp += S.value + I.min_temp + A.value;
    }
}

// TESTCASE: nested procedural and declarative while()s and an if()
ruleset fail_test8
{
    OnInsert(incubator)
    {
        const char* s = "just a string";
        int i = 0;
        while (*s++) {
            while (/incubator.max_temp > 0) {
                while(*s++) {
                    if (*s == ' ') {
                        break;
                    }
                }
            }
        }
    }
}

// TESTCASE: declarative do-while containing an if() that declares a tag
ruleset fail_test10
{
    OnUpdate(incubator)
    {
        int count = 0;
        do
        {
            if (A:actuator.value > 0.0)
            {
                count += 1;
            }
        }
        while (sensor.value > 0.0);
    }
}

// TESTCASE: declarative do-while with a full-table scan
ruleset fail_test11
{
    OnInsert(incubator)
    {
        int count = 0;
        do
        {
            count += 1;
        }
        while (/sensor.value > 0.0);
    }
}

// TESTCASE: do-while with an active field and a table scan in the while()
ruleset fail_test12
{
    {
        int count = 0;
        do
        {
            count += 1;
        }
        while (/@animal.age < 10);
    }
}

// TESTCASE: do-while with a table scan in the while() over the child table of the anchor row's table
ruleset fail_test13
{
    OnInsert(incubator)
    {
        int count = 0;
        do
        {
            count += 1;
        }
        while (/sensor.value > 0.0);
    }
}

// TESTCASE: nested declarative do-while loops
ruleset fail_test14
{
    OnInsert(I:incubator)
    {
        int count_a = 0;
        do
        {
            int count_b = 0;

            do
            {
                int count_c = 0;

                do
                {
                    count_c += 1;
                } while (strcmp(raised.birthdate, "") != 0);

                count_b += 1;
            } while (actuator.value < 10);

            count_a += 1;
        }
        while (sensor.value > 0.0);
    }
}

// TESTCASE: arbitrarily complex navigation in the while() statement of a do-while
ruleset fail_test15
{
    OnInsert(farmer)
    {
        int count = 0;
        do
        {
            count++;
        }
        while (farmer->raised->animal->feeding->yield->crop.acres < 10);
    }
}

// TESTCASE: procedural for() with a declarative query inside a do-while
ruleset fail_test16
{
    OnInsert(incubator)
    {
        do
        {
            for (int i = 0; i < farmer.acreage; i++)
            {
                farmer.acreage++;
            }
        } while (sensor.value > 0.0);
    }
}

#endif // #ifdef SHOULD_FAIL

// TESTCASE: break from within a declarative if.
// GAIAPLAT-1053
#ifdef TEST_FAILURES
ruleset test_1
{
    OnInsert(incubator)
    {
        if (S:sensor.value > 99.9)
        {
            break;
        }
        else
        {
            S.value += 0.5;
        }
    }
}
#endif

// TESTCASE: break from within the nomatch block of a declarative if.
#ifdef TEST_FAILURES
ruleset test_2
{
    OnInsert(incubator)
    {
        if (S:sensor.value > 99.9)
        {
            S.value -= 0.5;
        }
        else
        {
            S.value += 0.5;
        }
        nomatch
        {
            break;
        }
    }
}
#endif

// TESTCASE: break from within a declarative for.
ruleset test_3
{
    OnInsert(incubator)
    {
        for (S:sensor) if (S.value > 99.9)
        {
            break;
        }
        else
        {
            S.value += 0.5;
        }
    }
}

// TESTCASE: break from within a nested declarative for.
// GAIAPLAT-1056
ruleset test_4
{
    OnInsert(incubator)
    {
        for (S:sensor)
        {
            for (S->incubator->farmer->Y:yield)
            {
                if (Y.bushels > 10)
                {
                    break;
                }
            }
            int i = 0;
        }
    }
}

void printf(const char*, unsigned int);

// TESTCASE: mix up declarative for with switch statement
// GAIAPLAT-1084 (fixed)
ruleset test34
{
    OnUpdate(farmer)
    {
        for (F:feeding)
        {
            switch (F.portion)
            {
            default:
                F.portion += 1;
                printf("%d\n", F.portion);
            }
        }
    }
}

// TESTCASE: while with an anchor field condition
ruleset test35
{
    OnUpdate(incubator)
    {
        while (incubator.max_temp < 100.0)
        {
            incubator.max_temp += 5.0;
        }
    }
}

ruleset test36
{
    OnUpdate(incubator)
    {
        int maxtemp = incubator.max_temp;
        while (maxtemp < 100.0)
        {
            maxtemp += 5.0;
        }
        incubator.max_temp = maxtemp;
    }
}

ruleset test37
{
    OnUpdate(incubator)
    {
        for (S:sensor)
        {
            while (S.value < 100.0)
            {
                S.value += 5.0;
            }
        }
    }
}

ruleset test38
{
    OnUpdate(incubator)
    {
        for (S:sensor)
        {
            float val;
            val = S.value;
            while (val < 100.0)
            {
                val += 5.0;
            }
            S.value = val;
        }
    }
}
