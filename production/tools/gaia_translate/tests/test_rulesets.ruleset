/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include <string>
#include <cstring>
#include <atomic>

#include "test_rulesets.hpp"

bool g_oninsert_called;
bool g_oninsert2_called;
bool g_oninsert3_called;
bool g_onchange_called;
bool g_onchange2_called;
bool g_onupdate_called;
bool g_onupdate2_called;
bool g_onupdate3_called;
bool g_onupdate4_called;
test_error_result_t g_oninsert_result;
test_error_result_t g_oninsert2_result;
test_error_result_t g_oninsert3_result;
test_error_result_t g_onchange_result;
test_error_result_t g_onchange2_result;
test_error_result_t g_onupdate_result;
test_error_result_t g_onupdate2_result;
test_error_result_t g_onupdate3_result;
test_error_result_t g_onupdate4_result;
int32_t g_oninsert_value;
int32_t g_oninsert2_value;
int32_t g_oninsert3_value;
int32_t g_onupdate3_value;
std::string g_string_value;

std::atomic<int32_t> g_onupdate_value;
std::atomic<int32_t> g_insert_count;

ruleset test_tags
{
    // test_tags_code.oninsert
    // test_tags_code.multi_inserts
    OnInsert(student)
    {
        g_insert_count++;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }

    // test_tags_code.oninsert
    OnInsert(S:student)
    {
        g_oninsert2_value = S.age;
        g_oninsert2_result = test_error_result_t::e_none;
        g_oninsert2_called = true;
    }

    // test_tags_code.basic_tags
    OnInsert(R:registration)
    {
        // Check common field references.
        if (strcmp(R.reg_id, reg_id) != 0)
        {
            g_oninsert3_result = test_error_result_t::e_tag_field_mismatch;
        }
        else if (strcmp(reg_id, registration.reg_id) != 0)
        {
            g_oninsert3_result = test_error_result_t::e_tag_field_mismatch;
        }
        else {
            g_oninsert3_result = test_error_result_t::e_none;
        }
        g_oninsert3_called = true;
    }

    // test_tags_code.oninsert
    // test_tags_code.onchange
    // test_tags_code.onupdate
    OnChange(student)
    {
        g_onchange_result = test_error_result_t::e_none;
        g_onchange_called = true;
    }

    // test_tags_code.oninsert
    // test_tags_code.onupdate
    OnChange(student.age)
    {
        g_onchange2_result = test_error_result_t::e_none;
        g_onchange2_called = true;
    }

    // test_tags_code.onchange
    // test_tags_code.onupdate
    OnUpdate(student)
    {
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }

    // test_tags_code.onchange
    OnUpdate(student.surname)
    {
        g_onupdate2_result = test_error_result_t::e_none;
        g_onupdate2_called = true;
    }

    // test_tags_code.onupdate
    OnUpdate(student.age)
    {
        g_onupdate3_value = age;
        g_onupdate3_result = test_error_result_t::e_none;
        g_onupdate3_called = true;
    }

    // test_tags_code.onchange
    // test_tags_code.onupdate
    OnUpdate(student.age, student.surname)
    {
        g_onupdate4_result = test_error_result_t::e_none;
        g_onupdate4_called = true;
    }
}

ruleset test_queries
{
    // This rule is patterned after an example in the document "Paths and
    // Tags in Declarative Rules". Pseudo-code will be used until the
    // translator is done.

    // test_queries_code.new_registration
    OnInsert(R:registration)
    {
        // printf("OnInsert(registration) = %s\n", registration.reg_id);
        // printf("course name=%s\n", course.name);
        status = "Ineligible";
        // Has this student taken all prerequisites?
        //>for (course.requires->prereq.prereq->PC:course) {
        //>    bool taken = false;
        //>    for (student->registration->TC:course) {
        //>        if (TC.courseId == PC.courseId) {
        //>            taken = true;
        //>            break;
        //>        }
        //>    }
        //>    if (!taken) {
        //>        printf("student has not taken course %s\n", PC.courseId);
        //>        return;
        //>    }
        //>}
        //
        // Has this student passed all prerequisites with minimum grades?
        //>for (course.requires->P:prereq.required_by->course->R:registration->S:student) {
        //>    if (student_id == S.student_id) {
        //>    if (R:Grade < P.MinGrade) {
        //>        return;
        //>    }
        //>}
        status = "Eligible";

        g_insert_count++;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }

    // test_queries_code.sum_of_ages
    OnInsert(S:student)
    {
        int32_t age_sum = 0;
        age_sum += /student.age;
        g_oninsert2_value = age_sum;
        g_oninsert2_result = test_error_result_t::e_none;
        g_oninsert2_called = true;
    }

    // test_queries_code.basic_implicit_navigation
    // test_queries_code.basic_implicit_fork
    OnUpdate(S:student)
    {
        // Implicit query from student to course.
        // Result should be the total of hours for all courses taken by student.
        int32_t hours_total = 0;
        hours_total += hours;
        g_onupdate_value = hours_total;
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }

    OnUpdate (registration)
    {
        g_onupdate_value = total_hours + hours;
        g_onupdate_called = true;
    }
}

ruleset test_query_1
{
    // test_queries_code.sum_of_hours
    // Auto-sum of student hours.
    OnInsert(registration)
    {
        total_hours = 0;
        // Both 'total_hours' and 'hours' are single-cardinality implicit test_queries
        // from the registration row.
        total_hours += hours;
        g_oninsert_value = total_hours;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }
}

ruleset test_query_2
{
    // test_queries_code.sum_of_all_hours
    // Auto-sum of student hours.
    OnInsert(registration)
    {
        total_hours = 0;
        // Visit all courses in which the student is registered.
        total_hours += student->registration->course.hours;
        g_oninsert_value = total_hours;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }
}

// GAIAPLAT-950
ruleset test_query_3
{
    // test_queries_code.tag_define_use
    OnInsert(registration)
    {
        // Visit all courses in which the student is registered. Use the tags.
        S:student->R:registration->C:course.hours = S.total_hours + C.hours;

        g_oninsert_value = 0;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }

    OnUpdate(course.hours)
    {
        // When this rule is fired, we know that the commit for the
        // insertion of a registration rule fired and can proceed with verifying
        // the course hours in the test.
        g_onupdate_called = true;
    }
}

ruleset test_query_4
{
    // test_queries_code.if_stmt
    OnInsert(student)
    {
        int a = 0;
        if (total_hours > 10)
        {
            a += age;
        }
        g_oninsert_value = a;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }

    // test_queries_code.if_stmt2
    // Forward chaining rule. Stops when hours are 1.
    {
        if (@hours > 1)
        {
            hours -= 1;
            total_hours += 1;
        }
        else
        {
            // This should only happen the last time.
            g_onupdate_result = test_error_result_t::e_none;
            g_onupdate_called = true;
        }
        g_onupdate_value++;
    }

    // test_queries_code.if_stmt3
    {
        if (strcmp(@student->G:registration.grade, "C") == 0)
        {
            student.gpa *= 1.1;
        }
        else
        {
            student.gpa *= 0.9;
        }
        nomatch
        {
            student.gpa = 0.0;
        }
        g_onupdate_value = int(10*student.gpa);
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }
}

ruleset test_query_5
{
    OnUpdate(S:student)
    {
// GAIAPLAT-989
        while (student->R:registration->C:course.hours > 0)
        {
            g_string_value += std::string(S.student_id) + std::string(R.reg_id) + std::string(C.course_id) + " ";
        }
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }
}
// NOTE: alter above to
//        while (S:student->R:registration->C:course.hours > 0)
//        {
//            g_string_value += std::string(S.student_id) + std::string(R.reg_id) + std::string(C.course_id) + " ";

ruleset test_query_6
{
    OnUpdate(student)
    {
        if (strcmp(surname, "Richard") == 0)
        {
            g_string_value = std::string("found Richard");
        }
        else
        {
            g_string_value = std::string("failure");
        }
        nomatch
        {
            g_string_value = std::string("nomatch failure");
        }
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }

    OnInsert(student)
    {
        if (student->registration->course.hours > 0)
        {
            g_string_value = std::string("found hours > 0");
        }
        else
        {
            g_string_value = std::string("found hours <= 0");
        }
        nomatch
        {
            g_string_value = std::string("nomatch success");
        }
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }
}

ruleset test_query_7
{
    OnInsert(registration)
    {
        if (student.total_hours == 0)
        {
            g_string_value = std::string("found total_hours == 0");
        }
        // Note that the registration is not connected to a course.
        else if (course.hours > 0)
        {
            g_string_value = std::string("found hours > 0");
        }
        else
        {
            g_string_value = std::string("didn't find hours > 0");
        }
        nomatch
        {
            g_string_value = std::string("correct nomatch");
        }
        nomatch
        {
            g_string_value = std::string("incorrect nomatch");
        }
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }
}

ruleset test_query_8
{
    OnInsert(student)
    {
        // This student will have no registrations. The nomatch should execute.
        if (strcmp(student->registration.grade, "F") == 0)
        {
            g_string_value = std::string("found grade 'F' > 0");
        }
        else
        {
            g_string_value = std::string("found grade != 'F'");
        }
        nomatch
        {
            g_string_value = std::string("nomatch success");
        }
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }
}
