/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include <atomic>

#include "gaia_prerequisites.h"
#include "test_rulesets.hpp"

using namespace gaia::prerequisites;

bool g_oninsert_called;
bool g_oninsert2_called;
bool g_oninsert3_called;
bool g_onchange_called;
bool g_onchange2_called;
bool g_onupdate_called;
bool g_onupdate2_called;
bool g_onupdate3_called;
bool g_onupdate4_called;
test_error_result_t g_oninsert_result;
test_error_result_t g_oninsert2_result;
test_error_result_t g_oninsert3_result;
test_error_result_t g_onchange_result;
test_error_result_t g_onchange2_result;
test_error_result_t g_onupdate_result;
test_error_result_t g_onupdate2_result;
test_error_result_t g_onupdate3_result;
test_error_result_t g_onupdate4_result;
int32_t g_oninsert_value;
int32_t g_oninsert2_value;
int32_t g_oninsert3_value;
int32_t g_onupdate_value;
int32_t g_onupdate3_value;

std::atomic<int32_t> g_insert_count;

ruleset test_tags
{
    OnInsert(student)
    {
        g_insert_count++;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }

    OnInsert(S:student)
    {
        g_oninsert2_value = S.age;
        g_oninsert2_result = test_error_result_t::e_none;
        g_oninsert2_called = true;
    }

    OnInsert(R:registration)
    {
        // Check common field references.
        if (strcmp(R.reg_id, reg_id) != 0)
        {
            g_oninsert3_result = test_error_result_t::e_tag_field_mismatch;
        }
        else if (strcmp(reg_id, registration.reg_id) != 0)
        {
            g_oninsert3_result = test_error_result_t::e_tag_field_mismatch;
        }
        else {
            g_oninsert3_result = test_error_result_t::e_none;
        }
        g_oninsert3_called = true;
    }

    OnChange(student)
    {
        g_onchange_result = test_error_result_t::e_none;
        g_onchange_called = true;
    }

    OnChange(student.age)
    {
        g_onchange2_result = test_error_result_t::e_none;
        g_onchange2_called = true;
    }

    OnUpdate(student)
    {
        g_onupdate_result = test_error_result_t::e_none;
        g_onupdate_called = true;
    }

    OnUpdate(student.surname)
    {
        g_onupdate2_result = test_error_result_t::e_none;
        g_onupdate2_called = true;
    }

    OnUpdate(student.age)
    {
        g_onupdate3_value = age;
        g_onupdate3_result = test_error_result_t::e_none;
        g_onupdate3_called = true;
    }

    OnUpdate(student.age, student.surname)
    {
        g_onupdate4_result = test_error_result_t::e_none;
        g_onupdate4_called = true;
    }
}

ruleset test_queries
{
    // This rule is patterned after an example in the document "Paths and
    // Tags in Declarative Rules". Pseudo-code will be used until the
    // translator is done.

    OnInsert(R:registration)
    {
        // printf("OnInsert(registration) = %s\n", registration.reg_id);
        // printf("Course name=%s\n", Course.Name);
        status = "Ineligible";
        // Has this student taken all prerequisites?
        //>for (Course.requires->prereq.required_by->PC:Course) {
        // for (const auto& p : Course.requires) {
        //>    bool taken = false;
        //>    for (student->registration->TC:Course) {
        //>        if (TC.CourseId == PC.CourseId) {
        //>            taken = true;
        //>            break;
        //>        }
        //>    }
        //>    if (!taken) {
        //>        printf("student has not taken course %s\n", PC.CourseId);
        //>        return;
        //>    }
        //>}
        //
        // Has this student passed all prerequisites with minimum grades?
        //>for (Course.requires->P:prereq.required_by->Course->R:registration->S:student) {
        //>    if (student_id == S.student_id) {
        //>    if (R:Grade < P.MinGrade) {
        //>        return;
        //>    }
        //>}
        status = "Eligible";

        g_insert_count++;
        g_oninsert_result = test_error_result_t::e_none;
        g_oninsert_called = true;
    }

    OnInsert(S:student)
    {
        int32_t age_sum = 0;
        // +++ Explicit navigation expression.
        // GAIAPLAT-915
        // age_sum += /student.age;
        // --- Current equivalent.
        for (const auto& s : student_t::list())
        {
            age_sum += s.age();
        }

        g_oninsert2_value = age_sum;

        g_oninsert2_result = test_error_result_t::e_none;
        g_oninsert2_called = true;
    }

    OnUpdate(S:student)
    {
        // Implicit query from student to Course.
        // Result should be the total of hours for all Courses taken by student.
        // This code should eventually work
        if (false)
        {
            int32_t hours = 0;
            hours += hours;
            g_onupdate_value = hours;
            g_onupdate_result = test_error_result_t::e_none;
            g_onupdate_called = true;
        }
        else
        {
            // Temporary code:
            g_onupdate_value += hours;
        }
    }

    OnUpdate (registration)
    {
        g_onupdate_value = total_hours + hours;
    }
}
