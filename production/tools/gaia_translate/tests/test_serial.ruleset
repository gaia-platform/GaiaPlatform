#include "gaia/logger.hpp"
#include "gaia/events.hpp"

// #define TEST_FAILURES
#include <atomic>
#include <unistd.h>

std::atomic<int32_t> g_rule_called;
std::atomic<int32_t> g_insert_called;
std::atomic<int32_t> g_update_min_temp_called;
std::atomic<int32_t> g_update_max_temp_called;
std::atomic<int32_t> g_update_value_called;
std::atomic<int32_t> g_update_timestamp_called;

// TODO: think of a deterministic way to cause a concurrency violation instead of using usleep below.
ruleset test_serial_1A : SerialStream(A)
{
    // If these rules run in parallel then only one will run
    // and the other will have a concurrency violation.  This
    // test requires that the 'gaia.conf' configuration setting
    // 'thread_pool_count' is not equal to 1.
    OnInsert(incubator)
    {
        gaia_log::app().warn("[rule-1] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        usleep(5000);
        min_temp += min_temp;
        g_rule_called++;
    }
}

ruleset test_serial_2A : SerialStream(A)
{
    // If these rules run in parallel then only one will run
    // and the other will have a concurrency violation.  This
    // test requires that the 'gaia.conf' configuration setting
    // 'thread_pool_count' is not equal to 1.
    OnInsert(incubator)
    {
        gaia_log::app().warn("[rule-2] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        usleep(5000);
        max_temp += max_temp;
        g_rule_called++;
    }
}

ruleset test_serial_1B : SerialStream(B)
{
    // If these rules run in parallel then only one will run
    // and the other will have a concurrency violation.  This
    // test requires that the 'gaia.conf' configuration setting
    // 'thread_pool_count' is not equal to 1.
    OnInsert(sensor)
    {
        gaia_log::app().warn("[rule-3] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        usleep(5000);
        sensor.value += sensor.value;
        g_rule_called++;
    }
}

ruleset test_serial_2B : SerialStream(B)
{
    // If these rules run in parallel then only one will run
    // and the other will have a concurrency violation.  This
    // test requires that the 'gaia.conf' configuration setting
    // 'thread_pool_count' is not equal to 1.
    OnInsert(sensor)
    {
        gaia_log::app().warn("[rule-4] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        usleep(5000);
        sensor.timestamp += sensor.timestamp;
        g_rule_called++;
    }
}

ruleset test_parallel
{
    OnUpdate(incubator.max_temp)
    {
        gaia_log::app().warn("[rule-5] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        g_rule_called++;
        g_update_max_temp_called++;
    }

    OnUpdate(incubator.min_temp)
    {
        gaia_log::app().warn("[rule-6] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        g_rule_called++;
        g_update_min_temp_called++;
    }

    OnUpdate(sensor.value)
    {
        gaia_log::app().warn("[rule-7] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        g_rule_called++;
        g_update_value_called++;
    }

    OnUpdate(sensor.timestamp)
    {
        gaia_log::app().warn("[rule-8] begin {} {} {} {}", rule_context.ruleset_name, rule_context.rule_name, rule_context.event_type, rule_context.gaia_type);
        g_rule_called++;
        g_update_timestamp_called++;
    }
}