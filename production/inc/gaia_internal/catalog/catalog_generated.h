// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_INTERNAL_H_
#define FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_INTERNAL_H_

#include "flatbuffers/flatbuffers.h"

#include "gaia/direct_access/nullable_string.hpp"

namespace gaia {
namespace catalog {
namespace internal {

struct gaia_index;
struct gaia_indexBuilder;
struct gaia_indexT;

struct gaia_rule;
struct gaia_ruleBuilder;
struct gaia_ruleT;

struct gaia_ruleset;
struct gaia_rulesetBuilder;
struct gaia_rulesetT;

struct gaia_relationship;
struct gaia_relationshipBuilder;
struct gaia_relationshipT;

struct gaia_field;
struct gaia_fieldBuilder;
struct gaia_fieldT;

struct gaia_table;
struct gaia_tableBuilder;
struct gaia_tableT;

struct gaia_database;
struct gaia_databaseBuilder;
struct gaia_databaseT;

struct gaia_indexT : public flatbuffers::NativeTable {
  typedef gaia_index TableType;
  gaia::direct_access::nullable_string_t name;
  bool unique;
  uint8_t type;
  std::vector<uint64_t> fields;
  gaia_indexT()
      : unique(false),
        type(0) {
  }
};

struct gaia_index FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_indexT NativeTableType;
  typedef gaia_indexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_UNIQUE = 6,
    VT_TYPE = 8,
    VT_FIELDS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool unique() const {
    return GetField<uint8_t>(VT_UNIQUE, 0) != 0;
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<uint64_t> *fields() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_FIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_UNIQUE) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.EndTable();
  }
  gaia_indexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_indexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_index> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_indexBuilder {
  typedef gaia_index Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_index::VT_NAME, name);
  }
  void add_unique(bool unique) {
    fbb_.AddElement<uint8_t>(gaia_index::VT_UNIQUE, static_cast<uint8_t>(unique), 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(gaia_index::VT_TYPE, type, 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> fields) {
    fbb_.AddOffset(gaia_index::VT_FIELDS, fields);
  }
  explicit gaia_indexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_indexBuilder &operator=(const gaia_indexBuilder &);
  flatbuffers::Offset<gaia_index> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_index>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_index> Creategaia_index(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool unique = false,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> fields = 0) {
  gaia_indexBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_name(name);
  builder_.add_type(type);
  builder_.add_unique(unique);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_index> Creategaia_indexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool unique = false,
    uint8_t type = 0,
    const std::vector<uint64_t> *fields = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fields__ = fields ? _fbb.CreateVector<uint64_t>(*fields) : 0;
  return gaia::catalog::internal::Creategaia_index(
      _fbb,
      name__,
      unique,
      type,
      fields__);
}

flatbuffers::Offset<gaia_index> Creategaia_index(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_ruleT : public flatbuffers::NativeTable {
  typedef gaia_rule TableType;
  gaia::direct_access::nullable_string_t name;
  gaia_ruleT() {
  }
};

struct gaia_rule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_ruleT NativeTableType;
  typedef gaia_ruleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  gaia_ruleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_ruleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_rule> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_ruleBuilder {
  typedef gaia_rule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_rule::VT_NAME, name);
  }
  explicit gaia_ruleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_ruleBuilder &operator=(const gaia_ruleBuilder &);
  flatbuffers::Offset<gaia_rule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_rule>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_rule> Creategaia_rule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  gaia_ruleBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_rule> Creategaia_ruleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::internal::Creategaia_rule(
      _fbb,
      name__);
}

flatbuffers::Offset<gaia_rule> Creategaia_rule(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_rulesetT : public flatbuffers::NativeTable {
  typedef gaia_ruleset TableType;
  gaia::direct_access::nullable_string_t name;
  bool active_on_startup;
  std::vector<uint64_t> table_ids;
  gaia::direct_access::nullable_string_t source_location;
  gaia::direct_access::nullable_string_t serial_stream;
  gaia_rulesetT()
      : active_on_startup(false) {
  }
};

struct gaia_ruleset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_rulesetT NativeTableType;
  typedef gaia_rulesetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ACTIVE_ON_STARTUP = 6,
    VT_TABLE_IDS = 8,
    VT_SOURCE_LOCATION = 10,
    VT_SERIAL_STREAM = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool active_on_startup() const {
    return GetField<uint8_t>(VT_ACTIVE_ON_STARTUP, 0) != 0;
  }
  const flatbuffers::Vector<uint64_t> *table_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_TABLE_IDS);
  }
  const flatbuffers::String *source_location() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_LOCATION);
  }
  const flatbuffers::String *serial_stream() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIAL_STREAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE_ON_STARTUP) &&
           VerifyOffset(verifier, VT_TABLE_IDS) &&
           verifier.VerifyVector(table_ids()) &&
           VerifyOffset(verifier, VT_SOURCE_LOCATION) &&
           verifier.VerifyString(source_location()) &&
           VerifyOffset(verifier, VT_SERIAL_STREAM) &&
           verifier.VerifyString(serial_stream()) &&
           verifier.EndTable();
  }
  gaia_rulesetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_ruleset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_rulesetBuilder {
  typedef gaia_ruleset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_ruleset::VT_NAME, name);
  }
  void add_active_on_startup(bool active_on_startup) {
    fbb_.AddElement<uint8_t>(gaia_ruleset::VT_ACTIVE_ON_STARTUP, static_cast<uint8_t>(active_on_startup), 0);
  }
  void add_table_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> table_ids) {
    fbb_.AddOffset(gaia_ruleset::VT_TABLE_IDS, table_ids);
  }
  void add_source_location(flatbuffers::Offset<flatbuffers::String> source_location) {
    fbb_.AddOffset(gaia_ruleset::VT_SOURCE_LOCATION, source_location);
  }
  void add_serial_stream(flatbuffers::Offset<flatbuffers::String> serial_stream) {
    fbb_.AddOffset(gaia_ruleset::VT_SERIAL_STREAM, serial_stream);
  }
  explicit gaia_rulesetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_rulesetBuilder &operator=(const gaia_rulesetBuilder &);
  flatbuffers::Offset<gaia_ruleset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_ruleset>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool active_on_startup = false,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> table_ids = 0,
    flatbuffers::Offset<flatbuffers::String> source_location = 0,
    flatbuffers::Offset<flatbuffers::String> serial_stream = 0) {
  gaia_rulesetBuilder builder_(_fbb);
  builder_.add_serial_stream(serial_stream);
  builder_.add_source_location(source_location);
  builder_.add_table_ids(table_ids);
  builder_.add_name(name);
  builder_.add_active_on_startup(active_on_startup);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_ruleset> Creategaia_rulesetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool active_on_startup = false,
    const std::vector<uint64_t> *table_ids = nullptr,
    const char *source_location = nullptr,
    const char *serial_stream = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto table_ids__ = table_ids ? _fbb.CreateVector<uint64_t>(*table_ids) : 0;
  auto source_location__ = source_location ? _fbb.CreateString(source_location) : 0;
  auto serial_stream__ = serial_stream ? _fbb.CreateString(serial_stream) : 0;
  return gaia::catalog::internal::Creategaia_ruleset(
      _fbb,
      name__,
      active_on_startup,
      table_ids__,
      source_location__,
      serial_stream__);
}

flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_relationshipT : public flatbuffers::NativeTable {
  typedef gaia_relationship TableType;
  gaia::direct_access::nullable_string_t name;
  gaia::direct_access::nullable_string_t to_parent_link_name;
  gaia::direct_access::nullable_string_t to_child_link_name;
  uint8_t cardinality;
  bool parent_required;
  bool deprecated;
  uint16_t first_child_offset;
  uint16_t next_child_offset;
  uint16_t parent_offset;
  std::vector<uint16_t> parent_field_positions;
  std::vector<uint16_t> child_field_positions;
  gaia_relationshipT()
      : cardinality(0),
        parent_required(false),
        deprecated(false),
        first_child_offset(0),
        next_child_offset(0),
        parent_offset(0) {
  }
};

struct gaia_relationship FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_relationshipT NativeTableType;
  typedef gaia_relationshipBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TO_PARENT_LINK_NAME = 6,
    VT_TO_CHILD_LINK_NAME = 8,
    VT_CARDINALITY = 10,
    VT_PARENT_REQUIRED = 12,
    VT_DEPRECATED = 14,
    VT_FIRST_CHILD_OFFSET = 16,
    VT_NEXT_CHILD_OFFSET = 18,
    VT_PARENT_OFFSET = 20,
    VT_PARENT_FIELD_POSITIONS = 22,
    VT_CHILD_FIELD_POSITIONS = 24
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *to_parent_link_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TO_PARENT_LINK_NAME);
  }
  const flatbuffers::String *to_child_link_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TO_CHILD_LINK_NAME);
  }
  uint8_t cardinality() const {
    return GetField<uint8_t>(VT_CARDINALITY, 0);
  }
  bool parent_required() const {
    return GetField<uint8_t>(VT_PARENT_REQUIRED, 0) != 0;
  }
  bool deprecated() const {
    return GetField<uint8_t>(VT_DEPRECATED, 0) != 0;
  }
  uint16_t first_child_offset() const {
    return GetField<uint16_t>(VT_FIRST_CHILD_OFFSET, 0);
  }
  uint16_t next_child_offset() const {
    return GetField<uint16_t>(VT_NEXT_CHILD_OFFSET, 0);
  }
  uint16_t parent_offset() const {
    return GetField<uint16_t>(VT_PARENT_OFFSET, 0);
  }
  const flatbuffers::Vector<uint16_t> *parent_field_positions() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_PARENT_FIELD_POSITIONS);
  }
  const flatbuffers::Vector<uint16_t> *child_field_positions() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_CHILD_FIELD_POSITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TO_PARENT_LINK_NAME) &&
           verifier.VerifyString(to_parent_link_name()) &&
           VerifyOffset(verifier, VT_TO_CHILD_LINK_NAME) &&
           verifier.VerifyString(to_child_link_name()) &&
           VerifyField<uint8_t>(verifier, VT_CARDINALITY) &&
           VerifyField<uint8_t>(verifier, VT_PARENT_REQUIRED) &&
           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
           VerifyField<uint16_t>(verifier, VT_FIRST_CHILD_OFFSET) &&
           VerifyField<uint16_t>(verifier, VT_NEXT_CHILD_OFFSET) &&
           VerifyField<uint16_t>(verifier, VT_PARENT_OFFSET) &&
           VerifyOffset(verifier, VT_PARENT_FIELD_POSITIONS) &&
           verifier.VerifyVector(parent_field_positions()) &&
           VerifyOffset(verifier, VT_CHILD_FIELD_POSITIONS) &&
           verifier.VerifyVector(child_field_positions()) &&
           verifier.EndTable();
  }
  gaia_relationshipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_relationshipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_relationship> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_relationshipBuilder {
  typedef gaia_relationship Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_relationship::VT_NAME, name);
  }
  void add_to_parent_link_name(flatbuffers::Offset<flatbuffers::String> to_parent_link_name) {
    fbb_.AddOffset(gaia_relationship::VT_TO_PARENT_LINK_NAME, to_parent_link_name);
  }
  void add_to_child_link_name(flatbuffers::Offset<flatbuffers::String> to_child_link_name) {
    fbb_.AddOffset(gaia_relationship::VT_TO_CHILD_LINK_NAME, to_child_link_name);
  }
  void add_cardinality(uint8_t cardinality) {
    fbb_.AddElement<uint8_t>(gaia_relationship::VT_CARDINALITY, cardinality, 0);
  }
  void add_parent_required(bool parent_required) {
    fbb_.AddElement<uint8_t>(gaia_relationship::VT_PARENT_REQUIRED, static_cast<uint8_t>(parent_required), 0);
  }
  void add_deprecated(bool deprecated) {
    fbb_.AddElement<uint8_t>(gaia_relationship::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0);
  }
  void add_first_child_offset(uint16_t first_child_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_FIRST_CHILD_OFFSET, first_child_offset, 0);
  }
  void add_next_child_offset(uint16_t next_child_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_NEXT_CHILD_OFFSET, next_child_offset, 0);
  }
  void add_parent_offset(uint16_t parent_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_PARENT_OFFSET, parent_offset, 0);
  }
  void add_parent_field_positions(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> parent_field_positions) {
    fbb_.AddOffset(gaia_relationship::VT_PARENT_FIELD_POSITIONS, parent_field_positions);
  }
  void add_child_field_positions(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> child_field_positions) {
    fbb_.AddOffset(gaia_relationship::VT_CHILD_FIELD_POSITIONS, child_field_positions);
  }
  explicit gaia_relationshipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_relationshipBuilder &operator=(const gaia_relationshipBuilder &);
  flatbuffers::Offset<gaia_relationship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_relationship>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_relationship> Creategaia_relationship(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> to_parent_link_name = 0,
    flatbuffers::Offset<flatbuffers::String> to_child_link_name = 0,
    uint8_t cardinality = 0,
    bool parent_required = false,
    bool deprecated = false,
    uint16_t first_child_offset = 0,
    uint16_t next_child_offset = 0,
    uint16_t parent_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> parent_field_positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> child_field_positions = 0) {
  gaia_relationshipBuilder builder_(_fbb);
  builder_.add_child_field_positions(child_field_positions);
  builder_.add_parent_field_positions(parent_field_positions);
  builder_.add_to_child_link_name(to_child_link_name);
  builder_.add_to_parent_link_name(to_parent_link_name);
  builder_.add_name(name);
  builder_.add_parent_offset(parent_offset);
  builder_.add_next_child_offset(next_child_offset);
  builder_.add_first_child_offset(first_child_offset);
  builder_.add_deprecated(deprecated);
  builder_.add_parent_required(parent_required);
  builder_.add_cardinality(cardinality);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_relationship> Creategaia_relationshipDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *to_parent_link_name = nullptr,
    const char *to_child_link_name = nullptr,
    uint8_t cardinality = 0,
    bool parent_required = false,
    bool deprecated = false,
    uint16_t first_child_offset = 0,
    uint16_t next_child_offset = 0,
    uint16_t parent_offset = 0,
    const std::vector<uint16_t> *parent_field_positions = nullptr,
    const std::vector<uint16_t> *child_field_positions = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto to_parent_link_name__ = to_parent_link_name ? _fbb.CreateString(to_parent_link_name) : 0;
  auto to_child_link_name__ = to_child_link_name ? _fbb.CreateString(to_child_link_name) : 0;
  auto parent_field_positions__ = parent_field_positions ? _fbb.CreateVector<uint16_t>(*parent_field_positions) : 0;
  auto child_field_positions__ = child_field_positions ? _fbb.CreateVector<uint16_t>(*child_field_positions) : 0;
  return gaia::catalog::internal::Creategaia_relationship(
      _fbb,
      name__,
      to_parent_link_name__,
      to_child_link_name__,
      cardinality,
      parent_required,
      deprecated,
      first_child_offset,
      next_child_offset,
      parent_offset,
      parent_field_positions__,
      child_field_positions__);
}

flatbuffers::Offset<gaia_relationship> Creategaia_relationship(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_fieldT : public flatbuffers::NativeTable {
  typedef gaia_field TableType;
  gaia::direct_access::nullable_string_t name;
  uint8_t type;
  uint16_t repeated_count;
  uint16_t position;
  bool deprecated;
  bool active;
  bool unique;
  gaia_fieldT()
      : type(0),
        repeated_count(0),
        position(0),
        deprecated(false),
        active(false),
        unique(false) {
  }
};

struct gaia_field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_fieldT NativeTableType;
  typedef gaia_fieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_REPEATED_COUNT = 8,
    VT_POSITION = 10,
    VT_DEPRECATED = 12,
    VT_ACTIVE = 14,
    VT_UNIQUE = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint16_t repeated_count() const {
    return GetField<uint16_t>(VT_REPEATED_COUNT, 0);
  }
  uint16_t position() const {
    return GetField<uint16_t>(VT_POSITION, 0);
  }
  bool deprecated() const {
    return GetField<uint8_t>(VT_DEPRECATED, 0) != 0;
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool unique() const {
    return GetField<uint8_t>(VT_UNIQUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_REPEATED_COUNT) &&
           VerifyField<uint16_t>(verifier, VT_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_UNIQUE) &&
           verifier.EndTable();
  }
  gaia_fieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_fieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_field> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_fieldBuilder {
  typedef gaia_field Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_field::VT_NAME, name);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_TYPE, type, 0);
  }
  void add_repeated_count(uint16_t repeated_count) {
    fbb_.AddElement<uint16_t>(gaia_field::VT_REPEATED_COUNT, repeated_count, 0);
  }
  void add_position(uint16_t position) {
    fbb_.AddElement<uint16_t>(gaia_field::VT_POSITION, position, 0);
  }
  void add_deprecated(bool deprecated) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_unique(bool unique) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_UNIQUE, static_cast<uint8_t>(unique), 0);
  }
  explicit gaia_fieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_fieldBuilder &operator=(const gaia_fieldBuilder &);
  flatbuffers::Offset<gaia_field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_field>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_field> Creategaia_field(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t type = 0,
    uint16_t repeated_count = 0,
    uint16_t position = 0,
    bool deprecated = false,
    bool active = false,
    bool unique = false) {
  gaia_fieldBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_position(position);
  builder_.add_repeated_count(repeated_count);
  builder_.add_unique(unique);
  builder_.add_active(active);
  builder_.add_deprecated(deprecated);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_field> Creategaia_fieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t type = 0,
    uint16_t repeated_count = 0,
    uint16_t position = 0,
    bool deprecated = false,
    bool active = false,
    bool unique = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::internal::Creategaia_field(
      _fbb,
      name__,
      type,
      repeated_count,
      position,
      deprecated,
      active,
      unique);
}

flatbuffers::Offset<gaia_field> Creategaia_field(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_tableT : public flatbuffers::NativeTable {
  typedef gaia_table TableType;
  gaia::direct_access::nullable_string_t name;
  uint32_t type;
  bool is_system;
  std::vector<uint8_t> binary_schema;
  std::vector<uint8_t> serialization_template;
  gaia_tableT()
      : type(0),
        is_system(false) {
  }
};

struct gaia_table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_tableT NativeTableType;
  typedef gaia_tableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_IS_SYSTEM = 8,
    VT_BINARY_SCHEMA = 10,
    VT_SERIALIZATION_TEMPLATE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  bool is_system() const {
    return GetField<uint8_t>(VT_IS_SYSTEM, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *binary_schema() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY_SCHEMA);
  }
  const flatbuffers::Vector<uint8_t> *serialization_template() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALIZATION_TEMPLATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYSTEM) &&
           VerifyOffset(verifier, VT_BINARY_SCHEMA) &&
           verifier.VerifyVector(binary_schema()) &&
           VerifyOffset(verifier, VT_SERIALIZATION_TEMPLATE) &&
           verifier.VerifyVector(serialization_template()) &&
           verifier.EndTable();
  }
  gaia_tableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_tableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_tableBuilder {
  typedef gaia_table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_table::VT_NAME, name);
  }
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(gaia_table::VT_TYPE, type, 0);
  }
  void add_is_system(bool is_system) {
    fbb_.AddElement<uint8_t>(gaia_table::VT_IS_SYSTEM, static_cast<uint8_t>(is_system), 0);
  }
  void add_binary_schema(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary_schema) {
    fbb_.AddOffset(gaia_table::VT_BINARY_SCHEMA, binary_schema);
  }
  void add_serialization_template(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialization_template) {
    fbb_.AddOffset(gaia_table::VT_SERIALIZATION_TEMPLATE, serialization_template);
  }
  explicit gaia_tableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_tableBuilder &operator=(const gaia_tableBuilder &);
  flatbuffers::Offset<gaia_table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_table>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_table> Creategaia_table(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t type = 0,
    bool is_system = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary_schema = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialization_template = 0) {
  gaia_tableBuilder builder_(_fbb);
  builder_.add_serialization_template(serialization_template);
  builder_.add_binary_schema(binary_schema);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_is_system(is_system);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_table> Creategaia_tableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t type = 0,
    bool is_system = false,
    const std::vector<uint8_t> *binary_schema = nullptr,
    const std::vector<uint8_t> *serialization_template = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto binary_schema__ = binary_schema ? _fbb.CreateVector<uint8_t>(*binary_schema) : 0;
  auto serialization_template__ = serialization_template ? _fbb.CreateVector<uint8_t>(*serialization_template) : 0;
  return gaia::catalog::internal::Creategaia_table(
      _fbb,
      name__,
      type,
      is_system,
      binary_schema__,
      serialization_template__);
}

flatbuffers::Offset<gaia_table> Creategaia_table(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_databaseT : public flatbuffers::NativeTable {
  typedef gaia_database TableType;
  gaia::direct_access::nullable_string_t name;
  gaia_databaseT() {
  }
};

struct gaia_database FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_databaseT NativeTableType;
  typedef gaia_databaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  gaia_databaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_databaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_database> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_databaseBuilder {
  typedef gaia_database Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_database::VT_NAME, name);
  }
  explicit gaia_databaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_databaseBuilder &operator=(const gaia_databaseBuilder &);
  flatbuffers::Offset<gaia_database> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_database>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_database> Creategaia_database(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  gaia_databaseBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_database> Creategaia_databaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::internal::Creategaia_database(
      _fbb,
      name__);
}

flatbuffers::Offset<gaia_database> Creategaia_database(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline gaia_indexT *gaia_index::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_indexT> _o = std::unique_ptr<gaia::catalog::internal::gaia_indexT>(new gaia_indexT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_index::UnPackTo(gaia_indexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = unique(); _o->unique = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fields[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<gaia_index> gaia_index::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_index(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_index> Creategaia_index(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_indexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _unique = _o->unique;
  auto _type = _o->type;
  auto _fields = _o->fields.size() ? _fbb.CreateVector(_o->fields) : 0;
  return gaia::catalog::internal::Creategaia_index(
      _fbb,
      _name,
      _unique,
      _type,
      _fields);
}

inline gaia_ruleT *gaia_rule::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_ruleT> _o = std::unique_ptr<gaia::catalog::internal::gaia_ruleT>(new gaia_ruleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_rule::UnPackTo(gaia_ruleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_rule> gaia_rule::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_rule(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_rule> Creategaia_rule(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_ruleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return gaia::catalog::internal::Creategaia_rule(
      _fbb,
      _name);
}

inline gaia_rulesetT *gaia_ruleset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_rulesetT> _o = std::unique_ptr<gaia::catalog::internal::gaia_rulesetT>(new gaia_rulesetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_ruleset::UnPackTo(gaia_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = active_on_startup(); _o->active_on_startup = _e; }
  { auto _e = table_ids(); if (_e) { _o->table_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->table_ids[_i] = _e->Get(_i); } } }
  { auto _e = source_location(); if (_e) _o->source_location = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = serial_stream(); if (_e) _o->serial_stream = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_ruleset> gaia_ruleset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_ruleset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_rulesetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _active_on_startup = _o->active_on_startup;
  auto _table_ids = _o->table_ids.size() ? _fbb.CreateVector(_o->table_ids) : 0;
  auto _source_location = _o->source_location.empty() ? 0 : _fbb.CreateString(_o->source_location);
  auto _serial_stream = _o->serial_stream.empty() ? 0 : _fbb.CreateString(_o->serial_stream);
  return gaia::catalog::internal::Creategaia_ruleset(
      _fbb,
      _name,
      _active_on_startup,
      _table_ids,
      _source_location,
      _serial_stream);
}

inline gaia_relationshipT *gaia_relationship::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_relationshipT> _o = std::unique_ptr<gaia::catalog::internal::gaia_relationshipT>(new gaia_relationshipT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_relationship::UnPackTo(gaia_relationshipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = to_parent_link_name(); if (_e) _o->to_parent_link_name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = to_child_link_name(); if (_e) _o->to_child_link_name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = cardinality(); _o->cardinality = _e; }
  { auto _e = parent_required(); _o->parent_required = _e; }
  { auto _e = deprecated(); _o->deprecated = _e; }
  { auto _e = first_child_offset(); _o->first_child_offset = _e; }
  { auto _e = next_child_offset(); _o->next_child_offset = _e; }
  { auto _e = parent_offset(); _o->parent_offset = _e; }
  { auto _e = parent_field_positions(); if (_e) { _o->parent_field_positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parent_field_positions[_i] = _e->Get(_i); } } }
  { auto _e = child_field_positions(); if (_e) { _o->child_field_positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->child_field_positions[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<gaia_relationship> gaia_relationship::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_relationship(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_relationship> Creategaia_relationship(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_relationshipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _to_parent_link_name = _o->to_parent_link_name.empty() ? 0 : _fbb.CreateString(_o->to_parent_link_name);
  auto _to_child_link_name = _o->to_child_link_name.empty() ? 0 : _fbb.CreateString(_o->to_child_link_name);
  auto _cardinality = _o->cardinality;
  auto _parent_required = _o->parent_required;
  auto _deprecated = _o->deprecated;
  auto _first_child_offset = _o->first_child_offset;
  auto _next_child_offset = _o->next_child_offset;
  auto _parent_offset = _o->parent_offset;
  auto _parent_field_positions = _o->parent_field_positions.size() ? _fbb.CreateVector(_o->parent_field_positions) : 0;
  auto _child_field_positions = _o->child_field_positions.size() ? _fbb.CreateVector(_o->child_field_positions) : 0;
  return gaia::catalog::internal::Creategaia_relationship(
      _fbb,
      _name,
      _to_parent_link_name,
      _to_child_link_name,
      _cardinality,
      _parent_required,
      _deprecated,
      _first_child_offset,
      _next_child_offset,
      _parent_offset,
      _parent_field_positions,
      _child_field_positions);
}

inline gaia_fieldT *gaia_field::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_fieldT> _o = std::unique_ptr<gaia::catalog::internal::gaia_fieldT>(new gaia_fieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_field::UnPackTo(gaia_fieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = repeated_count(); _o->repeated_count = _e; }
  { auto _e = position(); _o->position = _e; }
  { auto _e = deprecated(); _o->deprecated = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = unique(); _o->unique = _e; }
}

inline flatbuffers::Offset<gaia_field> gaia_field::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_field(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_field> Creategaia_field(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_fieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _repeated_count = _o->repeated_count;
  auto _position = _o->position;
  auto _deprecated = _o->deprecated;
  auto _active = _o->active;
  auto _unique = _o->unique;
  return gaia::catalog::internal::Creategaia_field(
      _fbb,
      _name,
      _type,
      _repeated_count,
      _position,
      _deprecated,
      _active,
      _unique);
}

inline gaia_tableT *gaia_table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_tableT> _o = std::unique_ptr<gaia::catalog::internal::gaia_tableT>(new gaia_tableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_table::UnPackTo(gaia_tableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = is_system(); _o->is_system = _e; }
  { auto _e = binary_schema(); if (_e) { _o->binary_schema.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->binary_schema[_i] = _e->Get(_i); } } }
  { auto _e = serialization_template(); if (_e) { _o->serialization_template.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->serialization_template[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<gaia_table> gaia_table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_table> Creategaia_table(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_tableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _is_system = _o->is_system;
  auto _binary_schema = _o->binary_schema.size() ? _fbb.CreateVector(_o->binary_schema) : 0;
  auto _serialization_template = _o->serialization_template.size() ? _fbb.CreateVector(_o->serialization_template) : 0;
  return gaia::catalog::internal::Creategaia_table(
      _fbb,
      _name,
      _type,
      _is_system,
      _binary_schema,
      _serialization_template);
}

inline gaia_databaseT *gaia_database::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::internal::gaia_databaseT> _o = std::unique_ptr<gaia::catalog::internal::gaia_databaseT>(new gaia_databaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_database::UnPackTo(gaia_databaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_database> gaia_database::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_database(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_database> Creategaia_database(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_databaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return gaia::catalog::internal::Creategaia_database(
      _fbb,
      _name);
}

}  // namespace internal
}  // namespace catalog
}  // namespace gaia

#endif  // FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_INTERNAL_H_
