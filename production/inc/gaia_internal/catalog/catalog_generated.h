// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_INTERNAL_H_
#define FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_INTERNAL_H_

#include "flatbuffers/flatbuffers.h"

#include "gaia/direct_access/nullable_string.hpp"

namespace gaia {
namespace catalog {
namespace internal {

struct rule_relationship;
struct rule_relationshipBuilder;
struct rule_relationshipT;

struct rule_field;
struct rule_fieldBuilder;
struct rule_fieldT;

struct rule_table;
struct rule_tableBuilder;
struct rule_tableT;

struct ruleset_database;
struct ruleset_databaseBuilder;
struct ruleset_databaseT;

struct app_ruleset;
struct app_rulesetBuilder;
struct app_rulesetT;

struct app_database;
struct app_databaseBuilder;
struct app_databaseT;

struct gaia_application;
struct gaia_applicationBuilder;
struct gaia_applicationT;

struct gaia_index;
struct gaia_indexBuilder;
struct gaia_indexT;

struct gaia_rule;
struct gaia_ruleBuilder;
struct gaia_ruleT;

struct gaia_ruleset;
struct gaia_rulesetBuilder;
struct gaia_rulesetT;

struct gaia_relationship;
struct gaia_relationshipBuilder;
struct gaia_relationshipT;

struct gaia_field;
struct gaia_fieldBuilder;
struct gaia_fieldT;

struct gaia_table;
struct gaia_tableBuilder;
struct gaia_tableT;

struct gaia_database;
struct gaia_databaseBuilder;
struct gaia_databaseT;

struct rule_relationshipT : public flatbuffers::NativeTable {
  typedef rule_relationship TableType;
  uint8_t type = 0;
};

struct rule_relationship FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef rule_relationshipT NativeTableType;
  typedef rule_relationshipBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  rule_relationshipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(rule_relationshipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<rule_relationship> Pack(flatbuffers::FlatBufferBuilder &_fbb, const rule_relationshipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct rule_relationshipBuilder {
  typedef rule_relationship Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(rule_relationship::VT_TYPE, type, 0);
  }
  explicit rule_relationshipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<rule_relationship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<rule_relationship>(end);
    return o;
  }
};

inline flatbuffers::Offset<rule_relationship> Createrule_relationship(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0) {
  rule_relationshipBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<rule_relationship> Createrule_relationship(flatbuffers::FlatBufferBuilder &_fbb, const rule_relationshipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct rule_fieldT : public flatbuffers::NativeTable {
  typedef rule_field TableType;
  uint8_t type = 0;
  bool active = false;
};

struct rule_field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef rule_fieldT NativeTableType;
  typedef rule_fieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ACTIVE = 6
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           verifier.EndTable();
  }
  rule_fieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(rule_fieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<rule_field> Pack(flatbuffers::FlatBufferBuilder &_fbb, const rule_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct rule_fieldBuilder {
  typedef rule_field Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(rule_field::VT_TYPE, type, 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(rule_field::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  explicit rule_fieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<rule_field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<rule_field>(end);
    return o;
  }
};

inline flatbuffers::Offset<rule_field> Createrule_field(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    bool active = false) {
  rule_fieldBuilder builder_(_fbb);
  builder_.add_active(active);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<rule_field> Createrule_field(flatbuffers::FlatBufferBuilder &_fbb, const rule_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct rule_tableT : public flatbuffers::NativeTable {
  typedef rule_table TableType;
  uint8_t type = 0;
  bool anchor = false;
};

struct rule_table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef rule_tableT NativeTableType;
  typedef rule_tableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ANCHOR = 6
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool anchor() const {
    return GetField<uint8_t>(VT_ANCHOR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ANCHOR) &&
           verifier.EndTable();
  }
  rule_tableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(rule_tableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<rule_table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const rule_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct rule_tableBuilder {
  typedef rule_table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(rule_table::VT_TYPE, type, 0);
  }
  void add_anchor(bool anchor) {
    fbb_.AddElement<uint8_t>(rule_table::VT_ANCHOR, static_cast<uint8_t>(anchor), 0);
  }
  explicit rule_tableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<rule_table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<rule_table>(end);
    return o;
  }
};

inline flatbuffers::Offset<rule_table> Createrule_table(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    bool anchor = false) {
  rule_tableBuilder builder_(_fbb);
  builder_.add_anchor(anchor);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<rule_table> Createrule_table(flatbuffers::FlatBufferBuilder &_fbb, const rule_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ruleset_databaseT : public flatbuffers::NativeTable {
  typedef ruleset_database TableType;
};

struct ruleset_database FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ruleset_databaseT NativeTableType;
  typedef ruleset_databaseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ruleset_databaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ruleset_databaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ruleset_database> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ruleset_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ruleset_databaseBuilder {
  typedef ruleset_database Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ruleset_databaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ruleset_database> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ruleset_database>(end);
    return o;
  }
};

inline flatbuffers::Offset<ruleset_database> Createruleset_database(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ruleset_databaseBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ruleset_database> Createruleset_database(flatbuffers::FlatBufferBuilder &_fbb, const ruleset_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct app_rulesetT : public flatbuffers::NativeTable {
  typedef app_ruleset TableType;
  bool active_on_startup = false;
};

struct app_ruleset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef app_rulesetT NativeTableType;
  typedef app_rulesetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE_ON_STARTUP = 4
  };
  bool active_on_startup() const {
    return GetField<uint8_t>(VT_ACTIVE_ON_STARTUP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE_ON_STARTUP) &&
           verifier.EndTable();
  }
  app_rulesetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(app_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<app_ruleset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const app_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct app_rulesetBuilder {
  typedef app_ruleset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_active_on_startup(bool active_on_startup) {
    fbb_.AddElement<uint8_t>(app_ruleset::VT_ACTIVE_ON_STARTUP, static_cast<uint8_t>(active_on_startup), 0);
  }
  explicit app_rulesetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<app_ruleset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<app_ruleset>(end);
    return o;
  }
};

inline flatbuffers::Offset<app_ruleset> Createapp_ruleset(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool active_on_startup = false) {
  app_rulesetBuilder builder_(_fbb);
  builder_.add_active_on_startup(active_on_startup);
  return builder_.Finish();
}

flatbuffers::Offset<app_ruleset> Createapp_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const app_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct app_databaseT : public flatbuffers::NativeTable {
  typedef app_database TableType;
};

struct app_database FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef app_databaseT NativeTableType;
  typedef app_databaseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  app_databaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(app_databaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<app_database> Pack(flatbuffers::FlatBufferBuilder &_fbb, const app_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct app_databaseBuilder {
  typedef app_database Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit app_databaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<app_database> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<app_database>(end);
    return o;
  }
};

inline flatbuffers::Offset<app_database> Createapp_database(
    flatbuffers::FlatBufferBuilder &_fbb) {
  app_databaseBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<app_database> Createapp_database(flatbuffers::FlatBufferBuilder &_fbb, const app_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_applicationT : public flatbuffers::NativeTable {
  typedef gaia_application TableType;
  gaia::direct_access::nullable_string_t name{};
};

struct gaia_application FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_applicationT NativeTableType;
  typedef gaia_applicationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  gaia_applicationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_applicationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_application> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_applicationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_applicationBuilder {
  typedef gaia_application Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_application::VT_NAME, name);
  }
  explicit gaia_applicationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_application> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_application>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_application> Creategaia_application(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  gaia_applicationBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_application> Creategaia_applicationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::internal::Creategaia_application(
      _fbb,
      name__);
}

flatbuffers::Offset<gaia_application> Creategaia_application(flatbuffers::FlatBufferBuilder &_fbb, const gaia_applicationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_indexT : public flatbuffers::NativeTable {
  typedef gaia_index TableType;
  gaia::direct_access::nullable_string_t name{};
  bool unique = false;
  uint8_t type = 0;
  std::vector<uint64_t> fields{};
};

struct gaia_index FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_indexT NativeTableType;
  typedef gaia_indexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_UNIQUE = 6,
    VT_TYPE = 8,
    VT_FIELDS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool unique() const {
    return GetField<uint8_t>(VT_UNIQUE, 0) != 0;
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<uint64_t> *fields() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_FIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_UNIQUE) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.EndTable();
  }
  gaia_indexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_indexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_index> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_indexBuilder {
  typedef gaia_index Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_index::VT_NAME, name);
  }
  void add_unique(bool unique) {
    fbb_.AddElement<uint8_t>(gaia_index::VT_UNIQUE, static_cast<uint8_t>(unique), 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(gaia_index::VT_TYPE, type, 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> fields) {
    fbb_.AddOffset(gaia_index::VT_FIELDS, fields);
  }
  explicit gaia_indexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_index> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_index>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_index> Creategaia_index(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool unique = false,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> fields = 0) {
  gaia_indexBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_name(name);
  builder_.add_type(type);
  builder_.add_unique(unique);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_index> Creategaia_indexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool unique = false,
    uint8_t type = 0,
    const std::vector<uint64_t> *fields = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fields__ = fields ? _fbb.CreateVector<uint64_t>(*fields) : 0;
  return gaia::catalog::internal::Creategaia_index(
      _fbb,
      name__,
      unique,
      type,
      fields__);
}

flatbuffers::Offset<gaia_index> Creategaia_index(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_ruleT : public flatbuffers::NativeTable {
  typedef gaia_rule TableType;
  gaia::direct_access::nullable_string_t name{};
};

struct gaia_rule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_ruleT NativeTableType;
  typedef gaia_ruleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  gaia_ruleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_ruleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_rule> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_ruleBuilder {
  typedef gaia_rule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_rule::VT_NAME, name);
  }
  explicit gaia_ruleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_rule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_rule>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_rule> Creategaia_rule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  gaia_ruleBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_rule> Creategaia_ruleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::internal::Creategaia_rule(
      _fbb,
      name__);
}

flatbuffers::Offset<gaia_rule> Creategaia_rule(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_rulesetT : public flatbuffers::NativeTable {
  typedef gaia_ruleset TableType;
  gaia::direct_access::nullable_string_t name{};
  gaia::direct_access::nullable_string_t serial_stream{};
};

struct gaia_ruleset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_rulesetT NativeTableType;
  typedef gaia_rulesetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SERIAL_STREAM = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *serial_stream() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIAL_STREAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SERIAL_STREAM) &&
           verifier.VerifyString(serial_stream()) &&
           verifier.EndTable();
  }
  gaia_rulesetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_ruleset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_rulesetBuilder {
  typedef gaia_ruleset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_ruleset::VT_NAME, name);
  }
  void add_serial_stream(flatbuffers::Offset<flatbuffers::String> serial_stream) {
    fbb_.AddOffset(gaia_ruleset::VT_SERIAL_STREAM, serial_stream);
  }
  explicit gaia_rulesetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_ruleset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_ruleset>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> serial_stream = 0) {
  gaia_rulesetBuilder builder_(_fbb);
  builder_.add_serial_stream(serial_stream);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_ruleset> Creategaia_rulesetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *serial_stream = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto serial_stream__ = serial_stream ? _fbb.CreateString(serial_stream) : 0;
  return gaia::catalog::internal::Creategaia_ruleset(
      _fbb,
      name__,
      serial_stream__);
}

flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_relationshipT : public flatbuffers::NativeTable {
  typedef gaia_relationship TableType;
  gaia::direct_access::nullable_string_t name{};
  gaia::direct_access::nullable_string_t to_parent_link_name{};
  gaia::direct_access::nullable_string_t to_child_link_name{};
  uint8_t cardinality = 0;
  bool parent_required = false;
  bool deprecated = false;
  uint16_t first_child_offset = 0;
  uint16_t next_child_offset = 0;
  uint16_t prev_child_offset = 0;
  uint16_t parent_offset = 0;
  std::vector<uint16_t> parent_field_positions{};
  std::vector<uint16_t> child_field_positions{};
  gaia::direct_access::nullable_string_t hash{};
};

struct gaia_relationship FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_relationshipT NativeTableType;
  typedef gaia_relationshipBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TO_PARENT_LINK_NAME = 6,
    VT_TO_CHILD_LINK_NAME = 8,
    VT_CARDINALITY = 10,
    VT_PARENT_REQUIRED = 12,
    VT_DEPRECATED = 14,
    VT_FIRST_CHILD_OFFSET = 16,
    VT_NEXT_CHILD_OFFSET = 18,
    VT_PREV_CHILD_OFFSET = 20,
    VT_PARENT_OFFSET = 22,
    VT_PARENT_FIELD_POSITIONS = 24,
    VT_CHILD_FIELD_POSITIONS = 26,
    VT_HASH = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *to_parent_link_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TO_PARENT_LINK_NAME);
  }
  const flatbuffers::String *to_child_link_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TO_CHILD_LINK_NAME);
  }
  uint8_t cardinality() const {
    return GetField<uint8_t>(VT_CARDINALITY, 0);
  }
  bool parent_required() const {
    return GetField<uint8_t>(VT_PARENT_REQUIRED, 0) != 0;
  }
  bool deprecated() const {
    return GetField<uint8_t>(VT_DEPRECATED, 0) != 0;
  }
  uint16_t first_child_offset() const {
    return GetField<uint16_t>(VT_FIRST_CHILD_OFFSET, 0);
  }
  uint16_t next_child_offset() const {
    return GetField<uint16_t>(VT_NEXT_CHILD_OFFSET, 0);
  }
  uint16_t prev_child_offset() const {
    return GetField<uint16_t>(VT_PREV_CHILD_OFFSET, 0);
  }
  uint16_t parent_offset() const {
    return GetField<uint16_t>(VT_PARENT_OFFSET, 0);
  }
  const flatbuffers::Vector<uint16_t> *parent_field_positions() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_PARENT_FIELD_POSITIONS);
  }
  const flatbuffers::Vector<uint16_t> *child_field_positions() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_CHILD_FIELD_POSITIONS);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TO_PARENT_LINK_NAME) &&
           verifier.VerifyString(to_parent_link_name()) &&
           VerifyOffset(verifier, VT_TO_CHILD_LINK_NAME) &&
           verifier.VerifyString(to_child_link_name()) &&
           VerifyField<uint8_t>(verifier, VT_CARDINALITY) &&
           VerifyField<uint8_t>(verifier, VT_PARENT_REQUIRED) &&
           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
           VerifyField<uint16_t>(verifier, VT_FIRST_CHILD_OFFSET) &&
           VerifyField<uint16_t>(verifier, VT_NEXT_CHILD_OFFSET) &&
           VerifyField<uint16_t>(verifier, VT_PREV_CHILD_OFFSET) &&
           VerifyField<uint16_t>(verifier, VT_PARENT_OFFSET) &&
           VerifyOffset(verifier, VT_PARENT_FIELD_POSITIONS) &&
           verifier.VerifyVector(parent_field_positions()) &&
           VerifyOffset(verifier, VT_CHILD_FIELD_POSITIONS) &&
           verifier.VerifyVector(child_field_positions()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           verifier.EndTable();
  }
  gaia_relationshipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_relationshipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_relationship> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_relationshipBuilder {
  typedef gaia_relationship Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_relationship::VT_NAME, name);
  }
  void add_to_parent_link_name(flatbuffers::Offset<flatbuffers::String> to_parent_link_name) {
    fbb_.AddOffset(gaia_relationship::VT_TO_PARENT_LINK_NAME, to_parent_link_name);
  }
  void add_to_child_link_name(flatbuffers::Offset<flatbuffers::String> to_child_link_name) {
    fbb_.AddOffset(gaia_relationship::VT_TO_CHILD_LINK_NAME, to_child_link_name);
  }
  void add_cardinality(uint8_t cardinality) {
    fbb_.AddElement<uint8_t>(gaia_relationship::VT_CARDINALITY, cardinality, 0);
  }
  void add_parent_required(bool parent_required) {
    fbb_.AddElement<uint8_t>(gaia_relationship::VT_PARENT_REQUIRED, static_cast<uint8_t>(parent_required), 0);
  }
  void add_deprecated(bool deprecated) {
    fbb_.AddElement<uint8_t>(gaia_relationship::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0);
  }
  void add_first_child_offset(uint16_t first_child_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_FIRST_CHILD_OFFSET, first_child_offset, 0);
  }
  void add_next_child_offset(uint16_t next_child_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_NEXT_CHILD_OFFSET, next_child_offset, 0);
  }
  void add_prev_child_offset(uint16_t prev_child_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_PREV_CHILD_OFFSET, prev_child_offset, 0);
  }
  void add_parent_offset(uint16_t parent_offset) {
    fbb_.AddElement<uint16_t>(gaia_relationship::VT_PARENT_OFFSET, parent_offset, 0);
  }
  void add_parent_field_positions(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> parent_field_positions) {
    fbb_.AddOffset(gaia_relationship::VT_PARENT_FIELD_POSITIONS, parent_field_positions);
  }
  void add_child_field_positions(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> child_field_positions) {
    fbb_.AddOffset(gaia_relationship::VT_CHILD_FIELD_POSITIONS, child_field_positions);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(gaia_relationship::VT_HASH, hash);
  }
  explicit gaia_relationshipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_relationship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_relationship>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_relationship> Creategaia_relationship(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> to_parent_link_name = 0,
    flatbuffers::Offset<flatbuffers::String> to_child_link_name = 0,
    uint8_t cardinality = 0,
    bool parent_required = false,
    bool deprecated = false,
    uint16_t first_child_offset = 0,
    uint16_t next_child_offset = 0,
    uint16_t prev_child_offset = 0,
    uint16_t parent_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> parent_field_positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> child_field_positions = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  gaia_relationshipBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_child_field_positions(child_field_positions);
  builder_.add_parent_field_positions(parent_field_positions);
  builder_.add_to_child_link_name(to_child_link_name);
  builder_.add_to_parent_link_name(to_parent_link_name);
  builder_.add_name(name);
  builder_.add_parent_offset(parent_offset);
  builder_.add_prev_child_offset(prev_child_offset);
  builder_.add_next_child_offset(next_child_offset);
  builder_.add_first_child_offset(first_child_offset);
  builder_.add_deprecated(deprecated);
  builder_.add_parent_required(parent_required);
  builder_.add_cardinality(cardinality);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_relationship> Creategaia_relationshipDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *to_parent_link_name = nullptr,
    const char *to_child_link_name = nullptr,
    uint8_t cardinality = 0,
    bool parent_required = false,
    bool deprecated = false,
    uint16_t first_child_offset = 0,
    uint16_t next_child_offset = 0,
    uint16_t prev_child_offset = 0,
    uint16_t parent_offset = 0,
    const std::vector<uint16_t> *parent_field_positions = nullptr,
    const std::vector<uint16_t> *child_field_positions = nullptr,
    const char *hash = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto to_parent_link_name__ = to_parent_link_name ? _fbb.CreateString(to_parent_link_name) : 0;
  auto to_child_link_name__ = to_child_link_name ? _fbb.CreateString(to_child_link_name) : 0;
  auto parent_field_positions__ = parent_field_positions ? _fbb.CreateVector<uint16_t>(*parent_field_positions) : 0;
  auto child_field_positions__ = child_field_positions ? _fbb.CreateVector<uint16_t>(*child_field_positions) : 0;
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  return gaia::catalog::internal::Creategaia_relationship(
      _fbb,
      name__,
      to_parent_link_name__,
      to_child_link_name__,
      cardinality,
      parent_required,
      deprecated,
      first_child_offset,
      next_child_offset,
      prev_child_offset,
      parent_offset,
      parent_field_positions__,
      child_field_positions__,
      hash__);
}

flatbuffers::Offset<gaia_relationship> Creategaia_relationship(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_fieldT : public flatbuffers::NativeTable {
  typedef gaia_field TableType;
  gaia::direct_access::nullable_string_t name{};
  uint8_t type = 0;
  uint16_t repeated_count = 0;
  uint16_t position = 0;
  bool deprecated = false;
  bool active = false;
  bool unique = false;
  gaia::direct_access::nullable_string_t hash{};
};

struct gaia_field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_fieldT NativeTableType;
  typedef gaia_fieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_REPEATED_COUNT = 8,
    VT_POSITION = 10,
    VT_DEPRECATED = 12,
    VT_ACTIVE = 14,
    VT_UNIQUE = 16,
    VT_HASH = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint16_t repeated_count() const {
    return GetField<uint16_t>(VT_REPEATED_COUNT, 0);
  }
  uint16_t position() const {
    return GetField<uint16_t>(VT_POSITION, 0);
  }
  bool deprecated() const {
    return GetField<uint8_t>(VT_DEPRECATED, 0) != 0;
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool unique() const {
    return GetField<uint8_t>(VT_UNIQUE, 0) != 0;
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_REPEATED_COUNT) &&
           VerifyField<uint16_t>(verifier, VT_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_UNIQUE) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           verifier.EndTable();
  }
  gaia_fieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_fieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_field> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_fieldBuilder {
  typedef gaia_field Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_field::VT_NAME, name);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_TYPE, type, 0);
  }
  void add_repeated_count(uint16_t repeated_count) {
    fbb_.AddElement<uint16_t>(gaia_field::VT_REPEATED_COUNT, repeated_count, 0);
  }
  void add_position(uint16_t position) {
    fbb_.AddElement<uint16_t>(gaia_field::VT_POSITION, position, 0);
  }
  void add_deprecated(bool deprecated) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_unique(bool unique) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_UNIQUE, static_cast<uint8_t>(unique), 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(gaia_field::VT_HASH, hash);
  }
  explicit gaia_fieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_field>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_field> Creategaia_field(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t type = 0,
    uint16_t repeated_count = 0,
    uint16_t position = 0,
    bool deprecated = false,
    bool active = false,
    bool unique = false,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  gaia_fieldBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_name(name);
  builder_.add_position(position);
  builder_.add_repeated_count(repeated_count);
  builder_.add_unique(unique);
  builder_.add_active(active);
  builder_.add_deprecated(deprecated);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_field> Creategaia_fieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t type = 0,
    uint16_t repeated_count = 0,
    uint16_t position = 0,
    bool deprecated = false,
    bool active = false,
    bool unique = false,
    const char *hash = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  return gaia::catalog::internal::Creategaia_field(
      _fbb,
      name__,
      type,
      repeated_count,
      position,
      deprecated,
      active,
      unique,
      hash__);
}

flatbuffers::Offset<gaia_field> Creategaia_field(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_tableT : public flatbuffers::NativeTable {
  typedef gaia_table TableType;
  gaia::direct_access::nullable_string_t name{};
  uint32_t type = 0;
  bool is_system = false;
  std::vector<uint8_t> binary_schema{};
  std::vector<uint8_t> serialization_template{};
  gaia::direct_access::nullable_string_t hash{};
  gaia::direct_access::nullable_string_t type_name{};
};

struct gaia_table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_tableT NativeTableType;
  typedef gaia_tableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_IS_SYSTEM = 8,
    VT_BINARY_SCHEMA = 10,
    VT_SERIALIZATION_TEMPLATE = 12,
    VT_HASH = 14,
    VT_TYPE_NAME = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  bool is_system() const {
    return GetField<uint8_t>(VT_IS_SYSTEM, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *binary_schema() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY_SCHEMA);
  }
  const flatbuffers::Vector<uint8_t> *serialization_template() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALIZATION_TEMPLATE);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  const flatbuffers::String *type_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYSTEM) &&
           VerifyOffset(verifier, VT_BINARY_SCHEMA) &&
           verifier.VerifyVector(binary_schema()) &&
           VerifyOffset(verifier, VT_SERIALIZATION_TEMPLATE) &&
           verifier.VerifyVector(serialization_template()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyString(type_name()) &&
           verifier.EndTable();
  }
  gaia_tableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_tableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_tableBuilder {
  typedef gaia_table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_table::VT_NAME, name);
  }
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(gaia_table::VT_TYPE, type, 0);
  }
  void add_is_system(bool is_system) {
    fbb_.AddElement<uint8_t>(gaia_table::VT_IS_SYSTEM, static_cast<uint8_t>(is_system), 0);
  }
  void add_binary_schema(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary_schema) {
    fbb_.AddOffset(gaia_table::VT_BINARY_SCHEMA, binary_schema);
  }
  void add_serialization_template(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialization_template) {
    fbb_.AddOffset(gaia_table::VT_SERIALIZATION_TEMPLATE, serialization_template);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(gaia_table::VT_HASH, hash);
  }
  void add_type_name(flatbuffers::Offset<flatbuffers::String> type_name) {
    fbb_.AddOffset(gaia_table::VT_TYPE_NAME, type_name);
  }
  explicit gaia_tableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_table>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_table> Creategaia_table(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t type = 0,
    bool is_system = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary_schema = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialization_template = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> type_name = 0) {
  gaia_tableBuilder builder_(_fbb);
  builder_.add_type_name(type_name);
  builder_.add_hash(hash);
  builder_.add_serialization_template(serialization_template);
  builder_.add_binary_schema(binary_schema);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_is_system(is_system);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_table> Creategaia_tableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t type = 0,
    bool is_system = false,
    const std::vector<uint8_t> *binary_schema = nullptr,
    const std::vector<uint8_t> *serialization_template = nullptr,
    const char *hash = nullptr,
    const char *type_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto binary_schema__ = binary_schema ? _fbb.CreateVector<uint8_t>(*binary_schema) : 0;
  auto serialization_template__ = serialization_template ? _fbb.CreateVector<uint8_t>(*serialization_template) : 0;
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto type_name__ = type_name ? _fbb.CreateString(type_name) : 0;
  return gaia::catalog::internal::Creategaia_table(
      _fbb,
      name__,
      type,
      is_system,
      binary_schema__,
      serialization_template__,
      hash__,
      type_name__);
}

flatbuffers::Offset<gaia_table> Creategaia_table(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_databaseT : public flatbuffers::NativeTable {
  typedef gaia_database TableType;
  gaia::direct_access::nullable_string_t name{};
  gaia::direct_access::nullable_string_t hash{};
};

struct gaia_database FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_databaseT NativeTableType;
  typedef gaia_databaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_HASH = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           verifier.EndTable();
  }
  gaia_databaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_databaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_database> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_databaseBuilder {
  typedef gaia_database Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_database::VT_NAME, name);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(gaia_database::VT_HASH, hash);
  }
  explicit gaia_databaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<gaia_database> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_database>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_database> Creategaia_database(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  gaia_databaseBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_database> Creategaia_databaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *hash = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  return gaia::catalog::internal::Creategaia_database(
      _fbb,
      name__,
      hash__);
}

flatbuffers::Offset<gaia_database> Creategaia_database(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline rule_relationshipT *rule_relationship::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<rule_relationshipT>(new rule_relationshipT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void rule_relationship::UnPackTo(rule_relationshipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<rule_relationship> rule_relationship::Pack(flatbuffers::FlatBufferBuilder &_fbb, const rule_relationshipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createrule_relationship(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<rule_relationship> Createrule_relationship(flatbuffers::FlatBufferBuilder &_fbb, const rule_relationshipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const rule_relationshipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return gaia::catalog::internal::Createrule_relationship(
      _fbb,
      _type);
}

inline rule_fieldT *rule_field::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<rule_fieldT>(new rule_fieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void rule_field::UnPackTo(rule_fieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = active(); _o->active = _e; }
}

inline flatbuffers::Offset<rule_field> rule_field::Pack(flatbuffers::FlatBufferBuilder &_fbb, const rule_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createrule_field(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<rule_field> Createrule_field(flatbuffers::FlatBufferBuilder &_fbb, const rule_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const rule_fieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _active = _o->active;
  return gaia::catalog::internal::Createrule_field(
      _fbb,
      _type,
      _active);
}

inline rule_tableT *rule_table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<rule_tableT>(new rule_tableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void rule_table::UnPackTo(rule_tableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = anchor(); _o->anchor = _e; }
}

inline flatbuffers::Offset<rule_table> rule_table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const rule_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createrule_table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<rule_table> Createrule_table(flatbuffers::FlatBufferBuilder &_fbb, const rule_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const rule_tableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _anchor = _o->anchor;
  return gaia::catalog::internal::Createrule_table(
      _fbb,
      _type,
      _anchor);
}

inline ruleset_databaseT *ruleset_database::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ruleset_databaseT>(new ruleset_databaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ruleset_database::UnPackTo(ruleset_databaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ruleset_database> ruleset_database::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ruleset_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createruleset_database(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ruleset_database> Createruleset_database(flatbuffers::FlatBufferBuilder &_fbb, const ruleset_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ruleset_databaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return gaia::catalog::internal::Createruleset_database(
      _fbb);
}

inline app_rulesetT *app_ruleset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<app_rulesetT>(new app_rulesetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void app_ruleset::UnPackTo(app_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = active_on_startup(); _o->active_on_startup = _e; }
}

inline flatbuffers::Offset<app_ruleset> app_ruleset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const app_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createapp_ruleset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<app_ruleset> Createapp_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const app_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const app_rulesetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _active_on_startup = _o->active_on_startup;
  return gaia::catalog::internal::Createapp_ruleset(
      _fbb,
      _active_on_startup);
}

inline app_databaseT *app_database::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<app_databaseT>(new app_databaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void app_database::UnPackTo(app_databaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<app_database> app_database::Pack(flatbuffers::FlatBufferBuilder &_fbb, const app_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createapp_database(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<app_database> Createapp_database(flatbuffers::FlatBufferBuilder &_fbb, const app_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const app_databaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return gaia::catalog::internal::Createapp_database(
      _fbb);
}

inline gaia_applicationT *gaia_application::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_applicationT>(new gaia_applicationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_application::UnPackTo(gaia_applicationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_application> gaia_application::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_applicationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_application(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_application> Creategaia_application(flatbuffers::FlatBufferBuilder &_fbb, const gaia_applicationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_applicationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return gaia::catalog::internal::Creategaia_application(
      _fbb,
      _name);
}

inline gaia_indexT *gaia_index::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_indexT>(new gaia_indexT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_index::UnPackTo(gaia_indexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = unique(); _o->unique = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fields[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<gaia_index> gaia_index::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_index(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_index> Creategaia_index(flatbuffers::FlatBufferBuilder &_fbb, const gaia_indexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_indexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _unique = _o->unique;
  auto _type = _o->type;
  auto _fields = _o->fields.size() ? _fbb.CreateVector(_o->fields) : 0;
  return gaia::catalog::internal::Creategaia_index(
      _fbb,
      _name,
      _unique,
      _type,
      _fields);
}

inline gaia_ruleT *gaia_rule::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_ruleT>(new gaia_ruleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_rule::UnPackTo(gaia_ruleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_rule> gaia_rule::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_rule(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_rule> Creategaia_rule(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_ruleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return gaia::catalog::internal::Creategaia_rule(
      _fbb,
      _name);
}

inline gaia_rulesetT *gaia_ruleset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_rulesetT>(new gaia_rulesetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_ruleset::UnPackTo(gaia_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = serial_stream(); if (_e) _o->serial_stream = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_ruleset> gaia_ruleset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_ruleset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_rulesetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _serial_stream = _o->serial_stream.empty() ? 0 : _fbb.CreateString(_o->serial_stream);
  return gaia::catalog::internal::Creategaia_ruleset(
      _fbb,
      _name,
      _serial_stream);
}

inline gaia_relationshipT *gaia_relationship::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_relationshipT>(new gaia_relationshipT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_relationship::UnPackTo(gaia_relationshipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = to_parent_link_name(); if (_e) _o->to_parent_link_name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = to_child_link_name(); if (_e) _o->to_child_link_name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = cardinality(); _o->cardinality = _e; }
  { auto _e = parent_required(); _o->parent_required = _e; }
  { auto _e = deprecated(); _o->deprecated = _e; }
  { auto _e = first_child_offset(); _o->first_child_offset = _e; }
  { auto _e = next_child_offset(); _o->next_child_offset = _e; }
  { auto _e = prev_child_offset(); _o->prev_child_offset = _e; }
  { auto _e = parent_offset(); _o->parent_offset = _e; }
  { auto _e = parent_field_positions(); if (_e) { _o->parent_field_positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parent_field_positions[_i] = _e->Get(_i); } } }
  { auto _e = child_field_positions(); if (_e) { _o->child_field_positions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->child_field_positions[_i] = _e->Get(_i); } } }
  { auto _e = hash(); if (_e) _o->hash = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_relationship> gaia_relationship::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_relationship(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_relationship> Creategaia_relationship(flatbuffers::FlatBufferBuilder &_fbb, const gaia_relationshipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_relationshipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _to_parent_link_name = _o->to_parent_link_name.empty() ? 0 : _fbb.CreateString(_o->to_parent_link_name);
  auto _to_child_link_name = _o->to_child_link_name.empty() ? 0 : _fbb.CreateString(_o->to_child_link_name);
  auto _cardinality = _o->cardinality;
  auto _parent_required = _o->parent_required;
  auto _deprecated = _o->deprecated;
  auto _first_child_offset = _o->first_child_offset;
  auto _next_child_offset = _o->next_child_offset;
  auto _prev_child_offset = _o->prev_child_offset;
  auto _parent_offset = _o->parent_offset;
  auto _parent_field_positions = _o->parent_field_positions.size() ? _fbb.CreateVector(_o->parent_field_positions) : 0;
  auto _child_field_positions = _o->child_field_positions.size() ? _fbb.CreateVector(_o->child_field_positions) : 0;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  return gaia::catalog::internal::Creategaia_relationship(
      _fbb,
      _name,
      _to_parent_link_name,
      _to_child_link_name,
      _cardinality,
      _parent_required,
      _deprecated,
      _first_child_offset,
      _next_child_offset,
      _prev_child_offset,
      _parent_offset,
      _parent_field_positions,
      _child_field_positions,
      _hash);
}

inline gaia_fieldT *gaia_field::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_fieldT>(new gaia_fieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_field::UnPackTo(gaia_fieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = repeated_count(); _o->repeated_count = _e; }
  { auto _e = position(); _o->position = _e; }
  { auto _e = deprecated(); _o->deprecated = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = unique(); _o->unique = _e; }
  { auto _e = hash(); if (_e) _o->hash = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_field> gaia_field::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_field(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_field> Creategaia_field(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_fieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _repeated_count = _o->repeated_count;
  auto _position = _o->position;
  auto _deprecated = _o->deprecated;
  auto _active = _o->active;
  auto _unique = _o->unique;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  return gaia::catalog::internal::Creategaia_field(
      _fbb,
      _name,
      _type,
      _repeated_count,
      _position,
      _deprecated,
      _active,
      _unique,
      _hash);
}

inline gaia_tableT *gaia_table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_tableT>(new gaia_tableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_table::UnPackTo(gaia_tableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = is_system(); _o->is_system = _e; }
  { auto _e = binary_schema(); if (_e) { _o->binary_schema.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->binary_schema.begin()); } }
  { auto _e = serialization_template(); if (_e) { _o->serialization_template.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->serialization_template.begin()); } }
  { auto _e = hash(); if (_e) _o->hash = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = type_name(); if (_e) _o->type_name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_table> gaia_table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_table> Creategaia_table(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_tableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _is_system = _o->is_system;
  auto _binary_schema = _o->binary_schema.size() ? _fbb.CreateVector(_o->binary_schema) : 0;
  auto _serialization_template = _o->serialization_template.size() ? _fbb.CreateVector(_o->serialization_template) : 0;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _type_name = _o->type_name.empty() ? 0 : _fbb.CreateString(_o->type_name);
  return gaia::catalog::internal::Creategaia_table(
      _fbb,
      _name,
      _type,
      _is_system,
      _binary_schema,
      _serialization_template,
      _hash,
      _type_name);
}

inline gaia_databaseT *gaia_database::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<gaia_databaseT>(new gaia_databaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_database::UnPackTo(gaia_databaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = hash(); if (_e) _o->hash = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_database> gaia_database::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_database(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_database> Creategaia_database(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_databaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  return gaia::catalog::internal::Creategaia_database(
      _fbb,
      _name,
      _hash);
}

}  // namespace internal
}  // namespace catalog
}  // namespace gaia

#endif  // FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_INTERNAL_H_
