// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_H_
#define FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_H_

#include "flatbuffers/flatbuffers.h"

namespace gaia {
namespace catalog {

struct event_log;
struct event_logBuilder;
struct event_logT;

struct gaia_database;
struct gaia_databaseBuilder;
struct gaia_databaseT;

struct gaia_ruleset;
struct gaia_rulesetBuilder;
struct gaia_rulesetT;

struct gaia_rule;
struct gaia_ruleBuilder;
struct gaia_ruleT;

struct gaia_table;
struct gaia_tableBuilder;
struct gaia_tableT;

struct gaia_field;
struct gaia_fieldBuilder;
struct gaia_fieldT;

struct event_logT : public flatbuffers::NativeTable {
  typedef event_log TableType;
  uint32_t event_type;
  uint64_t type_id;
  uint64_t record_id;
  uint16_t column_id;
  uint64_t timestamp;
  bool rules_invoked;
  event_logT()
      : event_type(0),
        type_id(0),
        record_id(0),
        column_id(0),
        timestamp(0),
        rules_invoked(false) {
  }
};

struct event_log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef event_logT NativeTableType;
  typedef event_logBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_TYPE_ID = 6,
    VT_RECORD_ID = 8,
    VT_COLUMN_ID = 10,
    VT_TIMESTAMP = 12,
    VT_RULES_INVOKED = 14
  };
  uint32_t event_type() const {
    return GetField<uint32_t>(VT_EVENT_TYPE, 0);
  }
  uint64_t type_id() const {
    return GetField<uint64_t>(VT_TYPE_ID, 0);
  }
  uint64_t record_id() const {
    return GetField<uint64_t>(VT_RECORD_ID, 0);
  }
  uint16_t column_id() const {
    return GetField<uint16_t>(VT_COLUMN_ID, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool rules_invoked() const {
    return GetField<uint8_t>(VT_RULES_INVOKED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EVENT_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_TYPE_ID) &&
           VerifyField<uint64_t>(verifier, VT_RECORD_ID) &&
           VerifyField<uint16_t>(verifier, VT_COLUMN_ID) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_RULES_INVOKED) &&
           verifier.EndTable();
  }
  event_logT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(event_logT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<event_log> Pack(flatbuffers::FlatBufferBuilder &_fbb, const event_logT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct event_logBuilder {
  typedef event_log Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(uint32_t event_type) {
    fbb_.AddElement<uint32_t>(event_log::VT_EVENT_TYPE, event_type, 0);
  }
  void add_type_id(uint64_t type_id) {
    fbb_.AddElement<uint64_t>(event_log::VT_TYPE_ID, type_id, 0);
  }
  void add_record_id(uint64_t record_id) {
    fbb_.AddElement<uint64_t>(event_log::VT_RECORD_ID, record_id, 0);
  }
  void add_column_id(uint16_t column_id) {
    fbb_.AddElement<uint16_t>(event_log::VT_COLUMN_ID, column_id, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(event_log::VT_TIMESTAMP, timestamp, 0);
  }
  void add_rules_invoked(bool rules_invoked) {
    fbb_.AddElement<uint8_t>(event_log::VT_RULES_INVOKED, static_cast<uint8_t>(rules_invoked), 0);
  }
  explicit event_logBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  event_logBuilder &operator=(const event_logBuilder &);
  flatbuffers::Offset<event_log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<event_log>(end);
    return o;
  }
};

inline flatbuffers::Offset<event_log> Createevent_log(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t event_type = 0,
    uint64_t type_id = 0,
    uint64_t record_id = 0,
    uint16_t column_id = 0,
    uint64_t timestamp = 0,
    bool rules_invoked = false) {
  event_logBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_record_id(record_id);
  builder_.add_type_id(type_id);
  builder_.add_event_type(event_type);
  builder_.add_column_id(column_id);
  builder_.add_rules_invoked(rules_invoked);
  return builder_.Finish();
}

flatbuffers::Offset<event_log> Createevent_log(flatbuffers::FlatBufferBuilder &_fbb, const event_logT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_databaseT : public flatbuffers::NativeTable {
  typedef gaia_database TableType;
  gaia::direct_access::nullable_string_t name;
  gaia_databaseT() {
  }
};

struct gaia_database FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_databaseT NativeTableType;
  typedef gaia_databaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  gaia_databaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_databaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_database> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_databaseBuilder {
  typedef gaia_database Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_database::VT_NAME, name);
  }
  explicit gaia_databaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_databaseBuilder &operator=(const gaia_databaseBuilder &);
  flatbuffers::Offset<gaia_database> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_database>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_database> Creategaia_database(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  gaia_databaseBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_database> Creategaia_databaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::Creategaia_database(
      _fbb,
      name__);
}

flatbuffers::Offset<gaia_database> Creategaia_database(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_rulesetT : public flatbuffers::NativeTable {
  typedef gaia_ruleset TableType;
  gaia::direct_access::nullable_string_t name;
  bool active_on_startup;
  gaia::direct_access::nullable_string_t table_ids;
  gaia::direct_access::nullable_string_t source_location;
  gaia::direct_access::nullable_string_t serial_stream;
  gaia_rulesetT()
      : active_on_startup(false) {
  }
};

struct gaia_ruleset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_rulesetT NativeTableType;
  typedef gaia_rulesetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ACTIVE_ON_STARTUP = 6,
    VT_TABLE_IDS = 8,
    VT_SOURCE_LOCATION = 10,
    VT_SERIAL_STREAM = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool active_on_startup() const {
    return GetField<uint8_t>(VT_ACTIVE_ON_STARTUP, 0) != 0;
  }
  const flatbuffers::String *table_ids() const {
    return GetPointer<const flatbuffers::String *>(VT_TABLE_IDS);
  }
  const flatbuffers::String *source_location() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_LOCATION);
  }
  const flatbuffers::String *serial_stream() const {
    return GetPointer<const flatbuffers::String *>(VT_SERIAL_STREAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE_ON_STARTUP) &&
           VerifyOffset(verifier, VT_TABLE_IDS) &&
           verifier.VerifyString(table_ids()) &&
           VerifyOffset(verifier, VT_SOURCE_LOCATION) &&
           verifier.VerifyString(source_location()) &&
           VerifyOffset(verifier, VT_SERIAL_STREAM) &&
           verifier.VerifyString(serial_stream()) &&
           verifier.EndTable();
  }
  gaia_rulesetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_ruleset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_rulesetBuilder {
  typedef gaia_ruleset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_ruleset::VT_NAME, name);
  }
  void add_active_on_startup(bool active_on_startup) {
    fbb_.AddElement<uint8_t>(gaia_ruleset::VT_ACTIVE_ON_STARTUP, static_cast<uint8_t>(active_on_startup), 0);
  }
  void add_table_ids(flatbuffers::Offset<flatbuffers::String> table_ids) {
    fbb_.AddOffset(gaia_ruleset::VT_TABLE_IDS, table_ids);
  }
  void add_source_location(flatbuffers::Offset<flatbuffers::String> source_location) {
    fbb_.AddOffset(gaia_ruleset::VT_SOURCE_LOCATION, source_location);
  }
  void add_serial_stream(flatbuffers::Offset<flatbuffers::String> serial_stream) {
    fbb_.AddOffset(gaia_ruleset::VT_SERIAL_STREAM, serial_stream);
  }
  explicit gaia_rulesetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_rulesetBuilder &operator=(const gaia_rulesetBuilder &);
  flatbuffers::Offset<gaia_ruleset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_ruleset>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool active_on_startup = false,
    flatbuffers::Offset<flatbuffers::String> table_ids = 0,
    flatbuffers::Offset<flatbuffers::String> source_location = 0,
    flatbuffers::Offset<flatbuffers::String> serial_stream = 0) {
  gaia_rulesetBuilder builder_(_fbb);
  builder_.add_serial_stream(serial_stream);
  builder_.add_source_location(source_location);
  builder_.add_table_ids(table_ids);
  builder_.add_name(name);
  builder_.add_active_on_startup(active_on_startup);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_ruleset> Creategaia_rulesetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool active_on_startup = false,
    const char *table_ids = nullptr,
    const char *source_location = nullptr,
    const char *serial_stream = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto table_ids__ = table_ids ? _fbb.CreateString(table_ids) : 0;
  auto source_location__ = source_location ? _fbb.CreateString(source_location) : 0;
  auto serial_stream__ = serial_stream ? _fbb.CreateString(serial_stream) : 0;
  return gaia::catalog::Creategaia_ruleset(
      _fbb,
      name__,
      active_on_startup,
      table_ids__,
      source_location__,
      serial_stream__);
}

flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_ruleT : public flatbuffers::NativeTable {
  typedef gaia_rule TableType;
  gaia::direct_access::nullable_string_t name;
  uint64_t ruleset_id;
  gaia_ruleT()
      : ruleset_id(0) {
  }
};

struct gaia_rule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_ruleT NativeTableType;
  typedef gaia_ruleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_RULESET_ID = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t ruleset_id() const {
    return GetField<uint64_t>(VT_RULESET_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_RULESET_ID) &&
           verifier.EndTable();
  }
  gaia_ruleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_ruleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_rule> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_ruleBuilder {
  typedef gaia_rule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_rule::VT_NAME, name);
  }
  void add_ruleset_id(uint64_t ruleset_id) {
    fbb_.AddElement<uint64_t>(gaia_rule::VT_RULESET_ID, ruleset_id, 0);
  }
  explicit gaia_ruleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_ruleBuilder &operator=(const gaia_ruleBuilder &);
  flatbuffers::Offset<gaia_rule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_rule>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_rule> Creategaia_rule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t ruleset_id = 0) {
  gaia_ruleBuilder builder_(_fbb);
  builder_.add_ruleset_id(ruleset_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_rule> Creategaia_ruleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t ruleset_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return gaia::catalog::Creategaia_rule(
      _fbb,
      name__,
      ruleset_id);
}

flatbuffers::Offset<gaia_rule> Creategaia_rule(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_tableT : public flatbuffers::NativeTable {
  typedef gaia_table TableType;
  gaia::direct_access::nullable_string_t name;
  bool is_log;
  uint8_t trim_action;
  uint64_t max_rows;
  uint64_t max_size;
  uint64_t max_seconds;
  gaia::direct_access::nullable_string_t binary_schema;
  gaia_tableT()
      : is_log(false),
        trim_action(0),
        max_rows(0),
        max_size(0),
        max_seconds(0) {
  }
};

struct gaia_table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_tableT NativeTableType;
  typedef gaia_tableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_IS_LOG = 6,
    VT_TRIM_ACTION = 8,
    VT_MAX_ROWS = 10,
    VT_MAX_SIZE = 12,
    VT_MAX_SECONDS = 14,
    VT_BINARY_SCHEMA = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool is_log() const {
    return GetField<uint8_t>(VT_IS_LOG, 0) != 0;
  }
  uint8_t trim_action() const {
    return GetField<uint8_t>(VT_TRIM_ACTION, 0);
  }
  uint64_t max_rows() const {
    return GetField<uint64_t>(VT_MAX_ROWS, 0);
  }
  uint64_t max_size() const {
    return GetField<uint64_t>(VT_MAX_SIZE, 0);
  }
  uint64_t max_seconds() const {
    return GetField<uint64_t>(VT_MAX_SECONDS, 0);
  }
  const flatbuffers::String *binary_schema() const {
    return GetPointer<const flatbuffers::String *>(VT_BINARY_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_LOG) &&
           VerifyField<uint8_t>(verifier, VT_TRIM_ACTION) &&
           VerifyField<uint64_t>(verifier, VT_MAX_ROWS) &&
           VerifyField<uint64_t>(verifier, VT_MAX_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_MAX_SECONDS) &&
           VerifyOffset(verifier, VT_BINARY_SCHEMA) &&
           verifier.VerifyString(binary_schema()) &&
           verifier.EndTable();
  }
  gaia_tableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_tableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_tableBuilder {
  typedef gaia_table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_table::VT_NAME, name);
  }
  void add_is_log(bool is_log) {
    fbb_.AddElement<uint8_t>(gaia_table::VT_IS_LOG, static_cast<uint8_t>(is_log), 0);
  }
  void add_trim_action(uint8_t trim_action) {
    fbb_.AddElement<uint8_t>(gaia_table::VT_TRIM_ACTION, trim_action, 0);
  }
  void add_max_rows(uint64_t max_rows) {
    fbb_.AddElement<uint64_t>(gaia_table::VT_MAX_ROWS, max_rows, 0);
  }
  void add_max_size(uint64_t max_size) {
    fbb_.AddElement<uint64_t>(gaia_table::VT_MAX_SIZE, max_size, 0);
  }
  void add_max_seconds(uint64_t max_seconds) {
    fbb_.AddElement<uint64_t>(gaia_table::VT_MAX_SECONDS, max_seconds, 0);
  }
  void add_binary_schema(flatbuffers::Offset<flatbuffers::String> binary_schema) {
    fbb_.AddOffset(gaia_table::VT_BINARY_SCHEMA, binary_schema);
  }
  explicit gaia_tableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_tableBuilder &operator=(const gaia_tableBuilder &);
  flatbuffers::Offset<gaia_table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_table>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_table> Creategaia_table(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool is_log = false,
    uint8_t trim_action = 0,
    uint64_t max_rows = 0,
    uint64_t max_size = 0,
    uint64_t max_seconds = 0,
    flatbuffers::Offset<flatbuffers::String> binary_schema = 0) {
  gaia_tableBuilder builder_(_fbb);
  builder_.add_max_seconds(max_seconds);
  builder_.add_max_size(max_size);
  builder_.add_max_rows(max_rows);
  builder_.add_binary_schema(binary_schema);
  builder_.add_name(name);
  builder_.add_trim_action(trim_action);
  builder_.add_is_log(is_log);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_table> Creategaia_tableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool is_log = false,
    uint8_t trim_action = 0,
    uint64_t max_rows = 0,
    uint64_t max_size = 0,
    uint64_t max_seconds = 0,
    const char *binary_schema = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto binary_schema__ = binary_schema ? _fbb.CreateString(binary_schema) : 0;
  return gaia::catalog::Creategaia_table(
      _fbb,
      name__,
      is_log,
      trim_action,
      max_rows,
      max_size,
      max_seconds,
      binary_schema__);
}

flatbuffers::Offset<gaia_table> Creategaia_table(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct gaia_fieldT : public flatbuffers::NativeTable {
  typedef gaia_field TableType;
  gaia::direct_access::nullable_string_t name;
  uint64_t table_id;
  uint8_t type;
  uint64_t type_id;
  uint16_t repeated_count;
  uint16_t position;
  bool required;
  bool deprecated;
  bool active;
  bool nullable;
  bool has_default;
  gaia::direct_access::nullable_string_t default_value;
  gaia_fieldT()
      : table_id(0),
        type(0),
        type_id(0),
        repeated_count(0),
        position(0),
        required(false),
        deprecated(false),
        active(false),
        nullable(false),
        has_default(false) {
  }
};

struct gaia_field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef gaia_fieldT NativeTableType;
  typedef gaia_fieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TABLE_ID = 6,
    VT_TYPE = 8,
    VT_TYPE_ID = 10,
    VT_REPEATED_COUNT = 12,
    VT_POSITION = 14,
    VT_REQUIRED = 16,
    VT_DEPRECATED = 18,
    VT_ACTIVE = 20,
    VT_NULLABLE = 22,
    VT_HAS_DEFAULT = 24,
    VT_DEFAULT_VALUE = 26
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t table_id() const {
    return GetField<uint64_t>(VT_TABLE_ID, 0);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint64_t type_id() const {
    return GetField<uint64_t>(VT_TYPE_ID, 0);
  }
  uint16_t repeated_count() const {
    return GetField<uint16_t>(VT_REPEATED_COUNT, 0);
  }
  uint16_t position() const {
    return GetField<uint16_t>(VT_POSITION, 0);
  }
  bool required() const {
    return GetField<uint8_t>(VT_REQUIRED, 0) != 0;
  }
  bool deprecated() const {
    return GetField<uint8_t>(VT_DEPRECATED, 0) != 0;
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool nullable() const {
    return GetField<uint8_t>(VT_NULLABLE, 0) != 0;
  }
  bool has_default() const {
    return GetField<uint8_t>(VT_HAS_DEFAULT, 0) != 0;
  }
  const flatbuffers::String *default_value() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_TABLE_ID) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_TYPE_ID) &&
           VerifyField<uint16_t>(verifier, VT_REPEATED_COUNT) &&
           VerifyField<uint16_t>(verifier, VT_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRED) &&
           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_NULLABLE) &&
           VerifyField<uint8_t>(verifier, VT_HAS_DEFAULT) &&
           VerifyOffset(verifier, VT_DEFAULT_VALUE) &&
           verifier.VerifyString(default_value()) &&
           verifier.EndTable();
  }
  gaia_fieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(gaia_fieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<gaia_field> Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct gaia_fieldBuilder {
  typedef gaia_field Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(gaia_field::VT_NAME, name);
  }
  void add_table_id(uint64_t table_id) {
    fbb_.AddElement<uint64_t>(gaia_field::VT_TABLE_ID, table_id, 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_TYPE, type, 0);
  }
  void add_type_id(uint64_t type_id) {
    fbb_.AddElement<uint64_t>(gaia_field::VT_TYPE_ID, type_id, 0);
  }
  void add_repeated_count(uint16_t repeated_count) {
    fbb_.AddElement<uint16_t>(gaia_field::VT_REPEATED_COUNT, repeated_count, 0);
  }
  void add_position(uint16_t position) {
    fbb_.AddElement<uint16_t>(gaia_field::VT_POSITION, position, 0);
  }
  void add_required(bool required) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_REQUIRED, static_cast<uint8_t>(required), 0);
  }
  void add_deprecated(bool deprecated) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_nullable(bool nullable) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_NULLABLE, static_cast<uint8_t>(nullable), 0);
  }
  void add_has_default(bool has_default) {
    fbb_.AddElement<uint8_t>(gaia_field::VT_HAS_DEFAULT, static_cast<uint8_t>(has_default), 0);
  }
  void add_default_value(flatbuffers::Offset<flatbuffers::String> default_value) {
    fbb_.AddOffset(gaia_field::VT_DEFAULT_VALUE, default_value);
  }
  explicit gaia_fieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gaia_fieldBuilder &operator=(const gaia_fieldBuilder &);
  flatbuffers::Offset<gaia_field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gaia_field>(end);
    return o;
  }
};

inline flatbuffers::Offset<gaia_field> Creategaia_field(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t table_id = 0,
    uint8_t type = 0,
    uint64_t type_id = 0,
    uint16_t repeated_count = 0,
    uint16_t position = 0,
    bool required = false,
    bool deprecated = false,
    bool active = false,
    bool nullable = false,
    bool has_default = false,
    flatbuffers::Offset<flatbuffers::String> default_value = 0) {
  gaia_fieldBuilder builder_(_fbb);
  builder_.add_type_id(type_id);
  builder_.add_table_id(table_id);
  builder_.add_default_value(default_value);
  builder_.add_name(name);
  builder_.add_position(position);
  builder_.add_repeated_count(repeated_count);
  builder_.add_has_default(has_default);
  builder_.add_nullable(nullable);
  builder_.add_active(active);
  builder_.add_deprecated(deprecated);
  builder_.add_required(required);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<gaia_field> Creategaia_fieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t table_id = 0,
    uint8_t type = 0,
    uint64_t type_id = 0,
    uint16_t repeated_count = 0,
    uint16_t position = 0,
    bool required = false,
    bool deprecated = false,
    bool active = false,
    bool nullable = false,
    bool has_default = false,
    const char *default_value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto default_value__ = default_value ? _fbb.CreateString(default_value) : 0;
  return gaia::catalog::Creategaia_field(
      _fbb,
      name__,
      table_id,
      type,
      type_id,
      repeated_count,
      position,
      required,
      deprecated,
      active,
      nullable,
      has_default,
      default_value__);
}

flatbuffers::Offset<gaia_field> Creategaia_field(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline event_logT *event_log::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::event_logT> _o = std::unique_ptr<gaia::catalog::event_logT>(new event_logT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void event_log::UnPackTo(event_logT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); _o->event_type = _e; }
  { auto _e = type_id(); _o->type_id = _e; }
  { auto _e = record_id(); _o->record_id = _e; }
  { auto _e = column_id(); _o->column_id = _e; }
  { auto _e = timestamp(); _o->timestamp = _e; }
  { auto _e = rules_invoked(); _o->rules_invoked = _e; }
}

inline flatbuffers::Offset<event_log> event_log::Pack(flatbuffers::FlatBufferBuilder &_fbb, const event_logT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createevent_log(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<event_log> Createevent_log(flatbuffers::FlatBufferBuilder &_fbb, const event_logT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const event_logT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event_type;
  auto _type_id = _o->type_id;
  auto _record_id = _o->record_id;
  auto _column_id = _o->column_id;
  auto _timestamp = _o->timestamp;
  auto _rules_invoked = _o->rules_invoked;
  return gaia::catalog::Createevent_log(
      _fbb,
      _event_type,
      _type_id,
      _record_id,
      _column_id,
      _timestamp,
      _rules_invoked);
}

inline gaia_databaseT *gaia_database::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::gaia_databaseT> _o = std::unique_ptr<gaia::catalog::gaia_databaseT>(new gaia_databaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_database::UnPackTo(gaia_databaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_database> gaia_database::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_database(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_database> Creategaia_database(flatbuffers::FlatBufferBuilder &_fbb, const gaia_databaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_databaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return gaia::catalog::Creategaia_database(
      _fbb,
      _name);
}

inline gaia_rulesetT *gaia_ruleset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::gaia_rulesetT> _o = std::unique_ptr<gaia::catalog::gaia_rulesetT>(new gaia_rulesetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_ruleset::UnPackTo(gaia_rulesetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = active_on_startup(); _o->active_on_startup = _e; }
  { auto _e = table_ids(); if (_e) _o->table_ids = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = source_location(); if (_e) _o->source_location = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = serial_stream(); if (_e) _o->serial_stream = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_ruleset> gaia_ruleset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_ruleset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_ruleset> Creategaia_ruleset(flatbuffers::FlatBufferBuilder &_fbb, const gaia_rulesetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_rulesetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _active_on_startup = _o->active_on_startup;
  auto _table_ids = _o->table_ids.empty() ? 0 : _fbb.CreateString(_o->table_ids);
  auto _source_location = _o->source_location.empty() ? 0 : _fbb.CreateString(_o->source_location);
  auto _serial_stream = _o->serial_stream.empty() ? 0 : _fbb.CreateString(_o->serial_stream);
  return gaia::catalog::Creategaia_ruleset(
      _fbb,
      _name,
      _active_on_startup,
      _table_ids,
      _source_location,
      _serial_stream);
}

inline gaia_ruleT *gaia_rule::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::gaia_ruleT> _o = std::unique_ptr<gaia::catalog::gaia_ruleT>(new gaia_ruleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_rule::UnPackTo(gaia_ruleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = ruleset_id(); _o->ruleset_id = _e; }
}

inline flatbuffers::Offset<gaia_rule> gaia_rule::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_rule(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_rule> Creategaia_rule(flatbuffers::FlatBufferBuilder &_fbb, const gaia_ruleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_ruleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _ruleset_id = _o->ruleset_id;
  return gaia::catalog::Creategaia_rule(
      _fbb,
      _name,
      _ruleset_id);
}

inline gaia_tableT *gaia_table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::gaia_tableT> _o = std::unique_ptr<gaia::catalog::gaia_tableT>(new gaia_tableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_table::UnPackTo(gaia_tableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = is_log(); _o->is_log = _e; }
  { auto _e = trim_action(); _o->trim_action = _e; }
  { auto _e = max_rows(); _o->max_rows = _e; }
  { auto _e = max_size(); _o->max_size = _e; }
  { auto _e = max_seconds(); _o->max_seconds = _e; }
  { auto _e = binary_schema(); if (_e) _o->binary_schema = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_table> gaia_table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_table> Creategaia_table(flatbuffers::FlatBufferBuilder &_fbb, const gaia_tableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_tableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _is_log = _o->is_log;
  auto _trim_action = _o->trim_action;
  auto _max_rows = _o->max_rows;
  auto _max_size = _o->max_size;
  auto _max_seconds = _o->max_seconds;
  auto _binary_schema = _o->binary_schema.empty() ? 0 : _fbb.CreateString(_o->binary_schema);
  return gaia::catalog::Creategaia_table(
      _fbb,
      _name,
      _is_log,
      _trim_action,
      _max_rows,
      _max_size,
      _max_seconds,
      _binary_schema);
}

inline gaia_fieldT *gaia_field::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<gaia::catalog::gaia_fieldT> _o = std::unique_ptr<gaia::catalog::gaia_fieldT>(new gaia_fieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void gaia_field::UnPackTo(gaia_fieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
  { auto _e = table_id(); _o->table_id = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = type_id(); _o->type_id = _e; }
  { auto _e = repeated_count(); _o->repeated_count = _e; }
  { auto _e = position(); _o->position = _e; }
  { auto _e = required(); _o->required = _e; }
  { auto _e = deprecated(); _o->deprecated = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = nullable(); _o->nullable = _e; }
  { auto _e = has_default(); _o->has_default = _e; }
  { auto _e = default_value(); if (_e) _o->default_value = gaia::direct_access::nullable_string_t(_e->c_str(), _e->size()); }
}

inline flatbuffers::Offset<gaia_field> gaia_field::Pack(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Creategaia_field(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<gaia_field> Creategaia_field(flatbuffers::FlatBufferBuilder &_fbb, const gaia_fieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const gaia_fieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _table_id = _o->table_id;
  auto _type = _o->type;
  auto _type_id = _o->type_id;
  auto _repeated_count = _o->repeated_count;
  auto _position = _o->position;
  auto _required = _o->required;
  auto _deprecated = _o->deprecated;
  auto _active = _o->active;
  auto _nullable = _o->nullable;
  auto _has_default = _o->has_default;
  auto _default_value = _o->default_value.empty() ? 0 : _fbb.CreateString(_o->default_value);
  return gaia::catalog::Creategaia_field(
      _fbb,
      _name,
      _table_id,
      _type,
      _type_id,
      _repeated_count,
      _position,
      _required,
      _deprecated,
      _active,
      _nullable,
      _has_default,
      _default_value);
}

}  // namespace catalog
}  // namespace gaia

#endif  // FLATBUFFERS_GENERATED_CATALOG_GAIA_CATALOG_H_
