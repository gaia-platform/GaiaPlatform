/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////
#pragma once

#include <vector>
#include <unordered_set>

#include "events.hpp"

namespace gaia 
{
/**
 * \addtogroup Gaia
 * @{
 */

namespace rules 
{

/**
 * \addtogroup Rules
 * @{
 * 
 * Provides facilities for subscribing and unsubscribing rules
 * to events.
 */

struct rule_context_t;

/**
 * All rules must adhere to this prototype.  Since the preamble of the rule
 * is generated by a GaiaProcessor, the context parameter should
 * be cast to the appropriate derived context before use.
 */
typedef void (* gaia_rule_fn)(const rule_context_t * context);

/**
 * The application must provide an implementation of initialize_rules().  This
 * function is invoked when the event manager singleton is created.
 */ 
extern "C" void initialize_rules();

/**
 * The caller supplies a rule_binding to subscribe/unsubscribe rules to/from events.
 * The caller must supply the ruleset_name, rule_name, and the function pointer for the rule.
 * The ruleset_name and the rule_name must uniquely identify the rule.
  */
struct rule_binding_t {
    rule_binding_t() 
        : ruleset_name(nullptr)
        , rule_name(nullptr), 
        rule(nullptr) {}
    
    rule_binding_t(
        const char* a_ruleset_name, 
        const char* a_rule_name, 
        gaia_rule_fn a_rule)
        : ruleset_name(a_ruleset_name)
        , rule_name(a_rule_name)
        , rule(a_rule) {}
    
    const char* ruleset_name;
    const char* rule_name;
    gaia_rule_fn rule;
};

/**
 * This type is returned in a caller-supplied vector when
 * the list_rules api is called
 */ 
struct subscription_t {
    const char* ruleset_name;
    const char* rule_name;
    gaia::common::gaia_type_t gaia_type;
    event_type_t type;
    const char* field_name;
};

/**
 * Caller must provide an instance of this type when using the list_subscribed_rules
 * method below
 */
typedef std::vector<std::unique_ptr<subscription_t>> subscription_list_t;

/**
 * Caller provide a list of fields to bind to field_change events
 */
typedef std::unordered_set<std::string> field_list_t;

/**
 * The rule context wraps the event (or data) context as well as information 
 * about the event and rule metadata.  In the future the rule context may also 
 * maintain the error state of the rule invocation.  Therefore, the rule 
 * contexts map 1:1 to each rule that is bound to an event.  
 * Data contexts may apply to more than one rule. 
 * 
 * Note:  A single event may be bound to multiple rules or a rule may be bound
 * to multiple events. Rules may also be invoked both synchronously or 
 * asynchronously.  For this reason, events and rules are decoupled in 
 * the system.
 * 
 * The rule binding is included for debugging and may be removed in a later
 * iteration.
 */
struct rule_context_t 
{
public:            
    rule_context_t(
        const rule_binding_t& a_binding, 
        gaia::common::gaia_type_t a_gaia_type,
        event_type_t a_event_type,
        gaia::common::gaia_base_t * a_row,
        const char* a_field
    );

    rule_context_t() = delete;
    const rule_binding_t rule_binding;
    gaia::common::gaia_type_t gaia_type;
    event_type_t event_type;
    gaia::common::gaia_base_t* event_context;
    string event_source;
};

/**
 * Thrown when the caller provides an incomplete rule_binding_t structure.
 * 
 * The system needs the function pointer, rule_name, and ruleset_name to
 * be provided by the caller.
 */ 
class invalid_rule_binding: public gaia::common::gaia_exception
{
public:
    invalid_rule_binding()
    {
        m_message = "Invalid rule binding. "
            "Verify that the ruleset_name, rule_name and rule are provided.";
    }
};

/**
 * Thrown under two circumstances.  
 * 
 * First, the ruleset_name and rule_name must be unique across the system.  
 * If a caller submits a rule_binding that generates the same key but has 
 * a different rule definition then this exception is thrown.  
 * 
 * Second, if a user attempts to subscribe the same rule to the same 
 * gaia type and event  type then this event is thrown.  
 */ 
class duplicate_rule: public gaia::common::gaia_exception
{
public:
    duplicate_rule(const rule_binding_t& binding, bool duplicate_key_found)
    {
        std::stringstream message;
        if (duplicate_key_found)
        {
            message << binding.ruleset_name << "::"
                << binding.rule_name 
                << " already subscribed with the same key "
                "but different rule function.";
        }
        else
        {
            message << binding.ruleset_name << "::"
                << binding.rule_name 
                << " already subscribed to the same rule list.";
        }
        m_message = message.str();
    }
};

/**
 * Thrown when the caller either does not initialize the event manager
 * or attempts to initialize an already initialized event manager.
 */ 
class initialization_error : public gaia::common::gaia_exception
{
public:
    initialization_error(bool is_already_initialized)
    {
        if (is_already_initialized)
        {
            m_message = "The event manager has already been initialized.";
        }
        else
        {
            m_message = "The event manager has not been initialized yet.";
        }
    }
};

/**
 * Initializes the rules engine.  Should only be called once
 * per process.
 * 
 * @throw initialization_error
 */
void initialize_rules_engine();

/**
 * Subscribes this rule to a field change event (event_type_t::field_change).
 * 
 * If any field that is part of the field list changes, then this rule
 * will be fired.
 * 
 * @param gaia_type table type to bind the rule to
 * @param event_type read or write field event
 * @param fields the set of fields that will cause this rule to be fired if changed
 * @param rule_binding caller-supplied rule information; this call will populate rule_name
 * @throw invalid_rule_binding
 * @throw duplicate_rule
 * @throw initialization_error
 */
void subscribe_field_rule(
    gaia::common::gaia_type_t gaia_type, 
    event_type_t event_type,
    const field_list_t& fields,
    const rule_binding_t& rule_binding);

/**
 * Subscribes this rule to the specified table event scoped to the gaia_type. 
 *  
 * Note that it is valid to bind multiple different rules to the same event.  
 * It is also valid to bind the same rule to multiple different events.
 * 
 * @param gaia_type table type to bind the rule to
 * @param event_type the table event type to bind this rule to
 * @param rule_binding caller-supplied rule information; this call will populate rule_name
 * @throw invalid_rule_binding
 * @throw duplicate_rule
 * @throw initialization_error
 */
void subscribe_database_rule(
    gaia::common::gaia_type_t gaia_type, 
    event_type_t event_type, 
    const rule_binding_t& rule_binding);

/**
 * Unsubscribes this rule from the specified table event scoped by the gaia_type.
 * 
 * @param gaia_type table type to bind the rule to
 * @param type the event type to bind this rule to
 * @param fields the set of columns to unsubscribe the rule from
 * @param rule_binding caller-supplied rule information
 * @return true if the rule was unsubscribed; false otherwise.
 * @throw invalid_rule_binding
 * @throw initialization_error
 */
bool unsubscribe_field_rule(
    gaia::common::gaia_type_t gaia_type, 
    event_type_t type, 
    const field_list_t& fields,
    const rule_binding_t& rule_binding);

/**
 * Unsubscribes this rule from the specified database event scoped by the gaia_type.
 * 
 * @param gaia_type table type to bind the rule to
 * @param type the event type to bind this rule to
 * @param rule_binding caller-supplied rule information
 * @return true if the rule was unsubscribed; false otherwise.
 * @throw invalid_rule_binding
 * @throw initialization_error
 */
bool unsubscribe_database_rule(
    gaia::common::gaia_type_t gaia_type, 
    event_type_t type, 
    const rule_binding_t& rule_binding);

/**
 * Unsubscribes all rules that were subscribed from the system.  May be called
 * even if no rules have been subscribed.
 * @throw initialization_error
 */
void unsubscribe_rules();

/**
 * List all rules already subscribed to events.  
 * 
 * Enable filtering on ruleset name, gaia_type, field_name, and event_type.
 * 
 * @param ruleset_name Scope returned rules to specified rulset if provided.  May be null.
 * @param gaia_type Filter results by the object they refer to.  May be null.
 * @param event_type Filter by events you want.
 * @param field Filter by the field for field_read and field_write events.
 * @param subscriptions Caller provided vector to hold the results.  This method will clear any existing
 *      entries before adding new ones.
 * @throw initialization_error
 */
void list_subscribed_rules(
    const char* ruleset_name, 
    const gaia::common::gaia_type_t* gaia_type, 
    const event_type_t* event_type,
    const char * field_name, 
    subscription_list_t& subscriptions);

/*@}*/
}
/*@}*/
}
