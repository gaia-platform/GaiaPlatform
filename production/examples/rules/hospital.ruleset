////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////

// Include Gaia's built-in logger for the application.
#include "gaia/logger.hpp"

// The generated Direct Access classses are used for the 'interop' lesson.
#include "gaia_hospital.h"

// Pull in a helper to show the event type
#include "gaia/db/events.hpp"

// The direct access vector is used in the 'array' lesson.
#include "gaia/direct_access/dac_vector.hpp"

// Coordinates the declarative rules with the procedural lessons.
#include "lesson_manager.hpp"

// Tip:  if you are using VS-code, you can install the Gaia Platform Intellisense extension to get
// syntax highlighting and intellisense for Gaia DDL and Ruleset files.

// Show how to write rules that respond to column updates, table inserts, or both.
ruleset basics
{
    // [basics:1_doctor]
    //
    // This rule is fired when a doctor is inserted into the database.
    // Every rule acts on exactly one table change.  The row of the table
    // that changed is passed to the rule.  This row is known as the anchor row.
    // In this rule, we are printing the 'name' column from the 'doctor' who
    // was just inserted.
    on_insert(doctor)
    {
        rule_scope_t r("{}:{}: doctor '{}' was inserted.",
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // [basics:2_patient]
    //
    // This rule is fired when any column of the patient is updated.
    // Because the anchor row in this rule is the 'patient' table, the
    // 'name' refers to the patient's name.
    on_update(patient)
    {
        rule_scope_t r("{}:{}: patient '{}' was updated.",
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // [basics:3_patient]
    //
    // This rule will fire because we changed the 'is_active' column of the patient.
    // This rule also shows that you can fire multiple rules off a single database change.
    on_update(patient.is_active)
    {
        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated.",
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // [basics:4_patient]
    //
    // This rule shows a shortcut syntax for firing a rule
    // based on a single field change using the '@<column>' syntax.  This rule is
    // the same as the previous rule in that it fires when 'patient.is_active' changes.
    {
        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, patient.name, @patient.is_active);
    }

    // [basics:5_patient]
    //
    // This rule will fire because we changed the 'is_active' column of the patient. Note that
    // the rule will fire if either the 'is_active' or the 'name' column of the patient
    // is changed.  Gaia currently does not support firing a rule only if all the columns
    // listed in the 'on_update' directive are changed.
    on_update(patient.is_active, patient.name)
    {
        rule_scope_t r("{}:{}: patient '{}' 'is_active' status or 'name' was updated.",
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // [basics:6_patient]
    //
    // The 'on_change' keyword will cause the rule to fire if a new row is inserted
    // to the table or any column is updated in a table.
    on_change(patient)
    {
        // The 'rule_context' allows you to display information about a rule:
        // ruleset_name: name of the ruleset
        // rule_name: ordinal of the rule
        // event_type: what event caused the rule to fire
        // gaia_type: type of anchor object
        rule_scope_t r("{}:{}: patient '{}' was changed due to a '{}' event on type '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name,
            gaia::db::triggers::event_type_name(rule_context.event_type),
            rule_context.gaia_type);
    }
} // ruleset basics

// Show that a rule itself can make changes to the database such that another rule is fired.
ruleset forward_chaining
{
    // [forward_chaining:1_patient]
    //
    // This rule will update the 'is_active' field of the the patient and set it to true.
    // Updating the patient will then cause the next rule to fire.
    on_insert(patient)
    {
        rule_scope_t r("{}:{}: patient '{}' was inserted.",
            rule_context.ruleset_name, rule_context.rule_name, name);
        is_active = true;
    }

    // [forward_chaining:2_patient]
    //
    // This rule is fired because the first rule changes the 'is_active' field on the newly
    // inserted patient.
    on_update(patient.is_active)
    {
        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);
    }
} // ruleset forward_chaining

// Show how to navigate records related to the rule's anchor or all records
// for a particular object type in the database. This lesson also shows how
// to iterate over records using declarative 'if' and 'for' statements.
//
// By default, all rules run in parallel.  The 'serial_group' attribute ensures
// that no rules in this ruleset can run concurrently with each other. Because
// this sample logs mulitple rows from each rule, we want to serialize
// the rules so that they don't interleave their output for the tutorial.
ruleset navigation : serial_group()
{
    // [navigation:1_patient]
    //
    // This rule shows navigating objects related to the patient.  Because
    // the anchor row of this rule is the patient and relationships exist both
    // to a patient's doctor and a patient's address, we can access the data from
    // these related objects.
    on_update(patient.is_active)
    {
        if (patient.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Because Gaia understands how your data is connected, you can directly
        // reference columns in related tables.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, address.street, address.city);
    }

    // [navigation:2_patient]
    //
    // This rule is the same as above but shows the '->' operator to
    // explicitly navigate tables.  This rule is semantically equivalent
    // to the above rule.
    on_update(patient.is_active)
    {
        if (!patient.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Because Gaia understands how your data is connected, you can directly
        // reference related information.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, patient->doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, patient->address.street, patient->address.city);
    }

    // [navigation:3_doctor]
    //
    // This rule shows listing all the patients for whom
    // this doctor cares.
    on_update(doctor.is_active)
    {
        if (!doctor.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // List all the patients of this doctor.  Because the schema for this application
        // specifies that a doctor may have many patients, Gaia will actually loop
        // over all the patients belonging to this doctor.  In other words, this statement
        // is executed for every patient related to the 'doctor' anchor row.
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);
    }

    // [navigation:4_doctor]
    //
    // This rule lists all the patients for whom this doctor cares
    // using a more explicit syntax than the above rule. The rule
    // is semantically equivalent to the previous rule.
    on_update(doctor.is_active)
    {
        if (doctor.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // You can also iterate over all of the doctor's patients
        // using a declarative 'for'
        for (patient)
        {
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, doctor.name);
        }
    }

    // [navigation:5_doctor]
    //
    // This rule lists all of the patients stored in the database.  By using
    // the '/' modifier on the table, we can access all records in the database and
    // not just the ones directly related to the 'doctor' anchor row.
    on_update(doctor.name)
    {
        rule_scope_t r("{}:{}: doctor '{}' is a new name.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // If you wanted to list all patients (not just those related to the doctor)
        // then use the '/' modifier.
        for (/patient)
        {
            // Note that if we had just displayed 'doctor.name', then
            // it would have been the anchor row's doctor and not the doctor
            // related to this patient.  In this case, we specifically want
            // the patient's doctor so use the '->' operator to traverse
            // the relationship.
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, patient->doctor.name);
        }
    }

    // [navigation:6_doctor]
    //
    // This rule shows the use of the nomatch clause in the case when a doctor
    // has no related patients.
    on_insert(doctor)
    {
        rule_scope_t r("{}:{}: doctor '{}' was added.",
            rule_context.ruleset_name, rule_context.rule_name, name);

        if (patient.is_active)
        {
            gaia_log::app().info("Patient '{}' is active", patient.name);
        }
        nomatch
        {
            gaia_log::app().info("'{}' has no patients.", doctor.name);
        }
    }

    // [navigation:7_patient]
    //
    // This shows that the nomatch clause can be used with a 1:1 relationship (patient->doctor).
    on_insert(patient)
    {
        rule_scope_t r("{}:{}: patient '{}' was added.",
            rule_context.ruleset_name, rule_context.rule_name, name);

        if (doctor.is_active)
        {
            gaia_log::app().info("Patient '{}' is assigned to '{}'.",
                patient.name, doctor.name);
        }
        nomatch
        {
            gaia_log::app().info("Patient '{}' is not assigned to a doctor yet.",
                patient.name);
        }
    }

    // [navigation:8_address]
    //
    // This shows that nomatch clauses can be nested.
    on_insert(address)
    {
        rule_scope_t r("{}:{}: address '{}' was added.",
            rule_context.ruleset_name, rule_context.rule_name, id);

        for(/this_doctor:doctor)
        {
            for(this_doctor->this_patient:patient)
            {
                gaia_log::app().info("Doctor '{}' has patient '{}'.",
                    this_doctor.name, this_patient.name);
            }
            nomatch
            {
                gaia_log::app().info("Doctor '{}' has no patients.",
                    this_doctor.name);

                for (/that_patient:patient)
                {
                    if (strcmp(that_patient->this_address:address.city, "Seattle") == 0)
                    {
                        gaia_log::app().info("Patient '{}' lives in Seattle on '{}'.",
                            that_patient.name, this_address.street);
                    }
                    nomatch
                    {
                        gaia_log::app().info("Patient '{}' has not submitted an address.",
                            that_patient.name);
                    }
                }
            }
        }
    }
} // ruleset navigation

// Shows how to use tags in rules. Tags are a way to explicitly represent a row and
// have rule or statement scope.
ruleset tags : serial_group()
{
    // [tags:1_doctor]
    //
    // Shows the use of a tag for a rule's anchor row.  In this case
    // 'anchor_doctor' can be used anywhere 'doctor' is used.
    on_update(anchor_doctor:doctor.is_active)
    {
        if (anchor_doctor.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, anchor_doctor.name, doctor.is_active);
    }

    // [tags:2_doctor]
    //
    // Shows the use of a tag as a loop variable
    on_update(anchor_doctor:doctor.is_active)
    {
        if (!anchor_doctor.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, anchor_doctor.name, doctor.is_active);

        for(/loop_doctor:doctor)
        {
            gaia_log::app().info("Loop doctor is '{}', anchor doctor is '{}'",
                loop_doctor.name, anchor_doctor.name);
        }
    }

    // [tags:3_doctor]
    //
    // Declare and use a tag in the same statement
    on_update(doctor.name)
    {
        if (strcmp(doctor.name, "Dr. DeclareUseTag") != 0)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' 'is_active' status is '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // You can declare and use a tag in a statement.  The following
        // line declares 'tag_patient' and then uses it to refer to the patient's active
        // status.
        gaia_log::app().info("Patient '{}' for doctor '{}' active status is '{}'.",
            doctor->tag_patient:patient.name, doctor.name, tag_patient.is_active);

    }

    // [tags:4_doctor]
    //
    // Using multiple tags in a single statement
    on_update(doctor.name)
    {
        if (strcmp(doctor.name, "Dr. MultiTags") != 0)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' 'is_active' status is '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // You can declare multiple tags in a single statement
        for (tag_doctor:doctor->tag_patient:patient->tag_address:address)
        {
            gaia_log::app().info("'{}' has patient '{}' who lives in '{}'.",
                tag_doctor.name,
                tag_patient.name,
                tag_address.city);
        }
    }

    // [tags:5_doctor]
    //
    // Using nested tags
    on_update(doctor.name)
    {
        if (strcmp(doctor.name, "Dr. NestedTags") != 0)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' 'is_active' status is '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // Like variables, tags are valid across enclosing scopes.
        for (tag_doctor:doctor)
        {
            for (tag_doctor->tag_patient:patient)
            {
                for (tag_patient->tag_address:address)
                    gaia_log::app().info("'{}' has patient '{}' who lives in '{}'.",
                        tag_doctor.name,
                        tag_patient.name,
                        tag_address.city);
            }

            // It's legal to redeclare a tag once it goes out of scope
            if (!tag_patient:patient.is_active)
            {
                gaia_log::app().info("Patient '{}' is inactive.", tag_patient.name);
            }
        }
    }
} // ruleset tags

// Shows how to connect and disconnect records to each other for both
// value-linked and non-value-linked references.
ruleset connections
{
    // [connections:1_patient]
    //
    // Connect a patient to the first active doctor in the database.
    on_update(patient.is_active)
    {
        // If a patient is not active, then do not make
        // any changes in this rule.
        if (!patient.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Note that this statement will not execute because the patient
        // is not connected to any doctor yet.
        gaia_log::app().info("'{}' is already a patient of '{}'.",
            patient.name, patient->doctor.name);

        // Declarative 'if' statements may translate into a loop for
        // traversing 1:M relationships.  Therefore, we allow 'break' functionality by
        // associating a label 'found_doctor' with the declarative if statement. This
        // code will break after finding the first doctor who is active. Note that labels
        // can also be used for 'continue' functionality as well.
        found_doctor:
        if (/doctor.is_active)
        {
            doctor.connect(patient);
            break found_doctor;
        }

        // Now that the patient has been connected, this statement
        // will execute.
        gaia_log::app().info("'{}' is now a patient of '{}'.",
            patient.name, patient->doctor.name);
    }

    // [connections:2_patient]
    //
    // If a patient moves from active to inactive status, then disconnect
    // the patient from the doctor.
    on_update(patient.is_active)
    {
        // If a patient is active then don't make changes in
        // this rule.
        if (patient.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: patient '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Remember the doctor's name. After we disconnect
        // the doctor from the patient, we won't be able to navigate
        // to it again. Note that we need to split apart the declaration
        // of 'doctor_name' from its initialization. This is because the
        // 'doctor_name' may never be assigned if the patient is not connected
        // to any doctors.
        const char* doctor_name = nullptr;
        doctor_name = doctor.name;
        doctor.disconnect(patient);

        gaia_log::app().info("Patient '{}' is no longer a patient of '{}'.",
            patient.name, doctor_name);
    }

    // [connections:3_address]
    //
    // Show that no explicit call to connect or disconnect is needed
    // for tables value linked relationships.
    on_update(address.street)
    {
        rule_scope_t r("{}:{}: Address '{}' 'street' was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, address.id, street);

        gaia_log::app().info("Patient '{}' lives on '{}' in '{}'.",
            patient.name, address.street, address.city);

        // The anchor address is Jim Holden's address which means that
        // the connected patient is 'Jim Holden'.  Change Jim's address_id
        // to the same address_id as Naomi.
        uint32_t naomi_address = 0;
        if (strcmp("Naomi Nagata", /naomi:patient.name) == 0)
        {
            // Because we have defined a value linked address between a patient
            // and their address, we can update the connections just by changing
            // the value of the field involved in the relationship.
            patient.address_id = naomi.address_id;
        }

        // Show Jim's address again.  Note, however, that the anchor address row
        // is still pointing to Jim's old address.  In fact, Jim is now not reachable
        // from this address as he no longer lives there.  So, find Jim again in the
        // database and print out his address.
        if (strcmp("Jim Holden", /jim:patient.name) == 0)
        {
            gaia_log::app().info("Patient '{}' now lives on '{}' in '{}'.",
                jim.name, jim->address.street, jim->address.city);
        }
    }
} // ruleset connections

// Shows how to insert and remove records from the database.
ruleset insert_delete
{
    // [insert_delete:1_doctor]
    //
    // This rule inserts a new patient into the database. You can specify column
    // name : value pairs in the insert statement.
    on_update(doctor.is_active)
    {
        if (doctor.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' status is '{}'",
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        if (strcmp("Alex Kamal", /alex:patient.name) == 0)
        {
            // Insert a new patient and have them live at the same address as Alex Kamal.
            patient.insert(name : "Alex Roomie", address_id : alex.address_id);
        }

        for (/patient)
        {
            gaia_log::app().info("Patient '{}' lives at '{}' in '{}'",
                patient.name, patient->address.street, patient->address.city);
        }
    }

    // [insert_delete:2_doctor]
    //
    // This rule inserts a new patient into the database and connects it to
    // the updated doctor.
    on_update(doctor.is_active)
    {
        if (!doctor.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' status is '{}'",
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // Insert a patient for this doctor and connect them.
        doctor.connect(patient.insert(name : "Rule Patient", is_active:true));

        gaia_log::app().info("'{}' has patient '{}'",
            doctor.name, patient.name);
    }

    // [insert_delete:3_patient]
    //
    // If a patient changes status to inactive, then remove them from their doctor
    // and delete them.
    on_update(patient.is_active)
    {
        if (patient.is_active)
        {
            return;
        }

        rule_scope_t r("{}:{}: '{}' status is '{}'",
            rule_context.ruleset_name, rule_context.rule_name, patient.name, patient.is_active);

        doctor.disconnect(patient);
        patient.remove();

        // Verify the rule patient is gone
        gaia_log::app().info("Patients:");
        gaia_log::app().info("'{}'", /patient.name);
    }
} // ruleset insert_delete

// Shows how declarative C++ and normal C++ can interoperate.
ruleset interop
{
    // This is a normal C++ function that we can call from a rule. This means
    // that no translation occurs for this code.
    void reassign_patients(gaia::hospital::doctor_t& doctor)
    {
        std::vector<gaia::hospital::patient_t> patient_list;
        for (auto patient : doctor.patients())
        {
            patient_list.push_back(patient);
        }

        // Remove all patients from this doctor
        doctor.patients().clear();

        // Reassign patients to the first active doctor we find.
        auto active_doctor = *(gaia::hospital::doctor_t::list().where(
            gaia::hospital::doctor_expr::is_active == true).begin());

        for (auto patient : patient_list)
        {
            active_doctor.patients().connect(patient);
            gaia_log::app().info("'{}' has been reassigned from '{}' to '{}'.",
                patient.name(), doctor.name(), active_doctor.name());
        }
    }

    // [interop:1_doctor]
    //
    // If 'Dr. Cox' moves to inactive status then reassign all the doctor's
    // patients to an active doctor.
    on_update(doctor.is_active)
    {
        if (strcmp(doctor.name, "Dr. Cox") != 0)
        {
            return;
        }

        rule_scope_t r("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Call our C++ function defined above.
        reassign_patients(doctor);
    }

    // [interop:2_doctor]
    //
    // If a doctor besides 'Dr. Cox' moves to inactive status, then reassign all the doctor's
    // patients to an active doctor.  Show mixed C++ and declarative C++ in the same rule.
    on_update(doctor.is_active)
    {
        if (strcmp(doctor.name, "Dr. Cox") == 0)
        {
            return;
        }

        rule_scope_t r("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.",
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // We can interoperate between normal C++ code and Gaia
        // Declarative C++ within a rule seamlessly.  The below code takes a "snapshot"
        // of all the patients belonging to this doctor. The rule then iterates over
        // the snapshot to disconnect all patients from the inactive doctor and assign
        // them to an active doctor.
        std::vector<gaia::hospital::patient_t> patient_list;
        patient_list.push_back(patient);

        // Iterate over each direct access patient object
        // that we stored in the patient list.  Because we are using
        // the direct access patient class directly, we need to
        // use the method name for lookup (i.e. 'dac_patient.name()' instead
        // of just 'patient.name').
        for (auto dac_patient : patient_list)
        {
            doctor.disconnect(dac_patient);

            found_doctor:
            if(/active_doctor:doctor.is_active)
            {
                active_doctor.connect(dac_patient);
                gaia_log::app().info("'{}' has been reassigned from '{}' to '{}'.",
                    dac_patient.name(), doctor.name, active_doctor.name);
                break found_doctor;
            }
        }
    }
} // ruleset interop

// Shows how to use array fields.
ruleset arrays
{
    // Array support in our declarative language is a work in progress.
    // We need to use normal C++ to retrieve the size of the array.
    uint32_t get_result_size(gaia::hospital::patient_t& patient)
    {
        return patient.analysis_results().size();
    }

    // [arrays:1_patient]
    //
    // Array fields can be used like any other field and support.
    on_update(analysis_results)
    {
        rule_scope_t r("{}:{}: patient '{}' has '{}' results:",
            rule_context.ruleset_name, rule_context.rule_name,
            patient.name, get_result_size(patient));

        for (auto result : analysis_results)
        {
            gaia_log::app().info("{}", result);
        }
    }

    // [arrays:2_patient]
    //
    // Array fields can be access like any other field.
    on_update(patient.is_active)
    {
        rule_scope_t r("{}:{}: patient '{}' has status '{}'",
            rule_context.ruleset_name, rule_context.rule_name, patient.name, patient.is_active);

        // Add more test results
        analysis_results = {analysis_results[0], analysis_results[1], 7.89, 10.1112};
    }
} // ruleset arrays
