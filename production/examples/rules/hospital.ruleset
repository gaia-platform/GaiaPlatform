////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////
#include "gaia/logger.hpp"
#include "gaia_hospital.h"
#include "gaia/db/events.hpp"

// Tip:  if you are using VS-code, you can install the Gaia Platform Intellisense extension to get
// syntax highlighting and intellisense for Gaia DDL and Ruleset files.
ruleset basics
{
    // Fired by: run_insert_rule.
    //
    // This rule is fired when a doctor is inserted into the database.
    // Every rule acts on exactly one table change.  The row of the table
    // that changed is passed to the rule.  This row is known as the anchor row.
    // In this rule, we are printing the 'name' column from the 'doctor' table.
    // In fact, we are printing the 'name' of the 'doctor' who was inserted.
    on_insert(doctor)
    {
        gaia_log::app().info("{}:{}: doctor '{}' was inserted.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule is fired when any column of the patient is updated.
    // Since the anchor row in this rule is the 'patient' table, the
    // 'name' refers to the patient's name.
    on_update(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: none.
    //
    // This rule shows that Gaia can respond to changes at the column level.
    // Since the patient's name was not changed, this rule is never fired.
    on_update(patient.name)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'name' field was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule will fire since we changed the 'is_active' column of the patient.
    // This rule also shows that you can fire multiple rules off a single database change.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule shows a shortcut syntax for firing a rule
    // based on a single field change using the '@<column>' syntax.  This rule is
    // the same as the previous rule in that it fires when 'patient.is_active' changes.
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, patient.name, @patient.is_active);
    }

    // Fired by: run_update_rule.
    //
    // This rule will fire since we changed the 'is_active' column of the patient. Note that
    // the rule will fire if either the 'is_active' or the 'name' column of the patient
    // is changed.  Gaia currently does not support firing a rule only if all the columns
    // listed in the 'on_update' directive are changed.
    on_update(patient.is_active, patient.name)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status or 'name' was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }    

    // Fired by: run_update_rule, run_insert_rule.
    //
    // The 'on_change' keyword will cause the rule to fire if a new row is inserted
    // to the table or any column is updated in a table.
    on_change(patient)
    {
        // The 'rule_context' allows you to display information about a rule:
        // ruleset_name: name of the ruleset
        // rule_name: ordinal of the rule
        // event_type: what event caused the rule to fire
        // gaia_type: type of anchor object
        gaia_log::app().info("{}:{}: patient '{}' was fired due to a '{}' event on type '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, 
            gaia::db::triggers::event_type_name(rule_context.event_type),
            rule_context.gaia_type);
    }
} // ruleset basics

ruleset forward_chaining
{
    // Fired by: run_insert_rule
    //
    // This rule will update the 'is_active' field of the the patient and set it to true.
    // Updating the patient will then cause the next rule to fire.
    on_insert(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was inserted.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
        is_active = true;
    }

    // Fired by: previous rule which changes the 'is_active' field to true.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

    }
} // ruleset forward_chaining

// By default, all rules run in parallel.  The 'serial_group' attribute ensures 
// that no rules in this ruleset can run concurrently with each other. Because
// this sample logs mulitple rows from each rule, we want to serialize
// the rules so that they don't interleave their output for the tutorial.
ruleset navigation : serial_group()
{
    // Fired by: run_navigate_one_to_one
    //
    // This rule shows navigating objects related to the patient.  Because 
    // the anchor row of this rule is the patient and relationships exist both
    // to a patient's doctor and a patient's address, we can access the data from
    // these related objects.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Since Gaia understands how your data is connected, you can directly
        // reference columns in related tables.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, address.street, address.city);
    }

    // Fired by: run_navigate_one_to_one
    //
    // This rule is the same as above but shows the '->' operator to
    // explicitly navigate tables.  This rule is semantically equivalent
    // to the above rule.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Since Gaia understands how your data is connected, you can directly
        // reference related information.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, patient->doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, patient->address.street, patient->address.city);
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule shows listing all the patients for whom
    // this doctor cares.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // List all the patients of this doctor.  Since the schema for this application
        // specifies that a doctor may have many patients, Gaia will actually loop
        // over all the patients belonging to this doctor.  In other words, this statement
        // is executed for every patient related to the 'doctor' anchor row.
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule lists all the patients for whom this doctor cares
    // using a more explicit syntax than the above rule. The rule
    // is semantically equivalent to the previous rule.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // You can also iterate over all of the doctor's patients
        // using a declarative 'for'
        for (patient)
        {
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, doctor.name);
        }
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule lists all of the patients stored in the database.  By using
    // the '/' modifier on the table, we can access all records in the database and
    // not just the ones directly related to the 'doctor' anchor row.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // If you wanted to list all patients (not just those related to the doctor)
        // then use the '/' modifier.
        for (/patient)
        {
            // Note that if we had just displayed 'doctor.name', then
            // it would have been the anchor row's doctor and not the doctor
            // related to this patient.  In this case, we specifically want
            // the patient's doctor so use the '->' operator to traverse
            // the relationship.
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, patient->doctor.name);
        }
    }

    // Fired by: run_navigate_nomatch
    //
    // This rule shows the use of the nomatch clause in the case when a doctor
    // has no related patients.
    on_insert(doctor)
    {
        gaia_log::app().info("{}:{}: doctor '{}' was added.", 
            rule_context.ruleset_name, rule_context.rule_name, name);

        if (patient.is_active)
        {
            gaia_log::app().info("Patient '{}' is active", patient.name); 
        }
        nomatch
        {
            gaia_log::app().info("'{}' has no patients.", doctor.name); 
        }
    }

    // Fired by: run_navigate_nomatch
    //
    // This shows that the nomatch clause can be used with a 1:1 relationship (patient->doctor).
    on_insert(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was added.", 
            rule_context.ruleset_name, rule_context.rule_name, name);

        if (doctor.is_active)
        {
            gaia_log::app().info("Patient '{}' is assigned to '{}'.", 
                patient.name, doctor.name); 
        }
        nomatch
        {
            gaia_log::app().info("Patient '{}' is not assigned to a doctor yet.", 
                patient.name); 
        }
    }

    // Fired by: run_navigate_nomatch
    //
    // This shows that nomatch clauses can be nested.
    on_insert(doctor)
    {
        gaia_log::app().info("{}:{}: patient '{}' was added.", 
            rule_context.ruleset_name, rule_context.rule_name, name);

        if (patient.is_active)
        {
            gaia_log::app().info("Active patient '{}' is assigned to '{}'.", 
                patient.name, doctor.name); 
        }
        else
        {
            gaia_log::app().info("Inactive patient '{}' is assigned to '{}'.", 
              patient.name, doctor.name); 
            
            if (strcmp(patient->address.city, "Seattle") == 0)
            {
                gaia_log::app().info("Inactive patient '{}' lives in Seattle.", 
                    patient.name); 
            }
            nomatch
            {
                gaia_log::app().info("Patient '{}' does not have an address.", 
                    patient.name);
            }
        }
        nomatch
        {
            gaia_log::app().info("Patient '{}' is not assigned to a doctor yet.", 
                patient.name); 
        }
    }
} // ruleset navigation

ruleset tags : serial_group()
{
    // Fired by: run_tags_simple
    //
    // Shows the use of a tag for a rule's anchor row.  In this case
    // 'anchor_doctor' can be used anywhere 'doctor' is used.
    on_update(anchor_doctor:doctor)
    {
        gaia_log::app().info("{}:{}: '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, anchor_doctor.name, doctor.is_active);
    }

    // Fired by: run_tags_simple
    //
    // Shows the use of a tag as a loop variable
    on_update(anchor_doctor:doctor)
    {
        gaia_log::app().info("{}:{}: '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, anchor_doctor.name, doctor.is_active);

        for(/loop_doctor:doctor)
        {
            gaia_log::app().info("Loop doctor is '{}', anchor doctor is '{}'", 
                loop_doctor.name, anchor_doctor.name);
        }
    }

    // Fired by: run_tags_simple
    //
    // Declare and use a tag in the same statement
    on_update(doctor)
    {
        gaia_log::app().info("{}:{}: '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // You can declare and use a tag in a statement.  The following
        // line declares 'tag_patient' and then uses it to refer to the patient's active
        // status.
        gaia_log::app().info("Patient '{}' 'is_active' status is '{}'.",
            doctor->tag_patient:patient.name, tag_patient.is_active);

    }

    // Fired by: run_tags_simple
    //
    // Using multiple tags in a single statement
    on_update(doctor)
    {
        gaia_log::app().info("{}:{}: '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // You can declare multiple tags in a single statement
        for (tag_doctor:doctor->tag_patient:patient->tag_address:address)
        {
            gaia_log::app().info("'{}' has patient '{}' who lives in '{}'.",
                tag_doctor.name,
                tag_patient.name,
                tag_address.city);
        }
    }

    // Fired by: run_tags_simple
    //
    // Using nested tags
    on_update(doctor)
    {
        gaia_log::app().info("{}:{}: '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, doctor.name, doctor.is_active);

        // Like variables, tags are valid across enclosing scopes.
        for (tag_doctor:doctor)
        {
            for (tag_doctor->tag_patient:patient)
            {
                for (tag_patient->tag_address:address)
                    gaia_log::app().info("'{}' has patient '{}' who lives in '{}'.",
                        tag_doctor.name,
                        tag_patient.name,
                        tag_address.city);
            }

            // It's legal to redeclare a tag once it goes out of scope
            if (!tag_patient:patient.is_active)
            {
                gaia_log::app().info("Patient '{}' is inactive.", tag_patient.name);
            }
        }
    }
} // ruleset tags

ruleset insert_delete
{
} // ruleset insert_delete

ruleset connections
{
    // Fired by: run_connect_patient, run_disconnect_patient
    //
    // Connect a patient to the first active doctor in the database.
    on_update(patient.is_active)
    {
        // If a patient is not active, then do not make
        // any changes in this rule.
        if (!patient.is_active)
        {
            return;
        }

        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Note that this statement will not execute because the patient
        // is not connected to any doctor yet.
        gaia_log::app().info("'{}' is already a patient of '{}'.",
            patient.name, patient->doctor.name);

        // NEW CONCEPT: declarative 'if' statements may translate into a loop for
        // traversing 1:M relationships.  Therefore, we allow 'break' functionality by
        // associating a label 'found_doctor' with the declarative if statement. This
        // code will break after finding the first doctor who is active. Note that labels
        // can also be used for 'continue' functionality as well.
        found_doctor:
        if (/doctor.is_active)
        {
            doctor.connect(patient);
            break found_doctor;
        }

        // Now that the patient has been connected, this statement
        // will execute.
        gaia_log::app().info("'{}' is now a patient of '{}'.",
            patient.name, patient->doctor.name);
    }

    // Fired by: run_connect_patient, run_disconnect_patient
    //
    // If a patient moves from active to inactive status, then disconnect
    // the patient from the doctor.
    on_update(patient.is_active)
    {
        // If a patient is active then don't make changes in
        // this rule.
        if (patient.is_active)
        {
            return;
        }

        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Remember the doctor's name. After we disconnect
        // the doctor from the patient, we won't be able to navigate
        // to it again. Note that we need to split apart the declaration
        // of 'doctor_name' from its initialization. This is because the
        // 'doctor_name' may never be assigned if the patient is not connected
        // to any doctors.
        const char* doctor_name = nullptr;
        doctor_name = doctor.name;
        doctor.disconnect(patient);

        // Note that this statement will not execute because the patient
        // is not connected to any doctor yet.
        gaia_log::app().info("Patient '{}' is no longer a patient of '{}'.",
            patient.name, doctor_name);
    }

    // Fired by: run_change_address
    //
    // Show that no explicit call to connect or disconnect is needed
    // for tables value linked relationships.
    on_update(address.street)
    {
        gaia_log::app().info("{}:{}: Address '{}' 'street' was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, address.id, street);

        gaia_log::app().info("Patient '{}' lives on '{}' in '{}'.",
            patient.name, address.street, address.city);
        
        // The anchor address is Jim Holden's address which means that
        // the connected patient is 'Jim Holden'.  Change Jim's address_id
        // to the same address_id as Naomi.
        uint32_t naomi_address = 0;
        if (strcmp("Naomi Nagata", /naomi:patient.name) == 0)
        {
            // Because we have defined a value linked address between a patient
            // and his address, we can update the connections just by changing
            // the value of the field involved in the relationship.
            patient.address_id = naomi.address_id;
        }

        // Show Jim's address again.  Note, however, that the anchor address row
        // is still pointing to Jim's old address.  In fact, Jim is now not reachable
        // from this address as he no longer lives there.  So, find Jim again in the 
        // database and print out his address.
        if (strcmp("Jim Holden", /jim:patient.name) == 0)
        {
            gaia_log::app().info("Patient '{}' now lives on '{}' in '{}'.",
                jim.name, jim->address.street, jim->address.city);
        }
    }
} // ruleset connections

// This is a normal C++ function that we can call from a rule. This means
// that no translation occurs for this code.
void reassign_patients(gaia::hospital::doctor_t& doctor)
{
    std::vector<gaia::hospital::patient_t> patient_list;
    for (auto patient : doctor.patients())
    {
        patient_list.push_back(patient);
    }

    // Remove all patients from this doctor
    doctor.patients().clear();

    // Reassign patients to the first active doctor we find.
    auto active_doctor = *(gaia::hospital::doctor_t::list().where(
        gaia::hospital::doctor_expr::is_active == true).begin());
    for (auto patient : patient_list)
    {
        active_doctor.patients().connect(patient);
        gaia_log::app().info("'{}' has been reassigned from '{}' to '{}'.",
            patient.name(), doctor.name(), active_doctor.name());
    }
}


ruleset interop
{

    // Fired by: run_interop_patient
    //
    // If 'Dr. Cox' moves to inactive status then reassign all the doctor's
    // patients to an active doctor.
    on_update(doctor.is_active)
    {
        if (strcmp(doctor.name, "Dr. Cox") != 0)
        {
            return;
        }

        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Call our C++ function defined above.
        reassign_patients(doctor);
    }

    // Fired by: run_interop_patient
    //
    // If a doctor besides 'Dr. Cox' moves to inactive status, then reassign all the doctor's
    // patients to an active doctor.  Show mixed C++ and declarative C++ in the same rule.
    on_update(doctor.is_active)
    {
        if (strcmp(doctor.name, "Dr. Cox") == 0)
        {
            return;
        }

        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // NEW CONCEPT:  We can interoperate between normal C++ code and Gaia 
        // Declarative C++ within a rule seamlessly.  The below code takes a "snapshot"
        // of all the patients belonging to this doctor. The rule then iterates over
        // the snapshot to disconnect all patients from the inactive doctor and assign
        // them to an active doctor.
        std::vector<gaia::hospital::patient_t> patient_list;
        patient_list.push_back(patient);

        // Iterate over each direct access patient object
        // that we stored in the patient list.  Because we are using
        // the direct access patient class directly, we need to
        // use the method name for lookup (i.e. 'dac_patient.name()' instead
        // of just 'patient.name').
        for (auto dac_patient : patient_list)
        {
            doctor.disconnect(dac_patient);

            found_doctor:
            if(/active_doctor:doctor.is_active)
            {
                active_doctor.connect(dac_patient);
                gaia_log::app().info("'{}' has been reassigned from '{}' to '{}'.",
                    dac_patient.name(), doctor.name, active_doctor.name);
            }
        }
    }
} // ruleset interop

ruleset arrays
{

} // rulset arrays
