////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////
#include "gaia/logger.hpp"

// Tip:  if you are using VS-code, you can install the Gaia Platform Intellisense extension to get
// syntax highlighting and intellisense for Gaia DDL and Ruleset files.
ruleset basics
{
    // Fired by: run_insert_rule.
    //
    // This rule is fired when a doctor is inserted into the database.
    // Every rule acts on exactly one table change.  The row of the table
    // that changed is passed to the rule.  This row is known as the anchor row.
    // In this rule, we are printing the 'name' column from the 'doctor' table.
    // In fact, we are printing the 'name' of the 'doctor' who was inserted.
    on_insert(doctor)
    {
        gaia_log::app().info("{}:{}: doctor '{}' was inserted.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule is fired when any column of the patient is updated.
    // Since the anchor row in this rule is the 'patient' table, the
    // 'name' refers to the patient's name.
    on_update(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: none.
    //
    // This rule shows that Gaia can respond to changes at the column level.
    // Since the patient's name was not changed, this rule is never fired.
    on_update(patient.name)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'name' field was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule will fire since we changed the 'is_active' column of the patient.
    // This rule also shows that you can fire multiple rules off a single database change.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule shows a shortcut syntax for firing a rule
    // based on a single field change using the '@<column>' syntax.  This rule is
    // the same as the previous rule.
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, patient.name, @patient.is_active);
    }

    // Fired by: run_update_rule.
    //
    // This rule will fire since we changed the 'is_active' column of the patient. Note that
    // the rule will fire if either the 'is_active' or the 'name' column of the patient
    // is changed.  Gaia currently does not support firing a rule only if all the columns
    // listed in the 'on_update' directive are changed.
    on_update(patient.is_active, patient.name)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status or 'name' was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }    

    // Fired by: run_update_rule, run_insert_rule.
    //
    // The 'on_change' keyword will cause the rule to fire if a new row is inserted
    // to the table or any column is updated in a table.
    on_change(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was either inserted or updated'.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }
}

ruleset forward_chaining
{
    // Fired by: run_insert_rule
    //
    // This rule will update the 'is_active' field of the the patient and set it to true.
    // Updating the patient will then cause the next rule to fire.
    on_insert(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was inserted.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
        is_active = true;
    }

    // Fired by: previous rule which changes the 'is_active' field to true.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

    }
}

// By default, all rules run in parallel.  The 'serial_group' attribute ensures 
// that no rules in this ruleset can run concurrently with each other. Because
// this sample logs mulitple rows from each rule, we want to serialize serialize
// the rules so that they don't interleave their output for the tutorial.
ruleset navigation : serial_group()
{
    // Fired by: run_navigate_one_to_one
    //
    // This rule shows navigating objects related to the patient.  Because 
    // the anchor row of this rule is the patient and relationships exist both
    // to a patient's doctor and a patient's address, we can access the data from
    // these related objects.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Since Gaia understands how your data is connected, you can directly
        // reference related information.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, address.street, address.city);
    }

    // Fired by: run_navigate_one_to_one
    //
    // This rule is the same as above but shows the '->' operator to
    // explicitly navigate tables.  This rule is semantically equivalent
    // to the above rule.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Since Gaia understands how your data is connected, you can directly
        // reference related information.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, patient->doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, patient->address.street, patient->address.city);
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule shows listing all the patients for whom
    // this doctor cares.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // List all the patients of this doctor.  Since the schema for this application
        // specifies that a doctor may have many patients, Gaia will actually loop
        // over all the patients belonging to this doctor.  In other words, this statement
        // is executed for every patient related to the 'doctor' anchor row.
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule lists all the patients for whom this doctor cares
    // using a more explicit syntax than the above rule. The rule
    // is semantically equivalent to the previous rule.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // You could also iterate over all of the doctor's patients
        // using a declarative 'for'
        for (patient)
        {
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, doctor.name);
        }
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule lists all of the patients stored in the database.  By using
    // the '/' modifier on the table, we can access all records in the database and
    // not just the ones directly related to the 'doctor' anchor row.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // If you wanted to list all patients (not just those related to the doctor)
        // then use the '/' modifier.
        for (/patient)
        {
            // Note that if we had just displayed 'doctor.name', then
            // it would have been the anchor row's doctor and not the doctor
            // related to this patient.  In this case, we specifically want
            // the patient's doctor so use the '->' operator to traverse
            // the relationship.
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, patient->doctor.name);
        }
    }
}

ruleset connections
{

}

ruleset interop
{
}

ruleset tagging
{
}
