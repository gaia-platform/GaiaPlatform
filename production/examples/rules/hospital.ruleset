////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////
#include "gaia/logger.hpp"

// Tip:  if you are using VS-code, you can install the Gaia Platform Intellisense extension to get
// syntax highlighting and intellisense for Gaia DDL and Ruleset files.
ruleset basics
{
    // Fired by: run_insert_rule.
    //
    // This rule is fired when a doctor is inserted into the database.
    on_insert(doctor)
    {
        gaia_log::app().info("{}:{}: doctor '{}' was inserted.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule is fired when any column of the patient is updated
    on_update(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: none.
    //
    // This rule shows that Gaia can respond to changes at the column level.
    // Since the patient's name was not changed, this rule is never fired.
    on_update(patient.name)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'name' field was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule will fire since we changed the 'is_active' column of the patient.
    // This rule also shows that you can fire multiple rules off a single database change.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }

    // Fired by: run_update_rule.
    //
    // This rule shows a shortcut syntax for firing a rule
    // based on a single field change using the '@<column>' syntax.  This rule is
    // the same as the previous rule.
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, patient.name, @patient.is_active);
    }

    // Fired by: run_update_rule.
    //
    // This rule will fire since we changed the 'is_active' column of the patient. Note that
    // the rule will fire if either the 'is_active' or the 'name' column of the patient
    // is changed.  Gaia currently does not support firing a rule only if all the columns
    // listed in the 'on_update' directive are changed.
    on_update(patient.is_active, patient.name)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status or 'name' was updated.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }    

    // Fired by: run_update_rule, run_insert_rule.
    //
    // The 'on_change' keyword will cause the rule to fire if a new row is inserted
    // to the table or any column is updated in a table.
    on_change(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was either inserted or updated'.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
    }
}

ruleset forward_chaining
{
    // Fired by: run_insert_rule
    //
    // This rule will update the 'is_active' field of the the patient and set it to true.
    // Updating the patient will then cause the next rule to fire.
    on_insert(patient)
    {
        gaia_log::app().info("{}:{}: patient '{}' was inserted.", 
            rule_context.ruleset_name, rule_context.rule_name, name);
        is_active = true;
    }

    // Fired by: previous rule which changes the 'is_active' field to true.
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

    }
}


ruleset navigation
{
    // Fired by: run_navigate_one_to_one
    //
    // This rule shows navigating related records to the patient.  Both of the
    // patient's doctor and address is visible in this rule
    on_update(patient.is_active)
    {
        gaia_log::app().info("{}:{}: patient '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // Since Gaia understands how your data is connected, you can directly
        // reference related information.

        // Who is this patient's doctor?
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);

        // Where does this patient live?
        gaia_log::app().info("'{}' lives on '{}' in '{}'.",
            patient.name, address.street, address.city);
    }

    // Fired by: run_navigate_one_to_many
    //
    // This rule shows listing all the patients for whom
    // this doctor cares.
    on_update(doctor.is_active)
    {
        gaia_log::app().info("{}:{}: doctor '{}' 'is_active' status was updated to '{}'.", 
            rule_context.ruleset_name, rule_context.rule_name, name, is_active);

        // List all the patients of this doctor.
        gaia_log::app().info("'{}' is a patient of '{}'.",
            patient.name, doctor.name);

        // You could also do this explicitly
        for (patient)
        {
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, doctor.name);
        }

        // If you wanted to list all patients (not just those related to the doctor)
        // then use the '/' modifier.
        for (/patient)
        {
            // Note that if we had just displayed "doctor.name", then
            // it would have been the anchor row's doctor and not the doctor
            // related to this patient.  In this case, we specifically want
            // the patient's doctor so use the '->' operator to traverse
            // the relationship.
            gaia_log::app().info("'{}' is a patient of '{}'.",
                patient.name, patient->doctor.name);
        }

        // TODO (dax): talk about anchor rows.

        // TODO (dax): series of stories about connecting doctors to patients and 
        // patients to doctors.  Perhaps even use VLR?
    }
}

ruleset connections
{

}

ruleset interop
{
}

ruleset tagging
{
}
