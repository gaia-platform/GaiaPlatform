/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include <gaia/db/db.hpp>
#include <gaia/logger.hpp>
#include <gaia/system.hpp>

#include "gaia_hospital.h"

using namespace gaia::hospital;
using namespace gaia::common;

///
/// Direct Access API examples.
///
/// A Direct Access Class (DAC) is a C++ class that map a Gaia database table.
/// DACs are generated by the gaiac and are used to perform CRUD operations
/// on the Gaia database.
///

/**
 * Creates a record using the insert() method. insert() returns a gaia_id_t
 * that can later be used to lookup the record.
 */
void create_record_insert()
{
    [[maybe_unused]] gaia_id_t id = patient_t::insert_row("Jane", 183, true);
}

/**
 *  Creates a record using the writer class (patient_writer in this case).
 *  A writer class does not require to set the value for all the fields.
 *  The unspecified fields can will be assigned a default value.
 *  The writer returns a gaia_id_t.
 */
void create_record_writer()
{
    patient_writer patient_w;
    patient_w.name = "Emma";
    patient_w.is_active = true;
    [[maybe_unused]] gaia_id_t id = patient_w.insert_row();
}

/**
 * Lookup an patient_t record using the static get(gaia_id_t) method.
 */
void lookup_record_get()
{
    gaia_id_t id = patient_t::insert_row("John", 175, false);

    patient_t john = patient_t::get(id);
    gaia_log::app().info("Patient name: {}", john.name());
}

/**
 * DACs override the bool() operator that evaluate to true when the
 * instance is in a valid state and false otherwise.
 */
void lookup_invalid_record()
{
    patient_t john = patient_t::get(gaia::common::c_invalid_gaia_id);

    if (john)
    {
        throw std::runtime_error("The patient is expected to evaluate to false.");
    }
    else
    {
        gaia_log::app().info("Cannot find patient with id: {}", gaia::common::c_invalid_gaia_id);
    }
}

/**
 * If you interact with a DAC instance that points to an invalid database record
 * you will get a invalid_object_id exception.
 */
void access_invalid_record()
{
    patient_t john = patient_t::get(gaia::common::c_invalid_gaia_id);

    try
    {
        gaia_log::app().info("Patient name: {}", john.name());
    }
    catch (gaia::db::invalid_object_id& ex)
    {
        gaia_log::app().error("As expected, attempting to access an invalid object is raising the following exception: '{}'.", ex.what());
    }
}

/**
 * Each DAC class exposes a static list() method that allow to iterate
 * through all the table records.
 */
void list_all_patients()
{
    for (auto& patient : patient_t::list())
    {
        gaia_log::app().info(
            "Patient name:{}, height:{}", patient.name(), patient.height());
    }
}

/**
 * Records can be deleted using the delete_row() method.
 */
void delete_single_record()
{
    doctor_t dr_house = doctor_t::get(doctor_t::insert_row("Dr. House"));

    dr_house.delete_row();

    if (dr_house)
    {
        throw std::runtime_error("The doctor is expected to be invalid after deletion.");
    }
    else
    {
        gaia_log::app().info("The record has been deleted");
    }
}

/**
 * Deleting all the records is not as simple as listing all the records with list()
 * and calling delete() on each of them. This approach will not work as you
 * modify the container while iterating it.
 */
void delete_all_records()
{
    doctor_t dr_house = doctor_t::get(doctor_t::insert_row("Dr. House"));
    doctor_t dr_dorian = doctor_t::get(doctor_t::insert_row("Dr. Dorian"));
    doctor_t dr_reid = doctor_t::get(doctor_t::insert_row("Dr. Reid"));

    // This approach doesn't work, it will remove only one element.
    // for (auto& doctor : doctor_t::list())
    // {
    //     doctor.delete_row();
    // }

    // This is a possible working approach:
    for (auto& doctor = *doctor_t::list().begin();
         doctor;
         doctor = *doctor_t::list().begin())
    {
        doctor.delete_row();
    }

    gaia_log::app().info("Doctors count: {}", doctor_t::list().size());
}

/**
 * Shows another way of deleting all the records using an iterator.
 */
void delete_all_records_iter()
{
    doctor_t dr_house = doctor_t::get(doctor_t::insert_row("Dr. House"));
    doctor_t dr_dorian = doctor_t::get(doctor_t::insert_row("Dr. Dorian"));
    doctor_t dr_reid = doctor_t::get(doctor_t::insert_row("Dr. Reid"));

    for (auto doctor_it = doctor_t::list().begin();
         doctor_it != doctor_t::list().end();)
    {
        auto next_doctor_it = doctor_it++;
        (*next_doctor_it).delete_row();
    }

    gaia_log::app().info("Doctors count: {}", doctor_t::list().size());
}

/**
 * Creates a one-to-many relationships between doctor and patients by
 * adding three patients to a single doctor.
 *
 * @return A gaia_id used by the following examples.
 */
gaia_id_t create_one_to_many_relationship()
{
    doctor_t dr_house = doctor_t::get(doctor_t::insert_row("Dr. House"));

    patient_t jane = patient_t::get(patient_t::insert_row("Jane", 183, true));
    patient_t jack = patient_t::get(patient_t::insert_row("Jack", 176, false));
    gaia_id_t john_id = patient_t::insert_row("John", 175, false);

    // Type safe insert (accepts instances of patient_t).
    dr_house.patients().insert(jane);
    dr_house.patients().insert(jack);

    // Type unsafe insert (accept gaia_id_t).
    dr_house.patients().insert(john_id);

    return dr_house.gaia_id();
}

/**
 * Iterate over all the patients of the given doctor and, from each patient,
 * traverse the backlink to doctor.
 *
 * @param doctor_id Id of previously created doctor with patients.
 */
void traverse_one_to_many_relationship(gaia_id_t doctor_id)
{
    doctor_t doctor = doctor_t::get(doctor_id);

    // doctor.patients() returns a container of patient_t.
    // The container is compatible with CPP STL containers.
    for (auto& patient : doctor.patients())
    {
        gaia_log::app().info("Patient name: {}", patient.name());

        // Traverse the backlink from patient to doctor.
        gaia_log::app().info("Patient's doctor: {}", patient.doctor().name());
    }
}

/**
 * If you try to delete a database object that is referenced by another
 * object you get a object_still_referenced exception because this violates
 * referential integrity.
 *
 * @param doctor_id Id of previously created doctor with patients.
 */
void delete_one_to_many_relationship_re(gaia_id_t doctor_id)
{
    doctor_t doctor = doctor_t::get(doctor_id);

    // Pick one of the doctor's patients.
    patient_t patient = *(doctor.patients().begin());

    try
    {
        doctor.delete_row();
    }
    catch (const gaia::db::object_still_referenced& ex)
    {
        gaia_log::app().error("s expected, deleting the doctor record is raising the following exception '{}'.", ex.what());
    }

    try
    {
        patient.delete_row();
    }
    catch (const gaia::db::object_still_referenced& ex)
    {
        gaia_log::app().error("As expected, deleting the patient record is raising the following exception '{}'.", ex.what());
    }
}

/**
 * The correct way of deleting object referenced by other objects is to disconnect
 * them first, and then delete them.
 *
 * @param doctor_id Id of previously created doctor with patients.
 */
void delete_one_to_many_relationship(gaia_id_t doctor_id)
{
    doctor_t doctor = doctor_t::get(doctor_id);

    // Pick one of the doctor's patients.
    patient_t patient = *(doctor.patients().begin());

    // You can unlink a single element (there are still 2 connected).
    doctor.patients().remove(patient);

    // You can now delete the patient.
    patient.delete_row();

    // Unlink all the remaining patients.
    doctor.patients().clear();

    // You can now delete the doctor.
    doctor.delete_row();
}

/**
 * Gaia relationships container expose the erase() method which behaves like
 * the STL erase method. Removes the element at the given position and return
 * an iterator to the following value.
 */
void delete_one_to_many_relationship_erase()
{
    gaia_id_t doctor_id = create_one_to_many_relationship();

    doctor_t doctor = doctor_t::get(doctor_id);
    auto doctor_patients = doctor.patients();

    for (auto patient_it = doctor_patients.begin(); patient_it != doctor_patients.end();)
    {
        patient_t patient = *patient_it;
        patient_it = doctor_patients.erase(patient_it);
        patient.delete_row();
    }

    doctor.delete_row();
}

/**
 * Creates a one-to-one relationship between a patient and an address
 * by setting the patient's address.
 *
 * @return A gaia_id used by the following examples.
 */
gaia_id_t create_one_to_one_relationship()
{
    patient_t jane = patient_t::get(patient_t::insert_row("Jane", 183, true));
    address_t amsterdam = address_t::get(address_t::insert_row("Tuinstraat", "Amsterdam"));

    // The address() method returns an address_ref_t which is a subclass of
    // address_t that expose connect()/disconnect() methods to set/unset
    // the reference.
    jane.address().connect(amsterdam);

    return jane.gaia_id();
}

/**
 * Access the address from the patient, and access the patient from the address
 * using the backlink.
 *
 * @param patient_id Id of previously created patient with an address.
 */
void traverse_one_to_one_relationship(gaia_id_t patient_id)
{
    patient_t patient = patient_t::get(patient_id);
    // Actually returns address_ref_t which being a subclass of
    // address_t can be assigned to address_t.
    address_t address = patient.address(); // NOLINT(cppcoreguidelines-slicing)

    gaia_log::app().info("City {}", address.city());

    // Note: address.patient() returns a patient_t and not a patient_ref_t.
    // This means you can set/unset the reference only from the patient side:
    //
    // You can do: patient.address().connect(...)
    // You can't do: address.patient().connect(...)
    //
    // This depends on the order things appear in the DDL. patient appears
    // first hence it exposes the ability to set/unset the reference to address.
    gaia_log::app().info("Patient {}", address.patient().name());
}

/**
 * Likewise in 1:n relationships, if you try to delete a a database object that
 * is referenced by another object (in a 1:1 relationship) you will get
 * object_still_referenced exception.
 *
 * @param patient_id Id of previously created patient with an address.
 */
void delete_one_to_one_relationship_re(gaia_id_t patient_id)
{
    patient_t patient = patient_t::get(patient_id);
    address_ref_t address = patient.address();

    try
    {
        patient.delete_row();
    }
    catch (const gaia::db::object_still_referenced& ex)
    {
        gaia_log::app().info("As expected, deleting the patient record is raising the following exception '{}'.", ex.what());
    }

    try
    {
        address.delete_row();
    }
    catch (const gaia::db::object_still_referenced& ex)
    {
        gaia_log::app().info("As expected, deleting the address record is raising the following exception '{}'.", ex.what());
    }
}

/**
 * The correct way to delete objects in 1:1 relationships is to first disconnect them.
 *
 * @param patient_id Id of previously created patient with an address.
 */
void delete_one_to_one_relationship(gaia_id_t patient_id)
{
    patient_t patient = patient_t::get(patient_id);
    address_t address = patient.address(); // NOLINT(cppcoreguidelines-slicing)

    patient.address().disconnect();

    patient.delete_row();
    address.delete_row();
}

/**
 * Helper method to create data used in filter examples.
 */
void create_filter_data()
{
    doctor_t dr_dorian = doctor_t::get(doctor_t::insert_row("Dr. Dorian"));
    doctor_t dr_house = doctor_t::get(doctor_t::insert_row("Dr. House"));

    patient_t jane = patient_t::get(patient_t::insert_row("Jane", 183, true));
    patient_t jack = patient_t::get(patient_t::insert_row("Jack", 176, false));
    patient_t john = patient_t::get(patient_t::insert_row("John", 165, false));

    dr_dorian.patients().insert(jane);
    dr_house.patients().insert(jack);
    dr_house.patients().insert(john);

    address_t seattle = address_t::get(address_t::insert_row("4th Ave", "Seattle"));
    address_t bellevue = address_t::get(address_t::insert_row("8th Street", "Bellevue"));
    address_t amsterdam = address_t::get(address_t::insert_row("Tuinstraat", "Amsterdam"));

    jane.address().connect(seattle);
    jack.address().connect(bellevue);
    john.address().connect(amsterdam);
}

/**
 * The Direct Access API allow filtering data using predicates expressed as:
 *
 *   std::function<bool (const T_class&)>
 *
 * where T_class is the type of the container the filter is applied to.
 */
void filter_lambda()
{
    // Find all the doctors whose name is "Dr. House".
    // using a lambda to express a predicate.
    // The result is a gaia container.
    auto doctors = doctor_t::list().where(
        [](const doctor_t& doctor) { return strcmp(doctor.name(), "Dr. House") == 0; });

    if (doctors.begin() == doctors.end())
    {
        gaia_log::app().warn("No doctors found!");
        return;
    }

    // Assuming there is only one result.
    doctor_t dr_house = *doctors.begin();

    auto patients = dr_house.patients().where(
        [](const patient_t& patient) { return strcmp(patient.name(), "Jack") == 0; });

    if (patients.begin() == patients.end())
    {
        gaia_log::app().warn("No patients found!");
        return;
    }

    patient_t jack = *patients.begin();

    gaia_log::app().info("{} has patient {}", dr_house.name(), jack.name());
}

/**
 * C++ lambda syntax can be quite verbose, for this reason DACs expose
 * an API to create predicates for the all the class fields.
 *
 * This API is under the T_class_expr namespace (eg. doctor_expr for
 * doctor_t class).
 *
 * The API provide the == and != for string (const char* and std::string).
 */
void filter_gaia_predicates_strings()
{
    // The doctor_expr namespace is generated along with the doctor_t class.
    auto doctors = doctor_t::list().where(doctor_expr::name == "Dr. House");

    if (doctors.begin() == doctors.end())
    {
        gaia_log::app().warn("No doctors found!");
        return;
    }

    // Assuming there is only one result.
    doctor_t dr_house = *doctors.begin();

    auto patients = dr_house.patients().where(patient_expr::name != "John");

    for (patient_t& patient : patients)
    {
        gaia_log::app().info("{} has patient {}", dr_house.name(), patient.name());
    }
}

/**
 * For numerical values you can use: >, >=, ==, !=, <= and <.
 */
void filter_gaia_predicates_numbers()
{
    auto active_patients = patient_t::list().where(patient_expr::is_active == true);
    gaia_log::app().info("There are {} active patients", active_patients.size());

    auto higher_than_160 = patient_t::list().where(patient_expr::height >= 160);
    gaia_log::app().info("There are {} patients higher than 160", higher_than_160.size());
}

/**
 * For containers you can use contains(), empty(), count().
 */
void filter_gaia_predicates_containers()
{
    // Contains with expression.
    auto jacks_doctor_container = doctor_t::list().where(
        doctor_expr::patients.contains(
            patient_expr::name == "Jack"));

    auto jacks_doctor = *jacks_doctor_container.begin();
    gaia_log::app().info("Jack's doctor is {}", jacks_doctor.name());

    // Contains with constant.
    auto jane = *(patient_t::list().where(patient_expr::name == "Jane").begin());

    auto janes_doctor_container = doctor_t::list().where(
        doctor_expr::patients.contains(jane));

    auto janes_doctor = *janes_doctor_container.begin();
    gaia_log::app().info("Jane's doctor is {}", janes_doctor.name());

    auto doctors_with_no_patients = doctor_t::list().where(doctor_expr::patients.empty());

    if (doctors_with_no_patients.begin() == doctors_with_no_patients.end())
    {
        gaia_log::app().info("All the doctors have at least one patient");
    }

    auto doctors_with_patients = doctor_t::list().where(
        doctor_expr::patients.count() >= 1);

    for (doctor_t& doctor : doctors_with_patients)
    {
        gaia_log::app().info("{} has at least one patient", doctor.name());
    }
}

/**
 * Clean the database.
 */
void clean_db()
{

    for (auto& doctor = *doctor_t::list().begin();
         doctor; doctor = *doctor_t::list().begin())
    {
        doctor.patients().clear();
        doctor.delete_row();
    }

    for (auto& patient = *patient_t::list().begin();
         patient; patient = *patient_t::list().begin())
    {
        patient.address().disconnect();
        patient.delete_row();
    }

    for (auto& address = *address_t::list().begin();
         address; address = *address_t::list().begin())
    {
        address.delete_row();
    }
}

int main()
{
    gaia::system::initialize();

    // The false params prevent to begin a new transaction
    // when the current one is committed.
    gaia::direct_access::auto_transaction_t txn{false};

    clean_db();

    create_record_insert();
    create_record_writer();
    lookup_record_get();
    lookup_invalid_record();
    access_invalid_record();
    list_all_patients();
    delete_single_record();
    delete_all_records();
    delete_all_records_iter();
    gaia_id_t doctor_id = create_one_to_many_relationship();
    traverse_one_to_many_relationship(doctor_id);
    delete_one_to_many_relationship_re(doctor_id);
    delete_one_to_many_relationship(doctor_id);
    delete_one_to_many_relationship_erase();
    gaia_id_t patient_id = create_one_to_one_relationship();
    traverse_one_to_one_relationship(patient_id);
    delete_one_to_one_relationship_re(patient_id);
    delete_one_to_one_relationship(patient_id);
    clean_db();
    create_filter_data();
    filter_lambda();
    filter_gaia_predicates_strings();
    filter_gaia_predicates_numbers();
    filter_gaia_predicates_containers();

    txn.commit();
    gaia::system::shutdown();
}
