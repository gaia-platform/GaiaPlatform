/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

// -*- mode: java -*- // Java mode works for emacs to edit flatbuffers.

// Identifiers are stored outside the payload.
// Foreign keys are represented as int64 because flatbuffers does not yet support GUIDs.
// If data size is not a concern, all integers can be made 64bit.

namespace gaia;

// This tracks high level information about types.
// Scalar types have hard-coded entries.
table types
{
    name: string;

    // For indicating struct or table in flatbuffers.
    //
    // Note: this catalog representation does not support union and enum.
    // Support for them can be added post-Q2, if needed.
    //
    // 0 = scalar, 1 = table, 2 = struct, 3 = enum, 4 = union
    //
    // Builtin basic types would be marked as scalar.
    category: ubyte;
}

// Any complex type is defined as a set of fields,
// with fields possibly being of complex type themselves
// (although this may not be used currently).
table fields
{
    name: string;

    // The type of the field.
    type_id: int64;

    // The type that owns this field.
    //
    // This enables us to collect fields under a type.
    // It also enables us to describe complex, hierarchical types.
    owning_type_id: int64;

    // Indicates whether this is an array type and if yes, what kind of size it has.
    //
    // 0 = variable size, 1 = not array, > 1 = fixed size.
    //
    // Do we need to support arrays larger than 4B?
    repeated_count: uint;

    // Monotonically assigned identifier, to maintain the order of fields in flatbuffers schema.
    //
    // Do we need to support more than 65k fields?
    ordering_id: ushort;

    // For deprecating fields.
    deprecated: bool;

    // Indicates whether the field accepts null values.
    // Will require some flatbuffers modification to support null values.
    // Mapping null to missing does not work for structs
    // and may not be possible for tables either
    // because we will probably avoid missing values to allow updating fields in-place.
    nullable: bool;
}

// A table will have its own identifier as well as a specific type.
// Several tables can share the same type.
table tables
{
    name: string;

    // Indicates the type of its payload, which gives us all the fields.
    type_id: int64;
}
