/////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
// All rights reserved.
/////////////////////////////////////////////

#include <cstring>
#include <cstdint>
#include <list>
#include <map>
#include "NullableString.h"
#include "airport_generated.h" // include both flatbuffer types and object API for testing 
#include "GaiaObj.h"
#include "AirportTypes.h"
#include "PerfTimer.h"

using namespace std;
using namespace gaia_se;
using namespace AirportDemo;

template <typename T>
gaia_ptr<T> skip_rows(gaia_ptr<T>& ptr, uint32_t offset)
{
    for (uint32_t i = 0; i < offset && nullptr != ptr; i++) {
        ++ptr;
    }
    return ptr;
}

// **************************************************************************
// Access without any syntactic sugar.  This is zero-copy and immutable.
// Two areas to add syntax:  Flatbuffers and Gaia constructs
// **************************************************************************
void traverse_list_raw(uint32_t offset, uint32_t num)
{
    begin_transaction();
    {
        uint32_t i;
        //
        // Gaia API here 
        //
        auto node_ptr = gaia_ptr<gaia_se_node>::find_first(AirportDemo::kAirlinesType);

        // skip rows to offset
        for (i = 0; i < offset && node_ptr; i++, ++node_ptr);

        // dump the number of rows requested
        for (i = 0; i < num && nullptr != node_ptr; i++) {
            auto row = flatbuffers::GetRoot<airlines>(node_ptr->payload);
            printf("%d, %s, %s\n", 
                row->al_id(), 
                row->name()->c_str(), 
                row->active()->c_str()
            );
            node_ptr = node_ptr.find_next();
        }
    }
    commit_transaction();
}

// **************************************************************************
// Access as flatbuffer "objects", note that this is a copy
// **************************************************************************
void traverse_list_obj(uint32_t offset, uint32_t num)
{
    // skip offset rows
    uint32_t i;
    
    begin_transaction();
    {
        auto node_ptr = gaia_ptr<gaia_se_node>::find_first(AirportDemo::kAirlinesType);
        for (i = 0; i < offset && node_ptr; i++, ++node_ptr);

        // dump the number of rows requested
        for (i = 0; i < num && nullptr != node_ptr; i++) {
            auto row = flatbuffers::GetRoot<airlines>(node_ptr->payload);
            // WARNING:  we just copied into airlinesT
            // The object API is generated by specifing --gen-object-api
            airlinesT * obj = row->UnPack();
            // note we can direclty access the members without going through
            // a function call
            printf("%d, %s, %s\n", 
                obj->al_id, 
                obj->name.c_str(), 
                obj->active.c_str()
            );
            node_ptr = node_ptr.find_next();
        }
    }
    commit_transaction();
}


// **************************************************************************
// shows augmenting the flatbuffer object class (implies copy) with
// next and previous pointers
// **************************************************************************
struct AirlineObj : public airlinesT {
    AirlineObj * next = nullptr;
    AirlineObj * prev = nullptr;

    AirlineObj(){}

    // **************************************************************************
    // imagine that the following are generated and part of airlinesT (gaia_airlinesT)
    // **************************************************************************
    AirlineObj(gaia_id_t id)
    {
        this->Gaia_id = id;
        refresh();
    }

    void update()
    {
        flatbuffers::FlatBufferBuilder b(128);
        auto a_new = airlines::Pack(b, this);
        b.Finish(a_new);
        begin_transaction();
        auto node_ptr = gaia_se_node::open(this->Gaia_id);
        node_ptr.update_payload(b.GetSize(), b.GetBufferPointer());
        commit_transaction();
    }

    void refresh()
    {
        begin_transaction();
        auto node_ptr = gaia_se_node::open(this->Gaia_id);
        auto row = flatbuffers::GetRoot<airlines>(node_ptr->payload);
        row->UnPackTo(this);
        commit_transaction();
    }

    void insert()
    {
        flatbuffers::FlatBufferBuilder b(128);
        auto a_new = airlines::Pack(b, this);
        b.Finish(a_new);
        begin_transaction();
        gaia_se_node::create(this->Gaia_id, AirportDemo::kAirlinesType, b.GetSize(), b.GetBufferPointer());        
        commit_transaction();
    }

    void remove()
    {
        begin_transaction();
        auto node_ptr = gaia_se_node::open(this->Gaia_id);
        gaia_ptr<gaia_se_node>::remove(node_ptr);
        commit_transaction();
    }
};

struct Airport;

// this isn't currently safe as GetRoot<T> just does a reinterpret_cast<T> on the
// flatbuffer layout.  There is no guarantee (standard wise) of memory layout
// still investigating
//struct Airline : public airlines
struct Airline
{
  Airline(const airlines * al_fb) : _fb(al_fb) {}
  int64_t Gaia_id() const {
    return _fb->Gaia_id();
  }
  int32_t al_id() const {
    return _fb->al_id();
  }
  const flatbuffers::String *name() const {
    return _fb->name();
  }
  const flatbuffers::String *alias() const {
    return _fb->alias();
  }
  const flatbuffers::String *iata() const {
    return _fb->iata();          
  }
  const flatbuffers::String *icao() const {
    return _fb->icao();      
  }
  const flatbuffers::String *callsign() const {
    return _fb->callsign();
  }
  const flatbuffers::String *country() const {
    return _fb->country();
  }
  const flatbuffers::String *active() const {
    return _fb->active();      
  }    

  Airline * prev = nullptr;
  Airline * next = nullptr;

private:
  const airlines * _fb;    
};


// in gaia, routes are encoded as edges
// but as routes connect airports via an airline,
// it is most intuitive to treat these as first class objects

//struct Route : public routes
struct Route
{
    Route(const routes * r_fb) : _fb(r_fb) {}

    int64_t Gaia_id() const {
        return _fb->Gaia_id();
    }
    int64_t Gaia_Al_id() const {
        return _fb->Gaia_Al_id();      
    }
    int64_t Gaia_Src_id() const {
        return _fb->Gaia_Src_id();      
    }
    int64_t Gaia_Dst_id() const {
        return _fb->Gaia_Dst_id();      
    }
    const flatbuffers::String *airline() const {
        return _fb->airline();      
    }
    int32_t al_id() const {
        return _fb->al_id();      
    }
    const flatbuffers::String *src_ap() const {
        return _fb->src_ap();      
    }
    int32_t src_ap_id() const {
        return _fb->src_ap_id();      
    }
    const flatbuffers::String *dst_ap() const {
        return _fb->dst_ap();      
    }
    int32_t dst_ap_id() const {
        return _fb->dst_ap_id();      
    }
    const flatbuffers::String *codeshare() const {
        return _fb->codeshare();      
    }
    int32_t stops() const {
        return _fb->stops();
    }
    const flatbuffers::String *equipment() const {
        return _fb->equipment();      
    }    

    Route * prev = nullptr;
    Route * next = nullptr;

    Airline * al = nullptr;
    Airport * src_airport = nullptr;
    Airport * dst_airport = nullptr;

private:
      const routes * _fb;    
};

// we can just define our own GetRoot here with our type
//struct Airport : airports
struct Airport
{

  Airport(const airports * ap_fb) : _fb(ap_fb) {}

  int64_t Gaia_id() const {
      return _fb->Gaia_id();
  }
  int32_t ap_id() const {
      return _fb->ap_id();
  }
  const flatbuffers::String *name() const {
      return _fb->name();
  }
  const flatbuffers::String *city() const {
      return _fb->city();
  }
  const flatbuffers::String *country() const {
    return _fb->country();
  }
  const flatbuffers::String *iata() const {
    return _fb->iata();
  }
  const flatbuffers::String *icao() const {
      return _fb->icao();
  }
  double latitude() const {
      return _fb->latitude();
  }
  double longitude() const {
      return _fb->longitude();
  }
  int32_t altitude() const {
      return _fb->altitude();
  }
  float timezone() const {
      return _fb->timezone();
  }
  const flatbuffers::String *dst() const {
      return _fb->dst();
  }
  const flatbuffers::String *tztext() const {
      return _fb->tztext();
  }
  const flatbuffers::String *type() const {
      return _fb->type();
  }
  const flatbuffers::String *source() const {
      return _fb->source();
  }    

    Airport * prev = nullptr;
    Airport * next = nullptr;

    // linked list of routes out of this airport
    list<Route *> routes;

private:
    const airports * _fb;    
};

// **************************************************************************
// shows augmenting the flatbuffer class (zero copy) with
// next and previous pointers as well as more convenient update semantics
// Note that we could also inherit from the "airlines" flatbuffer type but then
// we also would need to generate a new GetRoot function that knew about this
// Airline type.  There is also an issue that if you inherit we'd need to remove
// the private default constructor/copy constructor restriction on the underlying
// flatbuffer::Table
// Note that Airline_Writable is different than the mutable object that 
// flatbuffers create because// a write here creates a copy instead of changing the undelrying flatbuffer.
// **************************************************************************
struct Airline_Writeable  /*: public airlines*/
{
    Airline_Writeable * prev = nullptr;
    Airline_Writeable * next = nullptr;

    // if we construct without any thing then we are
    // saying we need a copy

    Airline_Writeable() {
        _copy = new airlinesT();
    }

    Airline_Writeable(const airlines * fb) {
        _fb = fb;
    }

    // pass through for read access
    int64_t Gaia_id() const {
        if (_copy) {
            return _copy->Gaia_id;
        }
        return _fb->Gaia_id();
    }

    int32_t al_id() const {
        if (_copy) {
            return _copy->al_id;
        }
        return _fb->al_id();
    }

    // this is subtle:  the airlines struct surfaces strings as flatbuffers::String
    // however we always convert to std::string or c_string to use this.  If null,
    // then we return an empty std::string.  This preserves the semantics of Pack/Unpack
    // from the object.
    std::string name() const {
        if (_copy) {
            return _copy->name;
        }
        return _fb->name() ? _fb->name()->str() : std::string();
    }

    std::string alias() const {
        if (_copy) {
            return _copy->alias;
        }
        return _fb->alias() ? _fb->alias()->str() : std::string();
    }

    std::string iata() const {
        if (_copy) {
            return _copy->iata;
        }
        return _fb->iata() ? _fb->iata()->str() : std::string();
    }

    std::string icao() const {
        if (_copy) {
            return _copy->icao;
        }
        return _fb->icao() ? _fb->icao()->str() : std::string();
    }

    std::string callsign() const {
        if (_copy) {
            return _copy->callsign;
        }
        return _fb->callsign() ? _fb->callsign()->str() : std::string();
    }

    std::string country() const {
        if (_copy) {
            return _copy->country;
        }
        return _fb->country() ? _fb->country()->str() : std::string();
    }

    std::string active() const {
        if (_copy) {
            return _copy->active;
        }
        return _fb->active() ? _fb->active()->str() : std::string();
    }

    void set_Gaia_id(int64_t id) {
        _copy_write()->Gaia_id = id;
    }

    void set_al_id(int32_t id) {
        _copy_write()->al_id = id;
    }

    void set_name(std::string& name) {
        _copy_write()->name = name;
    }

    void set_name(const char * name) {
        _copy_write()->name = name;
    }
    void set_alias(std::string& alias) {
        _copy_write()->alias = alias;
    }

    void set_alias(const char * alias) {
        _copy_write()->alias = alias;
    }

    void set_iata(std::string& iata) {
        _copy_write()->iata = iata;
    }

    void set_iata(const char * iata) {
        _copy_write()->iata = iata;
    }

    void set_icao(std::string& icao) {
        _copy_write()->icao = icao;
    }

    void set_icao(const char * icao) {
        _copy_write()->icao = icao;
    }

    void set_callsign(std::string& callsign) {
        _copy_write()->callsign = callsign;
    }

    void set_callsign(const char * callsign) {
        _copy_write()->callsign = callsign;
    }

    void set_country(std::string& country) {
        _copy_write()->country = country;
    }

    void set_country(const char * country) {
        _copy_write()->country = country;
    }

    void set_active(std::string& active) {
        _copy_write()->active = active;
    }

    void set_active(const char * active) {
        _copy_write()->active = active;
    }

    // interstingly enough, the db functions are very similar to the AirlineObj
    // code above
    void update()
    {
        if (_copy) {
            flatbuffers::FlatBufferBuilder b(128);
            auto a_new = airlines::Pack(b, _copy);
            b.Finish(a_new);
            begin_transaction();
            auto node_ptr = gaia_se_node::open(this->Gaia_id());
            node_ptr.update_payload(b.GetSize(), b.GetBufferPointer());
            commit_transaction();
        }
    }

    // just get rid of our copy
    // note that there would be an error if there were no _fb object
    void refresh()
    {
        if (_copy)
        {
            delete _copy;
            _copy = nullptr;
        }
    }

    void insert()
    {
        if (_copy) {
            flatbuffers::FlatBufferBuilder b(128);
            auto a_new = airlines::Pack(b, _copy);
            b.Finish(a_new);
            begin_transaction();
            gaia_se_node::create(this->Gaia_id(), AirportDemo::kAirlinesType, b.GetSize(), b.GetBufferPointer());        
            commit_transaction();
        }
    }

    void remove()
    {
        begin_transaction();
        auto node_ptr = gaia_se_node::open(this->Gaia_id());
        gaia_ptr<gaia_se_node>::remove(node_ptr);
        commit_transaction();
    }

private:
    // Note that this is not optimal - we could
    // maintain a "dirty" bitmap to track the fields
    // that changed and thus avoid copying the entire object
    airlinesT * _copy_write() {
        if (_copy == nullptr) {
            airlinesT * copy = new airlinesT();
            copy->Gaia_id = Gaia_id();
            copy->al_id = al_id();
            copy->name = name();
            copy->alias = alias();
            copy->iata = iata();
            copy->callsign = callsign();
            copy->country = country();
            copy->active = active();
            _copy = copy;
        }
        return _copy;
    }    

    // mutable object
    airlinesT * _copy = nullptr;
    // read-only flatbuffer object
    const airlines * _fb = nullptr;
};


//
// Explicit API to load, refresh, update, and insert
// Template syntax is verbose
// Pros:  don't put this in user data classes
// Cons:  it's an API
//
namespace gaia_se {
    // I think the fully "generic" template syntax is ugly
    // note Pack/Unpack are copies (i.e., still using object api)
    template <typename T, typename U>
    static void update(T * obj)
    {
        flatbuffers::FlatBufferBuilder b(128);
        auto a_new = U::Pack(b, obj);
        b.Finish(a_new);
        begin_transaction();
        auto node_ptr = gaia_se_node::open(obj->Gaia_id);
        node_ptr.update_payload(b.GetSize(), b.GetBufferPointer());
        commit_transaction();
    }

    // could be generated, assumes that every flatbuffer type must have a Gaia_id

    // could generate overloads:
    // update(AirlineObj *)
    // update(Airport *)
    //
    // versus, more explicit
    // update_airline(AirlineObj *)
    // update_airport(Airport *)
    //
    // or could generate as part of the airlinesT baseclass
    // and then have the user inherit from it
    //
    // my_object.update()
    //
    /*
    template <typename T, typename U>
    static void refresh(T * p)
    {
        begin_transaction();
        auto node_ptr = gaia_se_node::open(p->Gaia_id);
        auto row = flatbuffers::GetRoot<U>(node_ptr->payload);
        row->UnPackTo(p);
        commit_transaction();
    }

    static void insert(AirlineObj * p)
    {
        flatbuffers::FlatBufferBuilder b(128);
        auto a_new = airlines::Pack(b, p);
        b.Finish(a_new);
        begin_transaction();
        gaia_se_node::create(p->Gaia_id, AirportDemo::kAirlinesType, b.GetSize(), b.GetBufferPointer());        
        commit_transaction();
    }
    */

    // we have no idea what kind of data structure the client will want
    // so we need to take some sort of lambda function
    // undone:  still need another template arg so you don't have 'airlines' below,
    // of course.
    template<typename T>
    static void load(gaia_type_t type, function<void (T *)> loader)
    {
        begin_transaction();
        for (auto node_ptr = gaia_ptr<gaia_se_node>::find_first(type);
            node_ptr;
            node_ptr = node_ptr.find_next())
        {
            auto row = flatbuffers::GetRoot<airlines>(node_ptr->payload);
            T * a_new = new T();
            row->UnPackTo(a_new);
            loader(a_new);
        }
        commit_transaction();
    }

    template<typename T, typename U>
    static void load_zero_copy(gaia_type_t type, function<void (const T *)> loader)
    {
        begin_transaction();
        for (auto node_ptr = gaia_ptr<U>::find_first(type);
            node_ptr;
            node_ptr = node_ptr.find_next())
        {
            loader(flatbuffers::GetRoot<T>(node_ptr->payload));
        }
        commit_transaction();
    }

    template<typename T, typename U>
    static void load_zero_copy(gaia_type_t type, function<void (T *)> loader)
    {
        begin_transaction();
        for (auto node_ptr = gaia_ptr<U>::find_first(type);
            node_ptr;
            node_ptr = node_ptr.find_next())
        {
            // note that non-const requires mutuable root function
            loader(flatbuffers::GetMutableRoot<T>(node_ptr->payload));
        }
        commit_transaction();
    }

} //namespace


void traverse_list_native(AirlineObj * head, uint32_t offset, uint32_t num)
{
    AirlineObj * current = head;
    for (uint32_t i = 0; i < offset && nullptr != current; i++)
    {
        current = current->next;
    }

    for (uint32_t i = 0; i < num && nullptr != current; i++)
    {
        printf("%d, %s, %s\n", 
                current->al_id, 
                current->name.c_str(), 
                current->active.c_str()
        );
        current = current->next;
    }
}

void traverse_list_native(Airline_Writeable * head, uint32_t offset, uint32_t num)
{
    Airline_Writeable * current = head;
    for (uint32_t i = 0; i < offset && nullptr != current; i++)
    {
        current = current->next;
    }

    for (uint32_t i = 0; i < num && nullptr != current; i++)
    {
        printf("%d\n", current->al_id());
        printf("%d, %s, %s\n", 
                current->al_id(), 
                current->name().c_str(), 
                current->active().c_str()
        );
        current = current->next;
    }
}

const airports * find_airport(const char * iata)
{
    const airports * ptr = nullptr;
    uint32_t i = 0;
    int64_t ns;
    PerfTimer(ns, [&]() {
        gaia_se::begin_transaction();
        for (auto node_ptr = gaia_ptr<gaia_se_node>::find_first(AirportDemo::kAirportsType);
            node_ptr;
            node_ptr = node_ptr.find_next())
        {
            auto row = flatbuffers::GetRoot<airports>(node_ptr->payload);
            i++;
            if (row->iata())
            {
                if (0 == row->iata()->str().compare(iata))
                {
                    ptr = row;
                    break;
                }
            }
        }
        commit_transaction();
    });
    printf("Found %s after searching %u airports with raw access in %2.f ms\n", iata, i, PerfTimer::ns_ms(ns));
    return ptr;
}

const Airport * find_airport(const Airport * list, const char * iata)
{
    const Airport * ap = list;
    const Airport * found = nullptr;
    uint32_t i = 0;
    int64_t ns;
    PerfTimer(ns, [&]() {
        gaia_se::begin_transaction();
        while (ap)
        {
            i++;
            if (ap->iata()) 
            {
                if (0 == ap->iata()->str().compare(iata))
                {
                    found = ap;
                    break;
                }
            }
            ap = ap->next;
        }
        gaia_se::commit_transaction();
    });
    printf("Found %s after searching %u airports with obj access in %2.f ms\n", iata, i, PerfTimer::ns_ms(ns));
    return found;
}

// walk all the edges outgoing from this airport
void breadth_first(gaia_ptr<gaia_se_node> node_ptr)
{
    for (auto edge_ptr = node_ptr->next_edge_first; edge_ptr; edge_ptr = edge_ptr->next_edge_first)
    {
        // print out all the destinations
        // if we have no current route then we are at the root so
        auto airport_ptr = edge_ptr->node_second;
        const airports * dat = flatbuffers::GetRoot<airports>(airport_ptr->payload);
        printf("%s\n", dat->iata() ? dat->iata()->c_str() : "<NO IATA>" );
    }
}

// display a single route object
void traverse_route_list(list<Route *>& routes, bool print)
{
    bool printed_header = false;

    for (auto r : routes) {
        const char * airline = r->al->name() ? r->al->name()->c_str() : "<null>";
        const char * dst_name = r->dst_airport->name() ? r->dst_airport->name()->c_str() : "<null>";
        const char * dst_iata = r->dst_airport->iata() ? r->dst_airport->iata()->c_str() : "<null>";

        if (!printed_header) {
            const char * src_name = r->src_airport->name() ? r->src_airport->name()->c_str() : "<null>";
            const char * src_iata = r->src_airport->iata() ? r->src_airport->iata()->c_str() : "<null>";
            if (print) printf("Routes from '%s'(%s)\n", src_name, src_iata);
            printed_header=true;
        }
        if (print) printf("\t%s to '%s'(%s)\n", airline, dst_name, dst_iata);
    }
}

// display the list of routes, materializing airport
void print_route(list<int64_t>& route)
{
    bool first = true;
    for (auto id : route)
    {
        auto node_ptr = gaia_se_node::open(id);
        auto ap = flatbuffers::GetRoot<airports>(node_ptr->payload);
        const char * s = ap->iata() ? ap->iata()->c_str() : "<NO IATA>";
        if (first) {
            printf("%s", s);
            first = false;
        }
        else {
            printf("->%s", s);
        }
    }
    printf("\n");
}

void print_route(list<const Airport *>& route)
{
    bool first = true;
    for (auto ap : route)
    {
        const char * s = ap->iata() ? ap->iata()->c_str() : "<NO IATA>";
        if (first) {
            printf("%s", s);
            first = false;
        }
        else {
            printf("->%s", s);
        }
    }
    printf("\n");
}

struct FindRouteContext_Raw
{
    FindRouteContext_Raw(uint32_t max) : max_hops(max){}
    // maximum depth to search
    uint32_t max_hops;
    // total routes crawled
    uint32_t num_routes = 0;
    // list of routes from source to destination
    vector<list<int64_t>> routes;
    list<int64_t> current_route;
    set<int64_t> visited;
};

struct FindRouteContext_Obj
{
    FindRouteContext_Obj(uint32_t max) : max_hops(max){}
    // maximum depth to search
    uint32_t max_hops;
    // total routes crawled
    uint32_t num_routes = 0;
    // list of routes from source to destination
    vector<list<const Airport *>> routes;
    list<const Airport *> current_route;
    set<const Airport *> visited;
};

class Depth {
public:
    Depth() { s_depth++;}
    ~Depth() { s_depth--;}
    static uint32_t s_depth;
};
uint32_t Depth::s_depth = 0;

void crawl_edges_raw(gaia_ptr<gaia_se_node> node_ptr,
    int64_t dst_id,
    FindRouteContext_Raw& c
)
{
    Depth d;

    if (Depth::s_depth > c.max_hops) {
        return;
    }

    int64_t id = node_ptr->id;

    // if this airport is along this route already then don't go back to it
    if(c.visited.end() != c.visited.find(id)){
        return;
    }

    c.num_routes++;

    // put this airport on our current route
    // and update our index
    c.current_route.push_back(id);
    c.visited.insert(id);

    //print_route(c.current_route);

    // if we found our destination, we are done
    if (id == dst_id)
    {
        // add this to the list of candidate routes
        c.routes.push_back(c.current_route);
    }
    else
    {
        //printf("Calculate routes from %s, %s\n", iata.c_str(), ap->name() ? ap->name()->c_str(): "<NO NAME>");

        // only going for reachability here
        // so don't traverse edges to airports we've already
        // traversed.  For example, SEA has several routes to LAX
        // via different airlines
        set<int64_t> children;

        // next_edge_first is all the airports directly connected to this airport
        for (auto edge_ptr = node_ptr->next_edge_first; edge_ptr; edge_ptr = edge_ptr->next_edge_first)
        {
            // next_edge_second is the next airport
            auto airport_ptr = edge_ptr->node_second;
            if(children.end() != children.find(airport_ptr->id)){
                continue;
            }
            children.insert(airport_ptr->id);
            crawl_edges_raw(airport_ptr, dst_id, c);
        }
    }

    //
    // we're done with this node so remove from
    // the current route as well as our index
    //
    c.current_route.pop_back();
    c.visited.erase(id);
}

void crawl_edges_obj(const Airport * ap,
    const Airport * dst_ap,
    FindRouteContext_Obj& c
)
{
    Depth d;

    if (Depth::s_depth > c.max_hops) {
        return;
    }

    // if this airport is along this route already then don't go back to it
    if(c.visited.end() != c.visited.find(ap)){
        return;
    }

    c.num_routes++;

    // put this airport on our current route
    // and update our index
    c.current_route.push_back(ap);
    c.visited.insert(ap);

    //print_route(c.current_route);

    // if we found our destination, we are done
    if (ap == dst_ap)
    {
        // add this to the list of candidate routes
        c.routes.push_back(c.current_route);
    }
    else
    {
        //printf("Calculate routes from %s, %s\n", iata.c_str(), ap->name() ? ap->name()->c_str(): "<NO NAME>");

        // only going for reachability here
        // so don't traverse edges to airports we've already
        // traversed.  For example, SEA has several routes to LAX
        // via different airlines
        set<Airport *> children;

        // next_edge_first is all the airports directly connected to this airport
        for (auto r : ap->routes)
        {
            Airport * next_airport = r->dst_airport;
            if(children.end() != children.find(next_airport)){
                continue;
            }
            children.insert(next_airport);
            crawl_edges_obj(next_airport, dst_ap, c);
        }
    }

    //
    // we're done with this node so remove from
    // the current route as well as our index
    //
    c.current_route.pop_back();
    c.visited.erase(ap);
}

// run a route finding algorithm using raw gaia syntax
void find_route_raw(const char * src_iata, const char * dst_iata, uint32_t max_hops, bool show_routes)
{
    FindRouteContext_Raw c(max_hops);
    const airports * src = find_airport(src_iata);
    const airports * dst = find_airport(dst_iata);

    int64_t ns;
    PerfTimer(ns, [&]() {
            gaia_se::begin_transaction();
                crawl_edges_raw(gaia_se_node::open(src->Gaia_id()), dst->Gaia_id(), c);
            gaia_se::commit_transaction();
    });
    printf("Searched %d routes in %.2f ms using raw access\n", c.num_routes, PerfTimer::ns_ms(ns));
    printf("Found %lu routes out of Seattle with <= '%u' hops:\n", c.routes.size(), max_hops);

    if (show_routes){
        gaia_se::begin_transaction();
        for (auto r : c.routes) {
            print_route(r);
        }
        gaia_se::commit_transaction();
    }
}

// run a route finding algorithm using raw gaia syntax
void find_route_obj(const Airport * airports, const char * src_iata, const char * dst_iata, uint32_t max_hops, bool show_routes)
{
    FindRouteContext_Obj c(max_hops);

    const Airport * src = find_airport(airports, src_iata);
    const Airport *dst = find_airport(airports, dst_iata);

    int64_t ns;
    PerfTimer(ns, [&]() {
            gaia_se::begin_transaction();
                crawl_edges_obj(src, dst, c);
            gaia_se::commit_transaction();
    });
    printf("Searched %d routes in %.2f ms using obj access\n", c.num_routes, PerfTimer::ns_ms(ns));
    printf("Found %lu routes out of Seattle with <= '%u' hops:\n", c.routes.size(), max_hops);

    if (show_routes){
        gaia_se::begin_transaction();
        for (auto r : c.routes) {
            print_route(r);
        }
        gaia_se::commit_transaction();
    }
}

int main (int argc, const char ** argv)
{
    gaia_mem_base::init(false);
    traverse_list_raw(0, 5);
    traverse_list_obj(5, 5);

    // **************************************************************************
    // Load into my own structure that inherites from airlineT.  I've added
    // next and prev pointers and can fill them in here.  This is an explicit
    // step.
    // **************************************************************************
    AirlineObj * head = nullptr;
    AirlineObj * tail = nullptr;
    AirlineObj * prev = nullptr;

    gaia_se::load<AirlineObj>(AirportDemo::kAirlinesType, [&](AirlineObj * a)
    {
        if (nullptr == head)
        {
            head = a;
            tail = a;
        }
        else
        {
            a->prev = prev;
            prev->next = a;
        }
        prev = tail = a;
    });

    // **************************************************************************
    // note that I could also just use a std::list
    // and put in regular flat buffers
    // **************************************************************************
    list<const airlines *> listAirlines;
    gaia_se::load_zero_copy<airlines, gaia_se_node>(AirportDemo::kAirlinesType, [&](const airlines * a)
    {
        listAirlines.push_back(a);
    });

    // **************************************************************************
    // natural traversal
    // **************************************************************************
    AirlineObj * current = head;

    // print 5 rows
    uint32_t i;

    for (i = 0; i < 5 && current; i++)
    {
        printf("%d, %s, %s\n", 
                current->al_id, 
                current->name.c_str(), 
                current->active.c_str()
        );
        current = current->next;
    }
    
    //**************************************************************************
    // natural traversal, not so bad with list either but note that
    // since we didn't make a copy, we must have an active transation here.
    // Is this correct?  Offer something like a gaia transaction class
    // that begins on constructions and ends on destruction with appropriate
    // rollback behavior
    // **************************************************************************
    i = 0;
    begin_transaction();
    for (auto item : listAirlines)
    {
        printf("%d, %s, %s\n", 
                item->al_id(), 
                item->name()->c_str(), 
                item->active()->c_str()
        );        
        i++;
        if (i == 5) break;
    }
    commit_transaction();

    // **************************************************************************
    // update:  would like to do the following
    // this works because AirlineObj was a copy so we are just changing our local
    // copy
    // **************************************************************************
    AirlineObj * mine = head->next->next;
    mine->name = "Dax's Airline";
    //
    // show change
    //
    traverse_list_native(head, 2, 1);

    //
    // get back original value
    // 
    mine->refresh();
    //gaia_se::refresh(mine);

    traverse_list_native(head, 2, 1);

    mine->name = "Dax's Airline For Real This Time";
    mine->update();
    mine->refresh();
    traverse_list_native(head, 2, 1);

    AirlineObj * new_al = new AirlineObj();
    new_al->Gaia_id = 1000000;
    new_al->al_id = tail->al_id + 1;
    new_al->name = "Woo Hoo!";
    new_al->active = "Y";
    new_al->prev = tail;
    tail->next = new_al;
    tail = new_al;

    new_al->insert();
    //gaia_se::insert(new_al);

    traverse_list_native(tail, 0, 1);
    
    // could also make this part of the dtor (but then insert above)
    // should be part of the ctor)
    tail = new_al->prev;
    tail->next = nullptr;
    new_al->remove();
    delete new_al;
    traverse_list_native(tail, 0, 1);


    // [WLW] test removed because id's are based on GUID algorithm
    // get a copy from the database of some airline 
    // AirlineObj * exist_al = new AirlineObj(3420);
    // printf("%d, %s, %s\n", 
    //     exist_al->al_id, 
    //     exist_al->name.c_str(), 
    //     exist_al->active.c_str());

    // **************************************************************************
    // in the zero-copy case, we don't have a mutable flatbuffer since this would
    // violate our COW semantics.  So, define our own class 'Airline' that is
    // zero-copy in read-only case but then creates a copy on the first field
    // write method call
    // **************************************************************************
    Airline_Writeable * mut_head = nullptr;
    Airline_Writeable * mut_tail = nullptr;
    Airline_Writeable * mut_prev = nullptr;
    
    gaia_se::load_zero_copy<airlines, gaia_se_node>(AirportDemo::kAirlinesType, [&](const airlines * a_fb)
    {
        Airline_Writeable * a = new Airline_Writeable(a_fb);
        if (nullptr == mut_head)
        {
            mut_head = a;
            mut_tail = a;
        }
        else
        {
            a->prev = mut_prev;
            mut_prev->next = a;
        }
        mut_prev = mut_tail = a;
    });

    gaia_se::begin_transaction();
    traverse_list_native(mut_head, 5, 5);
    gaia_se::commit_transaction();

    // now update the 6th record
    Airline_Writeable * target = mut_head->next->next->next->next->next;
    gaia_se::begin_transaction();
    target->set_name("A Mutable Airport");
    traverse_list_native(mut_head, 5, 1);
    target->refresh();
    traverse_list_native(mut_head, 5, 1);
    target->set_name("A Mutable Airport For Real This Time");
    gaia_se::commit_transaction();
    gaia_se::begin_transaction();
    traverse_list_native(mut_head, 5, 1);
    gaia_se::commit_transaction();

    // insert a new record with our "immutable object"
    gaia_se::begin_transaction();
    Airline_Writeable * mut_new = new Airline_Writeable();
    mut_new->set_Gaia_id(1000001);
    mut_new->set_al_id(mut_tail->al_id() + 1);
    mut_new->set_name("Woo Mut!");
    mut_new->set_active("N");
    mut_new->prev = mut_tail;
    mut_tail->next = mut_new;
    mut_tail = mut_new;
    gaia_se::commit_transaction();
    mut_new->insert();
    gaia_se::begin_transaction();
    traverse_list_native(mut_tail, 0, 1);
    gaia_se::commit_transaction();
    mut_tail = mut_new->prev;
    mut_tail->next = nullptr;
    mut_new->remove();
    delete mut_new;


    // look at some of the more challenging rows
    gaia_se::begin_transaction();
    traverse_list_native(mut_head, 5637, 1);
    gaia_se::commit_transaction();

    // **************************************************************************
    // edge navigation
    //
    // let's make a list of airports from Seattle (SEA) to Tahiti (PPT)
    //
    // we have flatbuffers of airports as nodes
    // we have flatbuffers of routes (airport -> airport) as edges
    // this tests using the raw gaia pointers
    // **************************************************************************
    find_route_raw("SEA", "PPT", 3, false);
    
    // **************************************************************************
    // now do the same thing with memory objects backed by flatbuffers
    // and materialize them ahead of time
    // **************************************************************************

    // load airlines
    Airline * al_head = nullptr;
    Airline * al_tail = nullptr;
    Airline * al_prev = nullptr;

    // can this be in the database?
    map<int64_t, Airline *> al_map;

    load_zero_copy<airlines, gaia_se_node>(AirportDemo::kAirlinesType, [&](const airlines * al_fb)
    {
        Airline * al = new Airline(al_fb);
        if (nullptr == al_head)
        {
            al_head = al_tail = al;
        }
        else
        {
            al->prev = al_prev;
            al_prev->next = al;
        }
        al_prev = al_tail = al;
        al_map.insert(pair<int64_t, Airline *>(al->Gaia_id(), al));
    });

    Airport * ap_head = nullptr;
    Airport * ap_tail = nullptr;
    Airport * ap_prev = nullptr;
    map<int64_t, Airport *> ap_map;

    load_zero_copy<airports, gaia_se_node>(AirportDemo::kAirportsType, [&](const airports * ap_fb)
    {
        Airport * ap = new Airport(ap_fb);
        if (nullptr == ap_head)
        {
            ap_head = ap_tail = ap;
        }
        else
        {
            ap->prev = ap_prev;
            ap_prev->next = ap;
        }
        ap_prev = ap_tail = ap;
        ap_map.insert(pair<int64_t, Airport *>(ap->Gaia_id(), ap));
    });

    Route * r_head = nullptr;
    Route * r_tail = nullptr;
    Route * r_prev = nullptr;
    map<int64_t, Route *> r_map;
    load_zero_copy<routes, gaia_se_edge>(AirportDemo::kRoutesType, [&](const routes * r_fb)
    {
        Route * r = new Route(r_fb);
        if (nullptr == r_head)
        {
            r_head = r_tail = r;
        }
        else
        {
            r->prev = r_prev;
            r_prev->next = r;
        }
        r_prev = r_tail = r;
        r_map.insert(pair<int64_t, Route *>(r->Gaia_id(), r));
    });    

    // now fill in our object pointers for every route
    gaia_se::begin_transaction();
    Route * r_curr = r_head;
    while (r_curr) {
        r_curr->al= al_map[r_curr->Gaia_Al_id()];
        r_curr->src_airport = ap_map[r_curr->Gaia_Src_id()];
        r_curr->dst_airport = ap_map[r_curr->Gaia_Dst_id()];
        r_curr = r_curr->next;
    }
    gaia_se::commit_transaction();

    // and fill in the route lists for every airport
    gaia_se::begin_transaction();
    Airport * ap_curr = ap_head;
    while (ap_curr) {
        auto node_ptr = gaia_se_node::open(ap_curr->Gaia_id());

        // fill in the routes for this airport as a linked list
        for (auto edge_ptr = node_ptr->next_edge_first; edge_ptr; edge_ptr = edge_ptr->next_edge_first)
        {
            ap_curr->routes.push_back(r_map[edge_ptr->id]);
        }
        ap_curr = ap_curr->next;
    }
    gaia_se::commit_transaction();
    
    uint32_t num_airports = 0;
    uint32_t num_routes = 0;
    int64_t ns;
    PerfTimer(ns, [&]() {
        gaia_se::begin_transaction();
        ap_curr = ap_head;
        while(ap_curr)
        {
            traverse_route_list(ap_curr->routes, false);
            num_airports++;
            num_routes += ap_curr->routes.size();
            ap_curr = ap_curr->next;
        }
        gaia_se::commit_transaction();
    });
    printf("Crawled %u routes across %u airports in %.2f ms using obj access\n", 
        num_routes, num_airports, PerfTimer::ns_ms(ns));

    // **************************************************************************
    // edge navigation with objects
    //
    // let's make a list of airports from Seattle (SEA) to Tahiti (PPT)
    // **************************************************************************
    find_route_obj(ap_head, "SEA", "PPT", 3, false);
    // **************************************************************************
    // edge updating
    //
    // let's make a list of airports from Seattle to Tahiti
    //
    // we have flatbuffers of airports as nodes
    // we have flatbuffers of routes (airport -> airport) as edges
    // let's create a direct route
    // **************************************************************************
}


// **************************************************************************
// Scrap yard of dead examples...just keeping around in case it jogs my memory
// **************************************************************************
/*


// get a little fancier

// inserts to end of list
// locator record type
// graph load of data 
// store data in the database, feels natural to a programmer, not necessarily a database person

// extended data class, 
// start as a linked list and somehow put this in the database as automatically as possible


struct Person
{
    Person * next; // next row
    Person * prev; // prev row
    Person * next_friend; // next 
    Person * next_employee;
};


void insert_person(Person ** head_ptr, Person ** tail_ptr, string a_first, string a_last, uint8_t a_age)
{
    Person * person = new Person(a_first, a_last, a_age);
    *tail_ptr = person;

    Person * ptr = *head_ptr;
    if (nullptr == ptr) 
    {
        *head_ptr = person;
    }
    else 
    {
        while (ptr->next != nullptr) 
        {
            ptr = ptr->next;
        }
        ptr->next = person;
        person->prev = ptr;
    }
}

void traverse_list_forward(Person * head) 
{
    for (Person * person = head; person != nullptr; person = person->next) 
    {
        printf("%s, %s, %d, %d\n", person->fname.c_str(), person->lname.c_str(), person->age, person->steps);
    }
}

void traverse_list_backward(Person * tail)
{
    for (Person * person = tail; person != nullptr; person = person->prev) 
    {
        printf("%s, %s, %d, %d\n", person->fname.c_str(), person->lname.c_str(), person->age, person->steps);
    }
}

// LINQ (power of combining query with programming)  Python slicing, etc
// conditionals.  However, we have an in-memory database so we can just use a QP for this
// if the call can be lightweight enough.

// update semantics especial with regards to transaction lifetimes.
// relational schema?


// a link table that links between variables used in a rule and fields that appear in a record.  Fields that 
// appear in a record are in the catalog schema.
// understand structure of a row

//
// a pointer is not a memory pointer but goes up through a transaction scheme to get to a record
// I can use a pointer to implement a linked list
// 

//
// Coming up with a medium sized database that lends itself to be a set of tables
// and property graph.  Start with airports?  Get the tabular value out of it as well
// 

//
// all the things of type 1 are stored in a table
//

//
// stuff that's annoying/distributed (when did I wish I had SQL?  Graph?  Direct access?)
// employees
// relationships -> friends, manager, 
//

//
// SUGGESTIONS:
// every Gaia Row must have a gaia id -> consider making this a mandatory part of the payload.
// 
// Guidelines, in order of priority:
// 1) data integrity; must obey transacational semantics
// 2) time performance; ensure containers do not copy records around.  Using flatbuffers for zero-copy semantics
// 3) intuitive, language-driven API:  should not know that my linked list is stored in the database
//
//
// OBSERVATIONS:
// 1) because the database is in memory and we have zero-copy semantics, you don't need to worry about
// selecting a subset of fields.  You can bring back an entire row without penalty only if you need to access
// a single filed from that.  You will, however, want to filter the data you get back so that you are only working
// on what you care about.
// 2) Will likely need/(strong desire) API for the following
//      - transactions (begin/commit/rollback)
//      - loading object graph into local structures (LINQ-like predicates, i.e. pass WHERE clause down)
//      - update/resync in bulk or object level
// 3) Note that loading with a WHERE clause is not about constraining what we load into memory (the entire graph)
//  is in memory, afterall although not necessarily materialized as flatbuffers, but rather only loading the subset
//  of a connected graph that your application cares about.  We'll want to know how to load edges.  The linked list
//  example is much more powerful showing navigation over relationships (airports connected to SEA, for example) than
//  simply iterating over a table.
// 
//
// CONSTRAINTS:
// 1) We are going to use flatbuffers but we can possibly extend them with Gaia semantics
// 2) We must preserve copy on write semantics but we could also extend the flatbuffer classes to make the syntax easier
//
//
// TODO: 
// 1) need to distinguish navigating nodes versus edges.  what does this look like?
// 2) easy to provide transaction wrappers if we so desire.  My feeling is that transactions should be explicit
//


*/
