#include <atomic>
#include <algorithm>
#include <cstdio>
#include "gaia/exception.hpp"
#include "gaia_hack.h"
#include "hack_constants.h"

static constexpr int c_id_len = 8;
using namespace std;

void send_message(string message, time_t time_done)
{
    gaia::hack::Message_writer m;
    m.message_timestamp = time_done;
    m.message_user = "";
    m.message_message = message;
    m.insert_row();
}

// Create an error message and throw an exception.
void abort_rule(string message)
{
    // This little dance allows the front-end to find this message so it can proceed.
    gaia::db::rollback_transaction();
    gaia::db::begin_transaction();
    send_message("Command failure: " + message, time(NULL));
    gaia::db::commit_transaction();
    throw gaia::common::gaia_exception(message.c_str());
}

// Create the Person record used by any person type.
gaia::hack::Person_writer create_person(stringstream& params)
{
    char person_id[c_id_len];

    // Obtain the Person ID.
    auto id = gaia::hack::id_association_t::get_first();
    snprintf(person_id, c_id_len, "%s%03d", c_person_prefix.c_str(), id.person());
    auto id_writer = id.writer();
    id_writer.person++;
    id_writer.update_row();

    std::string param_value;
    gaia::hack::Person_writer p;
    getline(params, param_value, ' ');
    p.FirstName = param_value;
    getline(params, param_value, ' ');
    p.LastName = param_value;
    p.PersonId = person_id;
    getline(params, param_value, ' ');
    p.Birthdate = atoi(param_value.c_str());
    return p;
}

// The following "find_<type>()" functions should be compacted into one function.
// Maybe a combination of template and lambda function?
// Each function acts like a key lookup of the ID in the type.
gaia::hack::Student_t find_student(const char* student_id)
{
    // Find the Student
    gaia::hack::Student_t student = gaia::hack::Student_t::get(0);
    for (auto s : gaia::hack::Student_t::list())
    {
        if (strcmp(s.StudentId(), student_id) == 0)
        {
            student = s;
            break;
        }
    }
    if (!student)
    {
        abort_rule("Unable to locate Student " + string(student_id));
    }
    return student;
}

gaia::hack::Person_t find_person(const char* person_id)
{
    // Find the Person
    gaia::hack::Person_t person = gaia::hack::Person_t::get(0);
    for (auto p : gaia::hack::Person_t::list())
    {
        if (strcmp(p.PersonId(), person_id) == 0)
        {
            person = p;
            break;
        }
    }

    // Unlike other find_ functions, this one should return a null Person.
    return person;
}

gaia::hack::Stranger_t find_stranger(const char* stranger_id)
{
    // Find the Stranger
    gaia::hack::Stranger_t stranger = gaia::hack::Stranger_t::get(0);
    for (auto s : gaia::hack::Stranger_t::list())
    {
        if (strcmp(s.StrangerId(), stranger_id) == 0)
        {
            stranger = s;
            break;
        }
    }

    // Unlike other find_ functions, this one should return a null Stranger.
    return stranger;
}

gaia::hack::Parent_t find_parent(const char* parent_id)
{
    // Find the Parent
    gaia::hack::Parent_t parent = gaia::hack::Parent_t::get(0);
    for (auto p : gaia::hack::Parent_t::list())
    {
        if (strcmp(p.ParentId(), parent_id) == 0)
        {
            parent = p;
            break;
        }
    }
    if (!parent)
    {
        abort_rule("Unable to locate Parent " + string(parent_id));
    }
    return parent;
}

gaia::hack::Staff_t find_staff(const char* staff_id)
{
    // Find the Staff
    gaia::hack::Staff_t staff = gaia::hack::Staff_t::get(0);
    for (auto s : gaia::hack::Staff_t::list())
    {
        if (strcmp(s.StaffId(), staff_id) == 0)
        {
            staff = s;
            break;
        }
    }
    if (!staff)
    {
        abort_rule("Unable to locate Staff " + string(staff_id));
    }
    return staff;
}

gaia::hack::Building_t find_building(const char* building_id)
{
    // Find the Building
    gaia::hack::Building_t building = gaia::hack::Building_t::get(0);
    for (auto b : gaia::hack::Building_t::list())
    {
        if (strcmp(b.BuildingId(), building_id) == 0)
        {
            building = b;
            break;
        }
    }
    if (!building)
    {
        abort_rule("Unable to locate Building " + string(building_id));
    }
    return building;
}

gaia::hack::Room_t find_room(const char* room_id)
{
    // Find the Room
    gaia::hack::Room_t room = gaia::hack::Room_t::get(0);
    for (auto r : gaia::hack::Room_t::list())
    {
        if (strcmp(r.RoomId(), room_id) == 0)
        {
            room = r;
            break;
        }
    }
    if (!room)
    {
        abort_rule("Unable to locate Room " + string(room_id));
    }
    return room;
}

gaia::hack::Event_t find_event(const char* event_id)
{
    // Find the Event
    gaia::hack::Event_t event = gaia::hack::Event_t::get(0);
    for (auto e : gaia::hack::Event_t::list())
    {
        if (strcmp(e.EventId(), event_id) == 0)
        {
            event = e;
            break;
        }
    }
    if (!event)
    {
        abort_rule("Unable to locate Event " + string(event_id));
    }
    return event;
}

gaia::hack::Enrollment_t find_enrollment(const char* enrollment_id)
{
    // Find the Enrollment
    gaia::hack::Enrollment_t enrollment = gaia::hack::Enrollment_t::get(0);
    for (auto e : gaia::hack::Enrollment_t::list())
    {
        if (strcmp(e.EnrollmentId(), enrollment_id) == 0)
        {
            enrollment = e;
            break;
        }
    }
    if (!enrollment)
    {
        abort_rule("Unable to locate Enrollment " + string(enrollment_id));
    }
    return enrollment;
}

gaia::hack::Family_t find_family(const char* family_id)
{
    // Find the Family
    gaia::hack::Family_t family = gaia::hack::Family_t::get(0);
    for (auto f : gaia::hack::Family_t::list())
    {
        if (strcmp(f.FamilyId(), family_id) == 0)
        {
            family = f;
            break;
        }
    }
    if (!family)
    {
        abort_rule("Unable to locate Family " + string(family_id));
    }
    return family;
}

ruleset hack_ruleset
{
    {
        if (Command.LastOperation == INSERT)
        {
            // RULE:
            // When a new Register_Command row is inserted, determine the operation (register/delete)
            // and log a register or delete record to perform the operation.
            if (command_operation == c_register)
            {
                gaia::hack::Register_Command_writer r;
                r.register_timestamp = time(NULL);
                r.register_person_type = command_person_type;
                r.register_parameters = command_parameters;
                r.insert_row();
            }
            else if (command_operation == c_delete)
            {
                gaia::hack::Delete_Command_writer d;
                d.delete_timestamp = time(NULL);
                d.delete_person_type = command_person_type;
                d.delete_id = command_parameters;
                d.insert_row();
            }

            gaia::hack::Processed_Command_writer p;
            p.processed_timestamp = command_timestamp;
            p.processed_time_done = time(NULL);
            p.processed_operation = command_operation;
            p.processed_person_type = command_person_type;
            p.processed_parameters = command_parameters;
            p.insert_row();
        }
    }

    {
        // RULE:
        // When a Register_Command row is inserted, determine the person type and
        // perform the enrollment.

        // Note that this rule is only invoked on INSERT.
        string parameters = register_parameters;
        stringstream params(parameters);
        string param_value;

        // All REGISTER commands except FAMILY, EVENT and REGISTRATION start with Person data in the parameters.
        gaia::hack::Person_writer p;
        if (register_person_type == c_student || register_person_type == c_staff || register_person_type == c_parent)
        {
            // This function absorbs the first, last and birthday parameters.
            p = create_person(params);
        }

        if (Register_Command.LastOperation == INSERT)
        {
            char id[c_id_len];
            int32_t number;
            auto role_id = gaia::hack::id_association_t::get_first();

            if (register_person_type == c_student)
            {
                // Obtain the Student ID.
                number = role_id.student();
                snprintf(id, c_id_len, "%s%03d", c_student_prefix.c_str(), number);
                auto id_writer = role_id.writer();
                id_writer.student++;
                id_writer.update_row();

                // Create the Student
                gaia::hack::Student_writer s;
                s.StudentId = id;
                s.Number = number;

                // Connect the Student to the Person.
                auto person = gaia::hack::Person_t::get(p.insert_row());
                auto student = gaia::hack::Student_t::get(s.insert_row());
                person.Student_list().insert(student);

                // Message back to the front-end.
                send_message(string(id), time(NULL));
            }
            else if (register_person_type == c_staff)
            {
                // Obtain the Staff ID.
                snprintf(id, c_id_len, "%s%03d", c_staff_prefix.c_str(), role_id.staff());
                auto id_writer = role_id.writer();
                id_writer.staff++;
                id_writer.update_row();

                // Create the Staff
                gaia::hack::Staff_writer s;
                s.StaffId = id;
                getline(params, param_value, ' ');
                s.HiredDate = param_value;

                // Connect the Staff to the Person.
                auto person = gaia::hack::Person_t::get(p.insert_row());
                auto staff = gaia::hack::Staff_t::get(s.insert_row());
                person.Staff_list().insert(staff);

                // Message back to the front-end.
                send_message(string(id), time(NULL));
            }
            else if (register_person_type == c_parent)
            {
                // Obtain the Parent ID.
                snprintf(id, c_id_len, "%s%03d", c_parent_prefix.c_str(), role_id.parent());
                auto id_writer = role_id.writer();
                id_writer.parent++;
                id_writer.update_row();

                // Create the Parent
                gaia::hack::Parent_writer pw;
                pw.ParentId = id;
                getline(params, param_value, ' ');
                if (param_value.length() == 0)
                {
                    abort_rule("Parent registration requires role (mother/father)");
                }
                pw.Role = param_value;

                // Connect the Parent to the Person.
                auto person = gaia::hack::Person_t::get(p.insert_row());
                auto parent = gaia::hack::Parent_t::get(pw.insert_row());
                person.Parent_list().insert(parent);

                // Send ID to the frone-end.
                send_message(string(id), time(NULL));
            }

            else if (register_person_type == c_family)
            {
                string parent_id;
                getline(params, parent_id, ' ');
                string student_id;
                getline(params, student_id, ' ');

                auto parent = find_parent(parent_id.c_str());

                // If the Student is already connected to a Family, just update the mother 
                // or father Id field in the Family record. Otherwise, create the Family. Updating the Family Id
                // fields for Student, Father or Mother should invoke rules
                auto student = find_student(student_id.c_str());
                auto family = *(student.Family_list().begin());
                if (!family)
                {
                    gaia::hack::Family_writer fw;
                    fw.Student_Family = student_id;
                    // By convention, pass the parent id through the role's field.
                    if (strcmp(parent.Role(), c_father.c_str()) == 0)
                    {
                        fw.Father_Family = parent_id;
                    }
                    else
                    {
                        fw.Mother_Family = parent_id;
                    }
                    fw.insert_row();
                    // This work will be finished by another rule.
                }
                else
                {
                    auto fw = family.writer();
                    if (strcmp(parent.Role(), c_father.c_str()) == 0)
                    {
                        fw.Father_Family = parent_id;
                        parent.father_Family_list().insert(family);
                    }
                    else
                    {
                        fw.Mother_Family = parent_id;
                        parent.mother_Family_list().insert(family);
                    }
                    fw.update_row();

                    send_message(string(family.FamilyId()), time(NULL));
                }
            }
            else if (register_person_type == c_room)
            {
                // Obtain the Room ID.
                snprintf(id, c_id_len, "%s%03d", c_room_prefix.c_str(), role_id.room());
                auto id_writer = role_id.writer();
                id_writer.room++;
                id_writer.update_row();

                // Obtain and store the room name, date, starttime and endtime.
                gaia::hack::Room_writer rw;
                rw.RoomId = id;
                getline(params, param_value, ' ');
                rw.Building_Room = param_value;
                getline(params, param_value, ' ');
                rw.RoomNumber = atoi(param_value.c_str());
                getline(params, param_value, ' ');
                rw.RoomName = param_value;
                getline(params, param_value, ' ');
                rw.FloorNumber = atoi(param_value.c_str());
                getline(params, param_value, ' ');
                rw.Capacity = atoi(param_value.c_str());
                auto room = gaia::hack::Room_t::get(rw.insert_row());

                // Connect room to its building.
                auto building = find_building(rw.Building_Room.c_str());
                building.Room_list().insert(room);

                send_message(string(id), time(NULL));
            }
            else if (register_person_type == c_scan)
            {
                // Obtain the Scan ID.
                snprintf(id, c_id_len, "%s%03d", c_scan_prefix.c_str(), role_id.scan());
                auto id_writer = role_id.writer();
                id_writer.scan++;
                id_writer.update_row();

                // Obtain and store the scan signature, date, starttime and endtime.
                gaia::hack::FaceScanLog_writer sw;
                sw.ScanLogId = id;
                getline(params, param_value, ' ');
                sw.Building_ScanLog = param_value;
                getline(params, param_value, ' ');
                sw.Person_ScanLog = param_value;
                getline(params, param_value, ' ');
                sw.ScanSignature = param_value;
                getline(params, param_value, ' ');
                sw.ScanDate = param_value;
                getline(params, param_value, ' ');
                sw.ScanTime = atoi(param_value.c_str());
                sw.insert_row();

                // Another rule will send the confirming message.
                // send_message(string(id), time(NULL));
            }
            else if (register_person_type == c_building)
            {
                // Obtain the Building ID.
                number = role_id.building();
                snprintf(id, c_id_len, "%s%03d", c_building_prefix.c_str(), number);
                auto id_writer = role_id.writer();
                id_writer.building++;
                id_writer.update_row();

                // Create the Building
                gaia::hack::Building_writer bw;
                bw.BuildingId = id;
                getline(params, param_value, ' ');
                bw.BuildingName = param_value;
                getline(params, param_value, ' ');
                bw.CameraId = atoi(param_value.c_str());
                bw.insert_row();

                // Message back to the front-end.
                send_message(string(id), time(NULL));
            }
            else if (register_person_type == c_event)
            {
                // Obtain the Event ID.
                snprintf(id, c_id_len, "%s%03d", c_event_prefix.c_str(), role_id.event());
                auto id_writer = role_id.writer();
                id_writer.event++;
                id_writer.update_row();

                // Obtain and store the event name, date, starttime and endtime.
                gaia::hack::Event_writer ew;
                ew.EventId = id;
                getline(params, param_value, ' ');
                ew.Staff_Event = param_value;
                getline(params, param_value, ' ');
                ew.Room_Event = param_value;
                getline(params, param_value, ' ');
                ew.EventName = param_value;
                getline(params, param_value, ' ');
                ew.EventDate = param_value;
                getline(params, param_value, ' ');
                ew.EventStartTime = atoi(param_value.c_str());
                getline(params, param_value, ' ');
                ew.EventEndTime = atoi(param_value.c_str());
                ew.insert_row();
            }
            else if (register_person_type == c_enroll)
            {
                // Obtain the Regstration ID.
                snprintf(id, c_id_len, "%s%03d", c_enrollment_prefix.c_str(), role_id.enrollment());
                auto id_writer = role_id.writer();
                id_writer.enrollment++;
                id_writer.update_row();

                // Obtain the ID's of the Student and Event this Event connnects.
                gaia::hack::Enrollment_writer rw;
                rw.EnrollmentId = id;
                getline(params, param_value, ' ');
                rw.Student_Enrollment = param_value;
                getline(params, param_value, ' ');
                rw.Event_Enrollment = param_value;
                getline(params, param_value, ' ');
                rw.EnrollmentDate = param_value;
                getline(params, param_value, ' ');
                rw.EnrollmentTime = atoi(param_value.c_str());
                rw.insert_row();
            }
        }
    }

    {
        // RULE: 
        // The Family record has been created.  Fill this one in correctly. Connect to the
        // Father or Mother parent based on field contents.
        if (Family.LastOperation == INSERT)
        {
            // Find the student
            string studentId = Student_Family;
            auto student = find_student(Student_Family);

            auto fam = gaia::hack::Family_t::get(Family.gaia_id());
            student.Family_list().insert(fam);

            // Find/connect either father or mother.
            gaia::hack::Parent_t parent;
            if (Father_Family)
            {
                parent = find_parent(Father_Family);
                parent.father_Family_list().insert(fam);
            }
            else
            {
                parent = find_parent(Mother_Family);
                parent.mother_Family_list().insert(fam);
            }

            // Obtain and set the Family ID.
            char family_id[c_id_len];
            auto id = gaia::hack::id_association_t::get_first();
            snprintf(family_id, c_id_len, "%s%03d", c_family_prefix.c_str(), id.family());
            auto id_writer = id.writer();
            id_writer.family++;
            id_writer.update_row();

            auto fw = fam.writer();
            fw.FamilyId = family_id;
            fw.update_row();

            send_message(family_id, time(NULL));
        }
    }

    {
        // RULE:
        // When a Delete_Command row is inserted, determine the person type and
        // perform the deletion.

        if (Delete_Command.LastOperation == INSERT)
        {
            if (delete_person_type == c_student)
            {
                auto student = find_student(delete_id);
                if (student)
                {
                    // If Student is connected to a family, disconnect the Family
                    // and delete it first.
                    for (;;)
                    {
                        auto family = *(student.Family_list().begin());
                        if (!family)
                        {
                            break;
                        }
                        auto mother = family.mother_Parent();
                        auto father = family.father_Parent();
                        if (mother)
                        {
                            mother.mother_Family_list().erase(family);
                        }
                        if (father)
                        {
                            father.father_Family_list().erase(family);
                        }
                        student.Family_list().erase(family);
                        family.delete_row();
                    }
                    // If the student is enrolled in events, disconnect & delete the enrollments.
                    for (;;)
                    {
                        auto enrollment = *(student.student_enrollment_Enrollment_list().begin());
                        if (!enrollment)
                        {
                            break;
                        }
                        // Disconnect the enrollment from the event.
                        auto event = enrollment.event_enrollment_Event();
                        event.event_enrollment_Enrollment_list().erase(enrollment);
                        student.student_enrollment_Enrollment_list().erase(enrollment);
                        enrollment.delete_row();
                    }
                    // Disconnect Student from Person & delete both.
                    auto person = student.Person();
                    person.Student_list().erase(student);
                    person.delete_row();
                    student.delete_row();
                    send_message("DELETE successful", time(NULL));
                    return;
                }
            }
            else if (delete_person_type == c_staff)
            {
                auto staff = find_staff(delete_id);
                if (staff)
                {
                    // Delete this Staff record. It's Person record first. After disconnecting.
                    auto person = staff.Person();
                    person.Staff_list().erase(staff);
                    person.delete_row();
                    staff.delete_row();
                    send_message("DELETE successful", time(NULL));
                    return;
                }
            }
            else if (delete_person_type == c_parent)
            {
                auto parent = find_parent(delete_id);
                if (parent)
                {
                    // Disconnect from all Student.
                    if (strcmp(parent.Role(), c_mother.c_str()) == 0)
                    {
                        for (;;)
                        {
                            auto family = *(parent.mother_Family_list().begin());
                            if (!family)
                            {
                                break;
                            }
                            parent.mother_Family_list().erase(family);
                            auto student = family.Student();
                            // If the father is connected, don't disconnect or delete the Family.
                            if (!family.father_Parent())
                            {
                                student.Family_list().erase(family);
                                family.delete_row();
                            }

                        }
                    }
                    else
                    {
                        // Not mother, must be father.
                        for (;;)
                        {
                            auto family = *(parent.father_Family_list().begin());
                            if (!family)
                            {
                                break;
                            }
                            parent.father_Family_list().erase(family);
                            auto student = family.Student();
                            // If the mother is connected, don't disconnect or delete the Family.
                            if (!family.mother_Parent())
                            {
                                student.Family_list().erase(family);
                                family.delete_row();
                            }
                        }
                    }

                    // Disconnect Parent from Person & delete both.
                    auto person = parent.Person();
                    person.Parent_list().erase(parent);
                    person.delete_row();
                    parent.delete_row();
                    send_message("DELETE successful", time(NULL));
                    return;
                }
            }
            else if (delete_person_type == c_family)
            {
                // Disconnect the Family from the Student and Parent it is a member of.
                auto family = find_family(delete_id);

                auto student = family.Student();
                student.Family_list().erase(family);

                auto father = family.father_Parent();
                if (father)
                {
                    father.father_Family_list().erase(family);
                }
                auto mother = family.mother_Parent();
                if (mother)
                {
                    mother.mother_Family_list().erase(family);
                }

                family.delete_row();

                send_message("DELETE successful", time(NULL));
                return;
            }
            else if (delete_person_type == c_building)
            {
                auto building = find_building(delete_id);
                // Currently assuming that all events have already been disconnected/deleted.
                // Otherwise, this will fail.

                building.delete_row();

                send_message("DELETE successful", time(NULL));
                return;
            }
            else if (delete_person_type == c_room)
            {
                auto room = find_room(delete_id);
                // Currently assuming that all events have already been disconnected/deleted.
                // Otherwise, this will fail.

                // Disconnect from Building.
                auto building = room.Building();
                building.Room_list().erase(room);

                room.delete_row();

                send_message("DELETE successful", time(NULL));
                return;
            }
            else if (delete_person_type == c_event)
            {
                // Disconnect the Event from the Room and Staff it is a member of.
                auto event = find_event(delete_id);

                auto staff = event.staff_event_Staff();
                staff.staff_event_Event_list().erase(event);

                auto room = event.room_event_Room();
                room.room_event_Event_list().erase(event);

                // Currently assuming that all enrollments have already been disconnected/deleted.
                // Otherwise, this will fail.
                event.delete_row();

                send_message("DELETE successful", time(NULL));
                return;
            }
            else if (delete_person_type == c_enroll)
            {
                // Disconnect the Enrollment from the Student and Event it is a member of.
                auto enrollment = find_enrollment(delete_id);

                auto student = enrollment.student_enrollment_Student();
                student.student_enrollment_Enrollment_list().erase(enrollment);

                auto event = enrollment.event_enrollment_Event();
                event.event_enrollment_Enrollment_list().erase(enrollment);

                // Currently assuming that all events have already been disconnected/deleted.
                // Otherwise, this will fail.

                // Then Buildings are implemented, disconnect from Building.
                enrollment.delete_row();

                send_message("DELETE successful", time(NULL));
                return;
            }
        }
    }
 
    {
        // RULE: 
        // The Event record has been created. Connect to the Room and Staff.
        if (Event.LastOperation == INSERT)
        {
            // Find the staff
            auto staff = find_staff(Staff_Event);

            // Find the room
            auto room = find_room(Room_Event);

            auto event = gaia::hack::Event_t::get(Event.gaia_id());
            staff.staff_event_Event_list().insert(event);
            room.room_event_Event_list().insert(event);

            send_message(EventId, time(NULL));
        }
    }

    {
        // RULE: 
        // The Enrollment record has been created. Connect to the Event and Student.
        if (Enrollment.LastOperation == INSERT)
        {
            // Locate the Student.
            auto student = find_student(Student_Enrollment);

            // Locate the Event.
            auto event = find_event(Event_Enrollment);

            // Connect the M:N relationship between Event and Student.
            auto enrollment = gaia::hack::Enrollment_t::get(Enrollment.gaia_id());
            student.student_enrollment_Enrollment_list().insert(enrollment);
            event.event_enrollment_Enrollment_list().insert(enrollment);

            send_message(EnrollmentId, time(NULL));
        }
    }

    {
        // RULE: 
        // The FaceScanLog record has been created. Connect to the Building and Person.
        if (FaceScanLog.LastOperation == INSERT)
        {
            // Locate the Person.
            auto person = find_person(Person_ScanLog);

            // Locate the Building.
            auto building = find_building(Building_ScanLog);

            // Connect the M:N relationship between Building and Person.
            auto scan_log = gaia::hack::FaceScanLog_t::get(FaceScanLog.gaia_id());
            building.FaceScanLog_list().insert(scan_log);

            // If Person was found, connect. Otherwise it's a Stranger.
            if (person)
            {
                person.FaceScanLog_list().insert(scan_log);
            }
            else {
                // Find or Create the Stranger record and connect it.
                auto stranger = find_stranger(Person_ScanLog);
                if (!stranger)
                {
                    // Start with a ScanCount of 1 - this one.
                    auto stranger_id = gaia::hack::Stranger_t::insert_row(Person_ScanLog, 1);
                    stranger = gaia::hack::Stranger_t::get(stranger_id);
                }
                else {
                    // Update the ScanCount.
                    auto sw = stranger.writer();
                    sw.ScanCount++;
                    // There's a rule triggered here.
                    sw.update_row();
                }
                stranger.FaceScanLog_list().insert(scan_log);
            }

            send_message(ScanLogId, time(NULL));
        }
    }

    {
        // RULE:
        // The Stranger ScanCount has been updated. Issue warning if beyond 1.
        if (ScanCount >= 2)
        {
            string message = "Warning: Stranger " + string(@StrangerId) + " has attempted to enter Building \"" + @BuildingName
                + "\" on " + string(@ScanDate) + " at " + to_string(@ScanTime) + ".";

            send_message(message, time(NULL));
        }
    }
}
