// automatically generated by the FlatBuffers compiler, do not modify

#include <iterator>

#ifndef FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_
#define FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_

#include "gaia_object.hpp"
#include "airport_generated.h"

using namespace std;
using namespace gaia::common;

namespace gaia {
namespace airport {

// NOTE: the names of these constants are not fixed with this pattern. Care must be taken
//       to not use naming conventions that may cause collision with flatbuffer field names.

// in Flight
const int c_first_segment = 0;
const int c_num_flight_ptrs = 1;

// in Segment
const int c_first_trip_segment = 0;
const int c_primary_segment = 1;
const int c_next_segment = 2;
const int c_primary_src_segment = 3;
const int c_next_src_segment = 4;
const int c_primary_dst_segment = 5;
const int c_next_dst_segment = 6;
const int c_num_segment_ptrs = 7;

// in Airport
const int c_first_src_segment = 0;
const int c_first_dst_segment = 1;
const int c_num_airport_ptrs = 2;

// in Trip_segment
const int c_next_trip_segment = 0;
const int c_primary_trip_segment = 1;
const int c_num_trip_segment_ptrs = 2;

// C++17 compliant way when std::iterator is deprecated
template<typename T_gaia_ptr>
class gaia_iterator_t {
    T_gaia_ptr m_ptr;
public:
    using iterator_category = std::forward_iterator_tag;
    using value_type = T_gaia_ptr;
    using difference_type = int;
    using pointer = T_gaia_ptr*;
    using reference = T_gaia_ptr&;

    gaia_iterator_t(T_gaia_ptr ptr) : m_ptr(ptr) {}
    gaia_iterator_t(const gaia_iterator_t& it) : m_ptr(it.m_ptr) {}

    gaia_iterator_t& operator++() {
        m_ptr = m_ptr->get_next();
        return *this;
    }

    T_gaia_ptr operator++(int) {
        T_gaia_ptr temp = m_ptr;
        operator++();
        return temp;
    }

    bool operator==(const gaia_iterator_t& rhs) const {
        return m_ptr->gaia_id() == rhs.m_ptr->gaia_id();
    }
    bool operator!=(const gaia_iterator_t& rhs) const {
        if (m_ptr && rhs.m_ptr) {
            return m_ptr->gaia_id() != rhs.m_ptr->gaia_id();
        }
        return (m_ptr != rhs.m_ptr);
    }

    T_gaia_ptr& operator*() { return m_ptr; }
};

template<typename T_gaia>
struct gaia_container_t {
    static gaia_iterator_t<T_gaia*> begin() { return gaia_iterator_t<T_gaia*>(T_gaia::get_first()); }
    static gaia_iterator_t<T_gaia*> end() { return gaia_iterator_t<T_gaia*>(nullptr); }
};

template <typename T_foreign, int T_foreign_slot>
class set_iterator {
    T_foreign* m_edc_ptr;
public:
    set_iterator() {}
    set_iterator(T_foreign* edc_ptr) {
        m_edc_ptr = edc_ptr;
    }
    T_foreign* operator*() {
        return m_edc_ptr;
    }
    set_iterator& operator++() {
        m_edc_ptr = T_foreign::get_row_by_id(m_edc_ptr->m_references[T_foreign_slot]);
        return *this;
    }
    bool operator!=(const set_iterator&) const {
        return m_edc_ptr != nullptr;
    }
};

template <typename T_primary, typename T_foreign, int T_parent_slot, int T_primary_slot, int T_foreign_slot>
class reference_chain {
    T_primary* m_outer;
public:
    set_iterator<T_foreign,T_foreign_slot> begin() {
        T_foreign* edc_ptr = T_foreign::get_row_by_id(m_outer->m_references[T_primary_slot]);
        return set_iterator<T_foreign,T_foreign_slot>(edc_ptr);
    }
    set_iterator<T_foreign,T_foreign_slot> end() {return set_iterator<T_foreign,T_foreign_slot>(nullptr);}
    void set_outer(T_primary* outer) {m_outer = outer;}
    void insert(T_foreign* foreign_ptr) {
        foreign_ptr->m_references[T_foreign_slot] = m_outer->m_references[T_primary_slot];
        foreign_ptr->m_references[T_parent_slot]  = m_outer->gaia_id();
        m_outer->m_references[T_primary_slot] = foreign_ptr->gaia_id();
    }
    void erase(T_foreign*) {}
};

struct Flight;
struct Airport;
struct Segment;
struct Trip_segment;

struct Flight : public gaia_object_t<1,Flight,flight,flightT>{
    Flight() : gaia_object_t("Flight") {segments.set_outer(this);}
    int32_t number () const {return GET_CURRENT(number);}
    int32_t number_original () const {return GET_ORIGINAL(number);}
    void set_number(int32_t val) {SET(number, val);}
    int32_t miles_flown () const {return GET_CURRENT(miles_flown);}
    int32_t miles_flown_original () const {return GET_ORIGINAL(miles_flown);}
    void set_miles_flown(int32_t val) {SET(miles_flown, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Flight* insert_row (int32_t number_val,int32_t miles_flown_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createflight(b, number_val,miles_flown_val));
        return gaia_object_t::insert_row(b, c_num_flight_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_flight_ptrs);
    }

    static gaia_container_t<Flight>& flights(){
        static gaia_container_t<Flight> flights;
        return flights;
    }

    reference_chain<Flight,Segment,c_primary_segment,c_first_segment,c_next_segment> segments;
private:
    friend struct gaia_object_t<1,Flight,flight,flightT>;
    friend struct Segment;
    Flight(gaia_id_t id) : gaia_object_t(id, "Flight") {segments.set_outer(this);}
};

struct Airport : public gaia_object_t<2,Airport,airport,airportT>{
    Airport() : gaia_object_t("Airport") {
        src_segments.set_outer(this);
        dst_segments.set_outer(this);
    }
    const char* name () const {return GET_STR(name);}
    const char* name_original () const {return GET_STR_ORIGINAL(name);}
    void set_name(const char* val) {SET(name, val);}
    const char* city () const {return GET_STR(city);}
    const char* city_original () const {return GET_STR_ORIGINAL(city);}
    void set_city(const char* val) {SET(city, val);}
    const char* iata () const {return GET_STR(iata);}
    const char* iata_original () const {return GET_STR_ORIGINAL(iata);}
    void set_iata(const char* val) {SET(iata, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Airport* insert_row (const char* name_val, const char* city_val,const char* iata_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(CreateairportDirect(b, name_val,city_val,iata_val));
        return gaia_object_t::insert_row(b, c_num_airport_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_airport_ptrs);
    }

    static gaia_container_t<Airport>& airports() {
        static gaia_container_t<Airport> airports;
        return airports;
    }

    reference_chain<Airport,Segment,c_primary_src_segment,c_first_src_segment,c_next_src_segment> src_segments;
    reference_chain<Airport,Segment,c_primary_dst_segment,c_first_dst_segment,c_next_dst_segment> dst_segments;
private:
    friend struct gaia_object_t<2,Airport,airport,airportT>;
    Airport(gaia_id_t id) : gaia_object_t(id, "Airport") {
        src_segments.set_outer(this);
        dst_segments.set_outer(this);
    }
};

struct Segment : public gaia_object_t<3,Segment,segment,segmentT>{
    Segment() : gaia_object_t("Segment") {trip_segments.set_outer(this);};
    int32_t id () const {return GET_CURRENT(id);}
    int32_t id_original () const {return GET_ORIGINAL(id);}
    void    set_id(int32_t val) {SET(id, val);}
    int32_t miles () const {return GET_CURRENT(miles);}
    int32_t miles_original () const {return GET_ORIGINAL(miles);}
    void    set_miles(int32_t val) {SET(miles, val);}
    int32_t status () const {return GET_CURRENT(status);}
    int32_t status_original () const {return GET_ORIGINAL(status);}
    void    set_status(int32_t val) {SET(status, val);}
    int32_t luggage_weight () const {return GET_CURRENT(luggage_weight);}
    int32_t luggage_weight_original () const {return GET_ORIGINAL(luggage_weight);}
    void    set_luggage_weight(int32_t val) {SET(luggage_weight, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Segment* insert_row (int32_t id_val,int32_t miles_val,int32_t status_val, int32_t luggage_weight_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createsegment(b, id_val,miles_val,status_val,luggage_weight_val));
        return gaia_object_t::insert_row(b, c_num_segment_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_segment_ptrs);
    }
    Airport* src_segment() {
        Airport* pp = Airport::get_row_by_id(this->m_references[c_primary_src_segment]);
        return pp;
    }
    Airport* dst_segment() {
        Airport* pp = Airport::get_row_by_id(this->m_references[c_primary_dst_segment]);
        return pp;
    }
    static gaia_container_t<Segment>& segments() {
        static gaia_container_t<Segment> segments;
        return segments;
    }

    reference_chain<Segment,Trip_segment,c_primary_trip_segment,c_first_trip_segment,c_next_trip_segment> trip_segments;
private:
    friend struct gaia_object_t<3,Segment,segment,segmentT>;
    Segment(gaia_id_t id) : gaia_object_t(id, "Segment") {trip_segments.set_outer(this);}
};

struct Trip_segment : public gaia_object_t<4,Trip_segment,trip_segment,trip_segmentT>{
    Trip_segment() : gaia_object_t("Trip_segment") {};
    const char* who () const {return GET_STR(who);}
    const char* who_original () const {return GET_STR_ORIGINAL(who);}
    void set_who(const char* val) {SET(who, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Trip_segment* insert_row (const char* who_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createtrip_segmentDirect(b, who_val));
        return gaia_object_t::insert_row(b, c_num_trip_segment_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_trip_segment_ptrs);
    }
    static gaia_container_t<Trip_segment>& trip_segments() {
        static gaia_container_t<Trip_segment> trip_segments;
        return trip_segments;
    }
private:
    friend struct gaia_object_t<4,Trip_segment,trip_segment,trip_segmentT>;
    Trip_segment(gaia_id_t id) : gaia_object_t(id, "Trip_segment") {}
};

}  // namespace airport
}  // namespace gaia

#endif  // FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_
