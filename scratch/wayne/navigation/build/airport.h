// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_
#define FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_

#include "gaia_object.hpp"
#include "airport_generated.h"

using namespace std;
using namespace gaia::common;

namespace gaia {
namespace airport {

// NOTE: the names of these constants are not fixed with this pattern. Care must be taken
//       to not use naming conventions that may cause collision with flatbuffer field names.

// in Flight
const int c_first_segment = 0;
const int c_num_flight_ptrs = 1;

// in Segment
const int c_first_trip_segment = 0;
const int c_primary_segment = 1;
const int c_next_segment = 2;
const int c_primary_src_segment = 3;
const int c_next_src_segment = 4;
const int c_primary_dst_segment = 5;
const int c_next_dst_segment = 6;
const int c_num_segment_ptrs = 7;

// in Airport
const int c_first_src_segment = 0;
const int c_first_dst_segment = 1;
const int c_num_airport_ptrs = 2;

// in Trip_segment
const int c_next_trip_segment = 0;
const int c_primary_trip_segment = 1;
const int c_num_trip_segment_ptrs = 2;

template <typename T_gaia>
class type_iterator {
public:
    type_iterator() {}
    type_iterator(T_gaia* edc_ptr) {
        m_edc_ptr = edc_ptr;
    }
    T_gaia* operator*() {
        return m_edc_ptr;
    }
    type_iterator &operator++() {
        m_edc_ptr = m_edc_ptr->get_next();
        return *this;
    }
    bool operator!=(const type_iterator&) const {
        return m_edc_ptr != nullptr;
    }
private:
    T_gaia* m_edc_ptr;
};

template <typename T_gaia>
type_iterator<T_gaia> begin_scan() {
    T_gaia* edc_ptr = T_gaia::get_first();
    return type_iterator<T_gaia>(edc_ptr);
}
template <typename T_gaia>
type_iterator<T_gaia> end_scan() {
    return type_iterator<T_gaia>(nullptr);
}

template <typename T_primary, typename T_foreign, int T_parent_slot, int T_primary_slot, int T_foreign_slot>
static void connect_objects(T_primary* pp, T_foreign* fp) {
    fp->m_references[T_foreign_slot] = pp->m_references[T_primary_slot];
    fp->m_references[T_parent_slot]  = pp->gaia_id();
    pp->m_references[T_primary_slot] = fp->gaia_id();
}

struct Segment;

struct Flight : public gaia_object_t<1,Flight,flight,flightT>{
    Flight() : gaia_object_t("Flight") {};
    int32_t number () const {return GET_CURRENT(number);}
    int32_t number_original () const {return GET_ORIGINAL(number);}
    void set_number(int32_t val) {SET(number, val);}
    int32_t miles_flown () const {return GET_CURRENT(miles_flown);}
    int32_t miles_flown_original () const {return GET_ORIGINAL(miles_flown);}
    void set_miles_flown(int32_t val) {SET(miles_flown, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Flight* insert_row (int32_t number_val,int32_t miles_flown_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createflight(b, number_val,miles_flown_val));
        return gaia_object_t::insert_row(b, c_num_flight_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_flight_ptrs);
    }
    type_iterator<Flight> begin() {return begin_scan<Flight>();}
    type_iterator<Flight> end() {return end_scan<Flight>();}

//     class set_iterator {
//     public:
//         set_iterator() {}
//         set_iterator(Segment* edc_ptr) {
//             m_edc_ptr = edc_ptr;
//         }
//         Segment* operator*() {
//             return m_edc_ptr;
//         }
//         set_iterator &operator++() {
//             m_edc_ptr = Segment::get_row_by_id(m_edc_ptr->m_references[c_next_segment]);
//             return *this;
//         }
//         bool operator!=(const set_iterator&) const {
//             return m_edc_ptr != nullptr;
//         }
//     private:
//         Segment* m_edc_ptr;
//     };

// public:
//     class segment_iterator {
//     public:
//         set_iterator begin() {
//             Flight* p_ptr = Flight::get_row_by_id(m_id);
//             Segment* edc_ptr = Segment::get_row_by_id(p_ptr->m_references[c_first_segment]);
//             return set_iterator(edc_ptr);
//         }
//         set_iterator end() {
//             return set_iterator(nullptr);
//         }
//         gaia_id_t m_id;
//     };
//     segment_iterator segments;

private:
    friend struct gaia_object_t<1,Flight,flight,flightT>;
    Flight(gaia_id_t id) : gaia_object_t(id, "Flight") {}
};

struct Airport : public gaia_object_t<2,Airport,airport,airportT>{
    Airport() : gaia_object_t("Airport") {};
    const char * name () const {return GET_STR(name);}
    const char * name_original () const {return GET_STR_ORIGINAL(name);}
    void set_name(const char * val) {SET(name, val);}
    const char * city () const {return GET_STR(city);}
    const char * city_original () const {return GET_STR_ORIGINAL(city);}
    void set_city(const char * val) {SET(city, val);}
    const char * iata () const {return GET_STR(iata);}
    const char * iata_original () const {return GET_STR_ORIGINAL(iata);}
    void set_iata(const char * val) {SET(iata, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Airport* insert_row (const char * name_val, const char * city_val,const char * iata_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(CreateairportDirect(b, name_val,city_val,iata_val));
        return gaia_object_t::insert_row(b, c_num_airport_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_airport_ptrs);
    }
    type_iterator<Airport> begin() {return begin_scan<Airport>();}
    type_iterator<Airport> end() {return end_scan<Airport>();}
private:
    friend struct gaia_object_t<2,Airport,airport,airportT>;
    Airport(gaia_id_t id) : gaia_object_t(id, "Airport") {}
};

struct Segment : public gaia_object_t<3,Segment,segment,segmentT>{
    Segment() : gaia_object_t("Segment") {};
    int32_t id () const {return GET_CURRENT(id);}
    int32_t id_original () const {return GET_ORIGINAL(id);}
    void    set_id(int32_t val) {SET(id, val);}
    int32_t miles () const {return GET_CURRENT(miles);}
    int32_t miles_original () const {return GET_ORIGINAL(miles);}
    void    set_miles(int32_t val) {SET(miles, val);}
    int32_t status () const {return GET_CURRENT(status);}
    int32_t status_original () const {return GET_ORIGINAL(status);}
    void    set_status(int32_t val) {SET(status, val);}
    int32_t luggage_weight () const {return GET_CURRENT(luggage_weight);}
    int32_t luggage_weight_original () const {return GET_ORIGINAL(luggage_weight);}
    void    set_luggage_weight(int32_t val) {SET(luggage_weight, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Segment* insert_row (int32_t id_val,int32_t miles_val,int32_t status_val, int32_t luggage_weight_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createsegment(b, id_val,miles_val,status_val,luggage_weight_val));
        return gaia_object_t::insert_row(b, c_num_segment_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_segment_ptrs);
    }
    static void connect_flight(Flight* pp, Segment* sp) {
        printf("Connecting flight to segment %ld to %ld\n", pp->gaia_id(), sp->gaia_id());
        connect_objects<Flight,Segment,c_primary_segment,c_first_segment,c_next_segment>(pp, sp);
    }
    static void connect_src_airport(Airport* ap, Segment* sp) {
        printf("Connecting airport src to segment %ld to %ld\n", ap->gaia_id(), sp->gaia_id());
        connect_objects<Airport,Segment,c_primary_src_segment,c_first_src_segment,c_next_src_segment>(ap, sp);
    }
    static void connect_dst_airport(Airport* ap, Segment* sp) {
        printf("Connecting airport dst to segment %ld to %ld\n", ap->gaia_id(), sp->gaia_id());
        connect_objects<Airport,Segment,c_primary_dst_segment,c_first_dst_segment,c_next_dst_segment>(ap, sp);
    }
    Airport* src_segment() {
        Airport* pp = Airport::get_row_by_id(this->m_references[c_primary_src_segment]);
        return pp;
    }
    Airport* dst_segment() {
        Airport* pp = Airport::get_row_by_id(this->m_references[c_primary_dst_segment]);
        return pp;
    }
    type_iterator<Segment> begin() {return begin_scan<Segment>();}
    type_iterator<Segment> end() {return end_scan<Segment>();}
private:
    friend struct gaia_object_t<3,Segment,segment,segmentT>;
    Segment(gaia_id_t id) : gaia_object_t(id, "Segment") {}
};

struct Trip_segment : public gaia_object_t<4,Trip_segment,trip_segment,trip_segmentT>{
    Trip_segment() : gaia_object_t("Trip_segment") {};
    const char * who () const {return GET_STR(who);}
    const char * who_original () const {return GET_STR_ORIGINAL(who);}
    void set_who(const char * val) {SET(who, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static Trip_segment* insert_row (const char * who_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createtrip_segmentDirect(b, who_val));
        return gaia_object_t::insert_row(b, c_num_trip_segment_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_trip_segment_ptrs);
    }
    static void connect_segment(Segment* sp, Trip_segment* tp) {
        printf("Connecting segment to trip_segment %ld to %ld\n", sp->gaia_id(), tp->gaia_id());
        connect_objects<Segment,Trip_segment,c_primary_trip_segment,c_first_trip_segment,c_next_trip_segment>(sp, tp);
    }
    type_iterator<Trip_segment> begin() {return begin_scan<Trip_segment>();}
    type_iterator<Trip_segment> end() {return end_scan<Trip_segment>();}
private:
    friend struct gaia_object_t<4,Trip_segment,trip_segment,trip_segmentT>;
    Trip_segment(gaia_id_t id) : gaia_object_t(id, "Trip_segment") {}
};

template <typename T_primary, typename T_foreign, int T_primary_slot, int T_foreign_slot>
class reference_iterator {
    class Iterator {
    public:
        Iterator() {}
        Iterator(T_foreign* edc_ptr) {
            m_edc_ptr = edc_ptr;
        }
        T_foreign* operator*() {
            return m_edc_ptr;
        }
        Iterator &operator++() {
            m_edc_ptr = T_foreign::get_row_by_id(m_edc_ptr->m_references[T_foreign_slot]);
            return *this;
        }
        bool operator!=(const Iterator&) const {
            return m_edc_ptr != nullptr;
        }
    private:
        T_foreign* m_edc_ptr;
    };

public:
    reference_iterator(T_primary* id) {
        m_id = id->gaia_id();
    }
    Iterator begin() {
        T_primary* p_ptr = T_primary::get_row_by_id(m_id);
        T_foreign* edc_ptr = T_foreign::get_row_by_id(p_ptr->m_references[T_primary_slot]);
        return Iterator(edc_ptr);
    }

    Iterator end() {
        return Iterator(nullptr);
    }

    gaia_id_t m_id;
};

typedef reference_iterator<Flight,Segment,c_first_segment,c_next_segment> flight_segments;
typedef reference_iterator<Airport,Segment,c_first_src_segment,c_next_src_segment> airport_src_segments;
typedef reference_iterator<Airport,Segment,c_first_dst_segment,c_next_dst_segment> airport_dst_segments;
typedef reference_iterator<Segment,Trip_segment,c_first_trip_segment,c_next_trip_segment> segment_trip_segments;

}  // namespace airport
}  // namespace gaia

#endif  // FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_
