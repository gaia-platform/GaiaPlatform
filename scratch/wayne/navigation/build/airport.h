// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_
#define FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_

#include "gaia_object.hpp"
#include "airport_generated.h"

using namespace std;
using namespace gaia::common;

namespace gaia {
namespace airport {

// NOTE: the names of these constants are not fixed with this pattern. Care must be taken
//       to not use naming conventions that may cause collision with flatbuffer field names.

// in Flight
const int c_first_segment = 0;
const int c_num_flight_ptrs = 1;

// in Segment
const int c_first_trip_segment = 0;
const int c_primary_segment = 1;
const int c_next_segment = 2;
const int c_primary_src_segment = 3;
const int c_next_src_segment = 4;
const int c_primary_dst_segment = 5;
const int c_next_dst_segment = 6;
const int c_num_segment_ptrs = 7;

// in Airport
const int c_first_src_segment = 0;
const int c_first_dst_segment = 1;
const int c_num_airport_ptrs = 2;

// in Trip_segment
const int c_next_trip_segment = 0;
const int c_primary_trip_segment = 1;
const int c_num_trip_segment_ptrs = 2;

template <typename T_gaia>
class gaia_type_iterator {
    class Iterator {
    public:
        Iterator() {}
        Iterator(T_gaia* edc_ptr) {
            m_edc_ptr = edc_ptr;
        }
        T_gaia* operator*() {
            return m_edc_ptr;
        }
        Iterator &operator++() {
            m_edc_ptr = m_edc_ptr->get_next();
            return *this;
        }
        bool operator!=(const Iterator&) const {
            return m_edc_ptr != nullptr;
        }
    private:
        T_gaia* m_edc_ptr;
    };

public:
    Iterator begin() {
        T_gaia* edc_ptr = T_gaia::get_first();
        return Iterator(edc_ptr);
    }

    Iterator end() {
        return Iterator(nullptr);
    }
};

template <typename T_primary, typename T_foreign, int T_parent_slot, int T_primary_slot, int T_foreign_slot>
static gaia_id_t connect_objects(gaia_id_t pid, gaia_id_t fid) {
    T_primary* pp = T_primary::get_row_by_id(pid);
    T_foreign* fp = T_foreign::get_row_by_id(fid);
    fp->m_references[T_foreign_slot] = pp->m_references[T_primary_slot];
    fp->m_references[T_parent_slot]  = pid;
    pp->m_references[T_primary_slot] = fid;
    return pid;
}

struct Flight : public gaia_object_t<1,Flight,flight,flightT>{
    Flight() : gaia_object_t("Flight") {};
    int32_t number () const {return GET_CURRENT(number);}
    int32_t number_original () const {return GET_ORIGINAL(number);}
    void set_number(int32_t val) {SET(number, val);}
    int32_t miles_flown () const {return GET_CURRENT(miles_flown);}
    int32_t miles_flown_original () const {return GET_ORIGINAL(miles_flown);}
    void set_miles_flown(int32_t val) {SET(miles_flown, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static gaia_id_t insert_row (int32_t number_val,int32_t miles_flown_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createflight(b, number_val,miles_flown_val));
        return gaia_object_t::insert_row(b, c_num_flight_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_flight_ptrs);
    }
    typedef gaia_type_iterator<Flight> Iterator;
private:
    friend struct gaia_object_t<1,Flight,flight,flightT>;
    Flight(gaia_id_t id) : gaia_object_t(id, "Flight") {}
};

struct Airport : public gaia_object_t<2,Airport,airport,airportT>{
    Airport() : gaia_object_t("Airport") {};
    const char * name () const {return GET_STR(name);}
    const char * name_original () const {return GET_STR_ORIGINAL(name);}
    void set_name(const char * val) {SET(name, val);}
    const char * city () const {return GET_STR(city);}
    const char * city_original () const {return GET_STR_ORIGINAL(city);}
    void set_city(const char * val) {SET(city, val);}
    const char * iata () const {return GET_STR(iata);}
    const char * iata_original () const {return GET_STR_ORIGINAL(iata);}
    void set_iata(const char * val) {SET(iata, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static gaia_id_t insert_row (const char * name_val, const char * city_val,const char * iata_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(CreateairportDirect(b, name_val,city_val,iata_val));
        return gaia_object_t::insert_row(b, c_num_airport_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_airport_ptrs);
    }
    typedef gaia_type_iterator<Airport> Iterator;
private:
    friend struct gaia_object_t<2,Airport,airport,airportT>;
    Airport(gaia_id_t id) : gaia_object_t(id, "Airport") {}
};

struct Segment : public gaia_object_t<3,Segment,segment,segmentT>{
    Segment() : gaia_object_t("Segment") {};
    int32_t id () const {return GET_CURRENT(id);}
    int32_t id_original () const {return GET_ORIGINAL(id);}
    void    set_id(int32_t val) {SET(id, val);}
    int32_t miles () const {return GET_CURRENT(miles);}
    int32_t miles_original () const {return GET_ORIGINAL(miles);}
    void    set_miles(int32_t val) {SET(miles, val);}
    int32_t status () const {return GET_CURRENT(status);}
    int32_t status_original () const {return GET_ORIGINAL(status);}
    void    set_status(int32_t val) {SET(status, val);}
    int32_t luggage_weight () const {return GET_CURRENT(luggage_weight);}
    int32_t luggage_weight_original () const {return GET_ORIGINAL(luggage_weight);}
    void    set_luggage_weight(int32_t val) {SET(luggage_weight, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static gaia_id_t insert_row (int32_t id_val,int32_t miles_val,int32_t status_val, int32_t luggage_weight_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createsegment(b, id_val,miles_val,status_val,luggage_weight_val));
        return gaia_object_t::insert_row(b, c_num_segment_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_segment_ptrs);
    }
    static gaia_id_t connect_flight(gaia_id_t pid, gaia_id_t sid) {
        printf("Connecting flight to segment %ld to %ld\n", pid, sid);
        return connect_objects<Flight,Segment,c_primary_segment,c_first_segment,c_next_segment>(pid, sid);
    }
    static gaia_id_t connect_src_airport(gaia_id_t aid, gaia_id_t sid) {
        printf("Connecting airport src to segment %ld to %ld\n", aid, sid);
        return connect_objects<Airport,Segment,c_primary_src_segment,c_first_src_segment,c_next_src_segment>(aid, sid);
    }
    static gaia_id_t connect_dst_airport(gaia_id_t aid, gaia_id_t sid) {
        printf("Connecting airport dst to segment %ld to %ld\n", aid, sid);
        return connect_objects<Airport,Segment,c_primary_dst_segment,c_first_dst_segment,c_next_dst_segment>(aid, sid);
    }
    Airport* src_segment() {
        Airport* pp = Airport::get_row_by_id(this->m_references[c_primary_src_segment]);
        return pp;
    }
    Airport* dst_segment() {
        Airport* pp = Airport::get_row_by_id(this->m_references[c_primary_dst_segment]);
        return pp;
    }
    typedef gaia_type_iterator<Segment> Iterator;
private:
    friend struct gaia_object_t<3,Segment,segment,segmentT>;
    Segment(gaia_id_t id) : gaia_object_t(id, "Segment") {}
};

struct Trip_segment : public gaia_object_t<4,Trip_segment,trip_segment,trip_segmentT>{
    Trip_segment() : gaia_object_t("Trip_segment") {};
    const char * who () const {return GET_STR(who);}
    const char * who_original () const {return GET_STR_ORIGINAL(who);}
    void set_who(const char * val) {SET(who, val);}
    using gaia_object_t::insert_row;
    using gaia_object_t::update_row;
    using gaia_object_t::delete_row;
    static gaia_id_t insert_row (const char * who_val){
        flatbuffers::FlatBufferBuilder b(128);
        b.Finish(Createtrip_segmentDirect(b, who_val));
        return gaia_object_t::insert_row(b, c_num_trip_segment_ptrs);
    }
    void insert_row() {
        gaia_object_t::insert_row(c_num_trip_segment_ptrs);
    }
    static gaia_id_t connect_segment(gaia_id_t sid, gaia_id_t tid) {
        printf("Connecting segment to trip_segment %ld to %ld\n", sid, tid);
        return connect_objects<Segment,Trip_segment,c_primary_trip_segment,c_first_trip_segment,c_next_trip_segment>(sid, tid);
    }
    typedef gaia_type_iterator<Trip_segment> Iterator;
private:
    friend struct gaia_object_t<4,Trip_segment,trip_segment,trip_segmentT>;
    Trip_segment(gaia_id_t id) : gaia_object_t(id, "Trip_segment") {}
};

template <typename T_primary, typename T_foreign, int T_primary_slot, int T_foreign_slot>
class reference_iterator {
    class Iterator {
    public:
        Iterator() {}
        Iterator(T_foreign* edc_ptr) {
            m_edc_ptr = edc_ptr;
        }
        T_foreign* operator*() {
            return m_edc_ptr;
        }
        Iterator &operator++() {
            m_edc_ptr = T_foreign::get_row_by_id(m_edc_ptr->m_references[T_foreign_slot]);
            return *this;
        }
        bool operator!=(const Iterator&) const {
            return m_edc_ptr != nullptr;
        }
    private:
        T_foreign* m_edc_ptr;
    };

public:
    reference_iterator(gaia_id_t id) {
        m_id = id;
    }
    Iterator begin() {
        T_primary* p_ptr = T_primary::get_row_by_id(m_id);
        T_foreign* edc_ptr = T_foreign::get_row_by_id(p_ptr->m_references[T_primary_slot]);
        return Iterator(edc_ptr);
    }

    Iterator end() {
        return Iterator(nullptr);
    }

    gaia_id_t m_id;
};

typedef reference_iterator<Flight,Segment,c_first_segment,c_next_segment> flight_segments;
typedef reference_iterator<Airport,Segment,c_first_src_segment,c_next_src_segment> airport_src_segments;
typedef reference_iterator<Airport,Segment,c_first_dst_segment,c_next_dst_segment> airport_dst_segments;
typedef reference_iterator<Segment,Trip_segment,c_first_trip_segment,c_next_trip_segment> segment_trip_segments;

}  // namespace airport
}  // namespace gaia

#endif  // FLATBUFFERS_GENERATED_GAIA_AIRPORT_GAIA_AIRPORT_H_
