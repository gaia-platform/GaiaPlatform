/**
 * Gaia School
 * School management system REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "FacilityApiImpl.h"

#include "gaia/common.hpp"
#include "gaia/db/db.hpp"
#include "gaia/direct_access/auto_transaction.hpp"
#include "gaia/exception.hpp"
#include "gaia_school.h"

#include "scope_guard.hpp"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

FacilityApiImpl::FacilityApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr)
    : FacilityApi(rtr) {}

void FacilityApiImpl::add_building(const Building &building,
                                   Pistache::Http::ResponseWriter &response) {
  gaia::db::begin_session();
  auto db_session_cleanup =
      sg::make_scope_guard([]() { gaia::db::end_session(); });
  response.headers().add<Pistache::Http::Header::ContentType>(
      MIME(Application, Json));
  nlohmann::json j;

  if (!building.nameIsSet() || building.getName().empty()) {
    j["what"] = "No building name.";
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  try {
    gaia::direct_access::auto_transaction_t txn;
    auto buildingId =
        gaia::school::building_t::insert_row(building.getName().c_str(), true);

    if (building.roomsIsSet()) {
      for (const auto &room : const_cast<Building &>(building).getRooms()) {
        if (!room.nameIsSet() || room.getName().empty() ||
            !room.numberIsSet() || room.getNumber().empty() ||
            !room.floorIsSet() || room.getFloor().empty()) {
          j["what"] = "Incomplete room information.";
          response.send(Pistache::Http::Code::Bad_Request, j.dump());
          return;
        }

        auto roomId = gaia::school::room_t::insert_row(
            room.getName().c_str(), room.getNumber().c_str(),
            room.getFloor().c_str(), room.getCapacity());
        gaia::school::building_t::get(buildingId)
            .building_room_list()
            .insert(roomId);
      }
    }
    txn.commit();
    j["buildingId"] = buildingId;
  } catch (const gaia::common::gaia_exception &e) {
    j["what"] = e.what();
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  response.send(Pistache::Http::Code::Ok, j.dump());
}
void FacilityApiImpl::add_facescan(const Facescan &facescan,
                                   Pistache::Http::ResponseWriter &response) {

  response.headers().add<Pistache::Http::Header::ContentType>(
      MIME(Application, Json));
  nlohmann::json j;

  if (!facescan.buildingIdIsSet() || !facescan.signatureIsSet()) {
    j["what"] = "Invalid input.";
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  gaia::db::begin_session();
  auto db_session_cleanup =
      sg::make_scope_guard([]() { gaia::db::end_session(); });

  try {
    gaia::direct_access::auto_transaction_t txn;
    auto building = gaia::school::building_t::get(facescan.getBuildingId());

    auto scan_time =
        std::chrono::system_clock::now().time_since_epoch().count();

    gaia::school::face_scan_writer writer;
    writer.signature = facescan.getSignature();
    writer.time = scan_time;
    writer.recognized = false;

    auto facescanId = gaia::common::c_invalid_gaia_id;

    for (auto person : gaia::school::person_t::list()) {
      if (person.face_signature() == facescan.getSignature()) {
        writer.recognized = true;
        facescanId = writer.insert_row();
        person.owner_face_scan_list().insert(facescanId);
        break;
      }
    }
    if (facescanId == gaia::common::c_invalid_gaia_id) {
      for (auto stranger : gaia::school::stranger_t::list()) {
        if (stranger.face_signature() == facescan.getSignature()) {
          facescanId = writer.insert_row();
          stranger.stranger_owner_face_scan_list().insert(facescanId);
          auto strangerWriter = stranger.writer();
          strangerWriter.scan_count++;
          strangerWriter.update_row();
          break;
        }
      }
    }
    if (facescanId == gaia::common::c_invalid_gaia_id) {
      facescanId = writer.insert_row();
      auto strangerId = gaia::school::stranger_t::insert_row(
          scan_time, facescan.getSignature(), 1);
      gaia::school::stranger_t::get(strangerId)
          .stranger_owner_face_scan_list()
          .insert(facescanId);
    }

    building.location_face_scan_list().insert(facescanId);

    txn.commit();
    j["facescanId"] = facescanId;
  } catch (const gaia::common::gaia_exception &e) {
    j["what"] = e.what();
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  response.send(Pistache::Http::Code::Ok, j.dump());
}
void FacilityApiImpl::add_room(const Room &room,
                               Pistache::Http::ResponseWriter &response) {
  response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void FacilityApiImpl::delete_building(
    const int64_t &buildingId, Pistache::Http::ResponseWriter &response) {
  response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void FacilityApiImpl::delete_room(const int64_t &roomId,
                                  Pistache::Http::ResponseWriter &response) {
  response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void FacilityApiImpl::get_building_by_id(
    const int64_t &buildingId, Pistache::Http::ResponseWriter &response) {
  gaia::db::begin_session();
  auto db_session_cleanup =
      sg::make_scope_guard([]() { gaia::db::end_session(); });
  response.headers().add<Pistache::Http::Header::ContentType>(
      MIME(Application, Json));
  nlohmann::json j;

  try {
    gaia::direct_access::auto_transaction_t txn;
    auto building = gaia::school::building_t::get(buildingId);
    Building b;
    b.setId(building.gaia_id());
    b.setName(building.name());
    b.setOpen(!building.door_closed());

    for (const auto &room : building.building_room_list()) {
      Room r;
      r.setId(room.gaia_id());
      r.setName(room.name());
      r.setNumber(room.number());
      r.setFloor(room.floor());
      r.setCapacity(room.capacity());
      r.setBuildingId(buildingId);
      b.getRooms().push_back(r);
    }

    txn.commit();
    j = b;
  } catch (const gaia::common::gaia_exception &e) {
    j["what"] = e.what();
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }
  response.send(Pistache::Http::Code::Ok, j.dump());
}
void FacilityApiImpl::get_room_by_id(const int64_t &roomId,
                                     Pistache::Http::ResponseWriter &response) {
  response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void FacilityApiImpl::list_buildings(Pistache::Http::ResponseWriter &response) {
  gaia::db::begin_session();
  auto db_session_cleanup =
      sg::make_scope_guard([]() { gaia::db::end_session(); });
  response.headers().add<Pistache::Http::Header::ContentType>(
      MIME(Application, Json));
  nlohmann::json j;

  try {
    gaia::direct_access::auto_transaction_t txn;
    for (auto &building : gaia::school::building_t::list()) {
      Building b;
      b.setId(building.gaia_id());
      b.setName(building.name());
      b.setOpen(!building.door_closed());
      j.push_back(b);
    }
    txn.commit();
  } catch (const gaia::common::gaia_exception &e) {
    j.clear();
    j["what"] = e.what();
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  response.send(Pistache::Http::Code::Ok, j.dump());
}
void FacilityApiImpl::list_facescan_at_building(
    const int64_t &buildingId, Pistache::Http::ResponseWriter &response) {
  gaia::db::begin_session();
  auto db_session_cleanup =
      sg::make_scope_guard([]() { gaia::db::end_session(); });
  response.headers().add<Pistache::Http::Header::ContentType>(
      MIME(Application, Json));
  nlohmann::json j;

  try {
    gaia::direct_access::auto_transaction_t txn;
    for (const auto &facescan :
         gaia::school::building_t::get(buildingId).location_face_scan_list()) {
      Facescan f;
      f.setId(facescan.gaia_id());
      f.setSignature(facescan.signature());
      f.setTime(facescan.time());
      f.setBuildingId(buildingId);
      j.push_back(f);
    }
    txn.commit();
  } catch (const gaia::common::gaia_exception &e) {
    j.clear();
    j["what"] = e.what();
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  response.send(Pistache::Http::Code::Ok, j.dump());
}
void FacilityApiImpl::list_rooms(Pistache::Http::ResponseWriter &response) {
  response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void FacilityApiImpl::update_building(
    const Building &building, Pistache::Http::ResponseWriter &response) {
  response.headers().add<Pistache::Http::Header::ContentType>(
      MIME(Application, Json));
  nlohmann::json j;

  if (!building.idIsSet()) {
    j["what"] = "No building id.";
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  gaia::db::begin_session();
  auto db_session_cleanup =
      sg::make_scope_guard([]() { gaia::db::end_session(); });

  try {
    gaia::direct_access::auto_transaction_t txn;
    auto writer = gaia::school::building_t::get(building.getId()).writer();
    if (!building.openIsSet()) {
      writer.door_closed = !writer.door_closed;
    } else {
      writer.door_closed = !building.isOpen();
    }
    if (building.nameIsSet()) {
      writer.name = building.getName();
    }
    writer.update_row();

    txn.commit();
  } catch (const gaia::common::gaia_exception &e) {
    j.clear();
    j["what"] = e.what();
    response.send(Pistache::Http::Code::Bad_Request, j.dump());
    return;
  }

  response.send(Pistache::Http::Code::Ok, j.dump());
}
void FacilityApiImpl::update_room(const Room &room,
                                  Pistache::Http::ResponseWriter &response) {
  response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}

} // namespace api
} // namespace server
} // namespace openapitools
} // namespace org
