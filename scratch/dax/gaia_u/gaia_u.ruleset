#include <string.h>
#include "rule_helpers.hpp"
#include "data/data_helpers.hpp"

ruleset event_planner
{
    // Create an Event.
    // Requires:  Room <- register later?
    //  Requires: Building
    // Requires:  Staff <- register later
    //  Requires: Person
    {
        event_planner::log("Rule 1", true);
        if (Buildings.LastOperation == INSERT)
        {
            auto building = gaia::gaia_u::Buildings_t::get(Buildings.gaia_id());
            //my_func(building);
        }
    }

    {
        event_planner::log("Rule 2",true);
        if (DoorLocked)
        {
            DoorLocked = false;
        }
    }

    //
    // Cancel event involves removing the event from the Staff_t.Teacher_Events_list()
    // and the Rooms_Events_list.
    // Note that this is not currently possible if the event has any reference defined
    //
    {
        event_planner::log("Rule 3", true);
        if (Events.LastOperation == DELETE)
        {
            event_planner::cancel_event(Events.gaia_id());
        }
    }

    // When a new room is added then adjust the restricted capacity
    // according to the restriction
    {
        event_planner::log("Rule 4", true);
        if (Rooms.LastOperation == INSERT)
        {
            RestrictedCapacity = @Capacity * (PercentFull / 100.0);
        }
    }

    // If a restriction to PercentFull changes, then update all the rooms Restricted Capacity
    // capacity.
    {
        event_planner::log("Rule 5", true);
        RestrictedCapacity = @Capacity * (PercentFull / 100.0);
    }

    // Overall algorithm.
    // 1) restriction changes
    // 2) capacity changes for every room
    // 3) for each room, see what events it is booked for
    // 4) if the new capacity is less than the enrollment, attempt to change the location
    // 4.a) update the event and registrations
    // 5) if you cannot change the location, then change the date
    // 5.a) update the event and registrations

    // If the room capacity has changed and is less than the enrollment then remove the room
    {
        event_planner::log("Rule 6", true);
        // GAIAPLAT-546:  should not have to annotate non-active fields with '@'
        if (RestrictedCapacity < @Enrolled)
        {
            char buffer[128];
            sprintf(buffer, "Event '%s' has '%u' enrollments but the restricted capacity is '%u'.  Attempting to change location.",
                @Events.Name, @Enrolled, RestrictedCapacity);
            
            event_planner::log(buffer);
            //printf("DBG:  Setting ChangeLocation for event '%s'\n", @Events.Name);
            ChangeLocation = true;
        }
    }

    // If we needto change the location, go find a room that meets the
    // following criteria:
    // - RestrictedCapacity >= number of students enrolled in the event
    // - It is not already booked for another event
    //
    // Search for room in the same building first and then
    // expand to other rooms if required.
     {
        char buffer[256];
        event_planner::log("Rule 7", true);
        if (!ChangeLocation)
        {
            return;
        }

        ChangeLocation = false;

        // If the room can hold the number of students enrolled then
        // then is no need find another room.
        if (@RestrictedCapacity >= @Enrolled)
        {
            return;
        }

        sprintf(buffer,"ChangeLocation:  Event '%s' needs a new location because room '%s' doesn't have the capacity.",
            @Events.Name, @RoomName);
        event_planner::log(buffer);

        // Try to find a room that works in the same building
        auto event = gaia::gaia_u::Events_t::get(Events.gaia_id());
        auto this_room = gaia::gaia_u::Rooms_t::get(Rooms.gaia_id());
        gaia::gaia_u::Buildings_t this_building;

        // We may find a room that meets the capacity requirements but it is not
        // available on the date we need.  Remember this so that we can reschedule
        // the event to the room and then reschedule the event to a date when the
        // room is available.
        gaia::gaia_u::Rooms_t candidate_room;

        // Search for a room in the same building.
        // UNDONE:  clean this rule up! (consolidate iteration code; it's too long and inelegant)
        if (this_room)
        {
            this_building = this_room.Buildings();
            for (auto& room : this_building.Rooms_list())
            {
                if (room == this_room)
                {
                    continue;
                }

                if (room.RestrictedCapacity() >= @Enrolled)
                {
                    if (event_planner::is_room_available(event, room))
                    {
                        event_planner::move_event_room(event, this_room, room);
                        NotifyReason = event_planner::notify_reason_t::change_location;
                        return;
                    }

                    if (!candidate_room)
                    {
                        candidate_room = room;
                    }
                }
            }
        }

        // Couldn't find a room in the same building so look in other buildings.
        // Even if we found a candidate_room above we may find one that is available.
        for (auto building : gaia::gaia_u::Buildings_t::list())
        {
            if (building == this_building)
            {
                continue;
            }

            for (auto& room : building.Rooms_list())
            {
                if (room.RestrictedCapacity() >= @Enrolled)
                {
                    if (event_planner::is_room_available(event, room))
                    {
                        event_planner::move_event_room(event, this_room, room);
                        NotifyReason = event_planner::notify_reason_t::change_location;
                        // We are done!
                        return;
                    }
                    if (!candidate_room)
                    {
                        candidate_room = room;
                    }
                }
            }
        }

        // If we have a candidate room it means we found a room that can fit the capacity
        // but not on the date we need.  Go ahead and move the room and then change the date.
        if (candidate_room)
        {
            sprintf(buffer, "Found a room for event '%s' but need to reschedule.", @Events.Name);
            event_planner::log(buffer);
            event_planner::move_event_room(event, this_room, candidate_room);
            ChangeDate = true;
        }
        else
        {
            sprintf(buffer, "Could not find a room for event '%s'.  Need to drop enrollments.", @Events.Name);
            event_planner::log(buffer);
            DropEnrollments = true;
        }
    }

    {
        char buffer[128];
        event_planner::log("Rule 8", true);
        if (!ChangeDate)
        {
            return;
        }

        ChangeDate = false;
        time_t old_date = @Date;
        auto date_info = localtime(&old_date);
        auto event = gaia::gaia_u::Events_t::get(Events.gaia_id());
        auto this_room = event.Room_Rooms();
              
        // Just pick the next week day until there is no conflict
        while (true)
        {
            date_info->tm_mday++;
            time_t new_date =  mktime(date_info);
            if (event_planner::is_room_available(new_date, this_room))
            {
                sprintf(buffer, "Changing date for event '%s' from '%s' to '%s'", @Events.Name,
                    event_planner::convert_date(@Date).c_str(),
                    event_planner::convert_date(new_date).c_str());
                event_planner::log(buffer);
                Date = new_date;
                NotifyReason = event_planner::notify_reason_t::change_both;
                break;
            }
        }
    }

    // If someone registers for an event then bump the number of enrollments
    {
        event_planner::log("Rule 9", true);
        if (Registrations.LastOperation == INSERT)
        {
            // Subtle: if you had use Enrolled++ this would have caused a second rule to
            // be generated That could be triggered by a change to the 'Enrolled' active
            // field.
            Enrolled = @Enrolled +1;
        }
    }

    // Notify staff of event changes
    {
        event_planner::log("Rule 10", true);

        std::string staff_email = "Notifying staff '";
        std::string student_email = "Notifying student '";
        std::string reason = "' that event '";

        // Pull in field from Events table to get the related staff
        if (NotifyReason == event_planner::notify_reason_t::none)
        {
            return;
        }

        // Event is related to persons via Staff so we can address
        // person fields directly.
        staff_email.append(@FirstName);
        staff_email.append(" ");
        staff_email.append(@LastName);

        reason.append(@Events.Name);
        reason.append("' has the following changes:  ");

        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_date)
        {
            reason.append("The new date is '");
            reason.append(event_planner::convert_date(@Date));
            reason.append("'.");
        }
        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_location)
        {
            reason.append("The new location is in building '");
            reason.append(@BuildingName);
            reason.append("', room '");
            reason.append(@RoomName);
            reason.append("'.");
        }
        staff_email.append(reason);
        event_planner::log(staff_email.c_str());
    }

    // Notify registered students of event changes
    {
        event_planner::log("Rule 11", true);
        std::string student_email = "Notifying student '";
        std::string reason = "' that event '";

        // Pull in field from Events table to get the related staff
        if (NotifyReason == event_planner::notify_reason_t::none)
        {
            return;
        }

        if (@RegistrationDate)
        {
            // Get the registrations for this event.
            auto registration = gaia::gaia_u::Registrations_t::get(Registrations.gaia_id());
            auto person = registration.Student_Students().Persons();
            student_email.append(person.FirstName());
            student_email.append(" ");
            student_email.append(person.LastName());
        }

        reason.append(@Events.Name);
        reason.append("' has the following changes:  ");

        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_date)
        {
            reason.append("The new date is '");
            reason.append(event_planner::convert_date(@Date));
            reason.append("'.");
        }
        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_location)
        {
            reason.append("The new location is in building '");
            reason.append(@BuildingName);
            reason.append("', room '");
            reason.append(@RoomName);
            reason.append("'.");
        }
        student_email.append(reason);
        event_planner::log(student_email.c_str());
    }


    // We don't have a room anywhere on campus that can fit the number of enrollments so
    // we need to stop dropping enrollments
    {
        char buffer[128];
        event_planner::log("Rule 12", true);
        // Send out notifications to all those who have registered
        if (!DropEnrollments)
        {
            return;
        }
        DropEnrollments = false;
        //event_planner::log("DropEnrollments", @Events.Name);

        // If the room size can accomadate the number of students enrolled
        // then we are done.
        if (@Enrolled <= @RestrictedCapacity)
        {
            return;
        }

        sprintf(buffer, "Dropping number of enrollments for event '%s' from '%u' to '%u'",
            @Events.Name, @Enrolled, @RestrictedCapacity);
        event_planner::log(buffer);

        uint32_t count_registrations_to_drop = @Enrolled - @RestrictedCapacity;

        // Drop the enrollments to match the capacity we have.  Drop the people who registered the latest.
        Enrolled = @RestrictedCapacity;

        auto this_event = gaia::gaia_u::Events_t::get(Events.gaia_id());
        std::map<int64_t, gaia::gaia_u::Registrations_t> registrations_to_drop;

        // populate our map
        for (auto& registration : this_event.Event_Registrations_list())
        {
            int64_t timestamp = event_planner::get_timestamp(registration.RegistrationDate(), registration.RegistrationTime());
            registrations_to_drop.insert(std::make_pair(timestamp, registration));
        }

        for (auto it = registrations_to_drop.rbegin(); 
            count_registrations_to_drop > 0 && it != registrations_to_drop.rend();
             ++it)
        {
            auto registration = it->second;
            auto w = registration.writer();
            w.NotifyDrop = true;
            w.update_row();
            count_registrations_to_drop--;
        }
    }

    // Notify student that they have been dropped from the enrollment
    // And delete the registration from the event
    {
        event_planner::log("Rule 13", true);
        std::string student_email = "Notifying student '";
        std::string reason = "' that they have been unregistered for event '";

        if (!NotifyDrop)
        {
            return;
        }
        NotifyDrop = false;

        student_email.append(@FirstName);
        student_email.append(" ");
        student_email.append(@LastName);
        reason.append(@Events.Name);
        reason.append("'.");
        student_email.append(reason);
        event_planner::log(student_email.c_str());

        // Drop registration
        // Remove the event and the student and drop the registration
        /*
        auto registration = gaia::gaia_u::Registrations_t::get(Registrations.gaia_id());
        registration.Event_Events().Event_Registrations_list().erase(registration);
        registration.Student_Students().Student_Registrations_list().erase(registration);
        registration.delete_row();
        */
    }
}
