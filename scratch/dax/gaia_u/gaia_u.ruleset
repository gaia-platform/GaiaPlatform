#include <string.h>

#include "rule_helpers.hpp"
#include "data/data_helpers.hpp"
#include "gaia/logger.hpp"

/**
 * Rule Index
 * 1) [unused] proof-of-concept, sharing rule-context object with function
 * 2) [unused] not-working, can't get gaia_id from deleted event (issue logged)
 * 3) If a room is inserted, use the PercentFull restriction to adjust the RestrictedCapacity of the Room
 * 4) If someone registers for an event, increase the number of enrollments for that event
 * 5) If a restriction changes (PercentFull), then update every rooms RestrictedCapacity
 * 6) If a room capacity changes and it cannot fit the number of people enrolled for an event, 
 *    we need to change the location of the event
 * 7) If an Event needs to change the location, go find a room that meets the criteria:
 *    - Can fit the number of enrollments for the event.
 *    - Is in the same building
 *    - Decide whether if it can find a room is their a time conflict
 *    - Decide if a room cannot be found for the event and need to change enrollments
 * 8) Reschedule Event
 * 9) Notify the staff (an instructor) of any event changes
 * 10) Notify registered students for an event of any changes.
 * 11) If we need to drop enrollments, then drop enrollments based on "first come, first serve".
 * 12) Notify students if their registration is cancelled because their enrollment was dropped
 */
ruleset event_planner
{
    // Create an Event.
    // Requires:  Room <- register later?
    //  Requires: Building
    // Requires:  Staff <- register later
    //  Requires: Person
    {
        gaia_log::app().trace("Rule 1");

        if (Buildings.LastOperation == INSERT)
        {
            auto building = gaia::gaia_u::Buildings_t::get(Buildings.gaia_id());
            //my_func(building);
        }
    }

    //
    // Cancel event involves removing the event from the Staff_t.Teacher_Events_list()
    // and the Rooms_Events_list.
    // Note that this is not currently possible if the event has any reference defined
    //
    {
        gaia_log::app().trace("Rule 2");
        if (Events.LastOperation == DELETE)
        {
            event_planner::cancel_event(Events.gaia_id());
        }
    }

    // When a new room is added then adjust the restricted capacity
    // according to the restriction
    {
        gaia_log::app().trace("Rule 3");
        if (Rooms.LastOperation == INSERT)
        {
            RestrictedCapacity = @Capacity * (PercentFull / 100.0);
        }
    }

    // If someone registers for an event then bump the number of enrollments
    {
        gaia_log::app().trace("Rule 4");
        if (Registrations.LastOperation == INSERT)
        {
            Enrolled++;
        }
    }

    // If a restriction to PercentFull changes, then update all the rooms Restricted Capacity
    // capacity.
    {
        gaia_log::app().trace("Rule 5");
        RestrictedCapacity = @Capacity * (PercentFull / 100.0);
    }

    // If the room capacity has changed and is less than the enrollment for the event then move the room
    {
        gaia_log::app().trace("Rule 6");
        if (RestrictedCapacity < Enrolled)
        {
            gaia_log::app().info("Event '{}' has '{}' enrollments but the restricted capacity is '{}'.  Attempting to change location.",
                @Events.Name, Enrolled, RestrictedCapacity);
            ChangeLocation = true;
        }
    }

    // If we needto change the location, go find a room that meets the
    // following criteria:
    // - RestrictedCapacity >= number of students enrolled in the event
    // - It is not already booked for another event
    //
    // Search for room in the same building first and then
    // expand to other rooms if required.
     {
        gaia_log::app().trace("Rule 7");
        if (!ChangeLocation)
        {
            return;
        }

        ChangeLocation = false;

        // If the room can hold the number of students enrolled then
        // then is no need find another room.
        if (@RestrictedCapacity >= Enrolled)
        {
            return;
        }

        gaia_log::app().info("ChangeLocation:  Event '{}' needs a new location because room '{}' doesn't have the capacity.",
            @Events.Name, @RoomName);

        // Try to find a room that works in the same building
        auto event = gaia::gaia_u::Events_t::get(Events.gaia_id());
        auto this_room = gaia::gaia_u::Rooms_t::get(Rooms.gaia_id());
        gaia::gaia_u::Buildings_t this_building;

        // We may find a room that meets the capacity requirements but it is not
        // available on the date we need.  Remember this so that we can reschedule
        // the event to the room and then reschedule the event to a date when the
        // room is available.
        gaia::gaia_u::Rooms_t candidate_room;

        // Search for a room in the same building.
        // UNDONE:  clean this rule up! (consolidate iteration code; it's too long and inelegant)
        if (this_room)
        {
            this_building = this_room.Buildings();
            for (auto& room : this_building.Rooms_list())
            {
                if (room == this_room)
                {
                    continue;
                }

                if (room.RestrictedCapacity() >= Enrolled)
                {
                    if (event_planner::is_room_available(event, room))
                    {
                        event_planner::move_event_room(event, this_room, room);
                        NotifyReason = event_planner::notify_reason_t::change_location;
                        return;
                    }

                    if (!candidate_room)
                    {
                        candidate_room = room;
                    }
                }
            }
        }

        // Couldn't find a room in the same building so look in other buildings.
        // Even if we found a candidate_room above we may find one that is available.
        for (auto building : gaia::gaia_u::Buildings_t::list())
        {
            if (building == this_building)
            {
                continue;
            }

            for (auto& room : building.Rooms_list())
            {
                if (room.RestrictedCapacity() >= Enrolled)
                {
                    if (event_planner::is_room_available(event, room))
                    {
                        event_planner::move_event_room(event, this_room, room);
                        NotifyReason = event_planner::notify_reason_t::change_location;
                        // We are done!
                        return;
                    }
                    if (!candidate_room)
                    {
                        candidate_room = room;
                    }
                }
            }
        }

        // If we have a candidate room it means we found a room that can fit the capacity
        // but not on the date we need.  Go ahead and move the room and then change the date.
        if (candidate_room)
        {
            gaia_log::app().info("Found a room for event '{}' but need to reschedule.", @Events.Name);
            event_planner::move_event_room(event, this_room, candidate_room);
            ChangeDate = true;
        }
        else
        {
            // Could not find a room, so use the one we have an drop enrollments until
            // we meet the restricted capacity
            gaia_log::app().info("Could not find a room for event '{}'.  Need to drop enrollments.", @Events.Name);
            DropEnrollments = true;
        }
    }

    // Reschedule an event.  Found a room but we need to change the date.
    {
        gaia_log::app().trace("Rule 8");
        if (!ChangeDate)
        {
            return;
        }

        ChangeDate = false;
        time_t old_date = @Date;
        auto date_info = localtime(&old_date);
        auto event = gaia::gaia_u::Events_t::get(Events.gaia_id());
        auto this_room = event.Rooms();
              
        // Just pick the next week day until there is no conflict
        while (true)
        {
            date_info->tm_mday++;
            time_t new_date =  mktime(date_info);
            if (event_planner::is_room_available(new_date, this_room))
            {
                gaia_log::app().info("Changing date for event '{}' from '{}' to '{}'", @Events.Name,
                    event_planner::convert_date(@Date).c_str(),
                    event_planner::convert_date(new_date).c_str());
                Date = new_date;
                NotifyReason = event_planner::notify_reason_t::change_both;
                break;
            }
        }
    }

    // Notify staff of event changes
    {
        gaia_log::app().trace("Rule 9");

        std::string staff_email = "Notifying staff '";
        std::string student_email = "Notifying student '";
        std::string reason = "' that event '";

        // Pull in field from Events table to get the related staff
        if (NotifyReason == event_planner::notify_reason_t::none)
        {
            return;
        }

        // Event is related to persons via Staff so we can address
        // person fields directly.
        staff_email.append(@FirstName);
        staff_email.append(" ");
        staff_email.append(@LastName);

        reason.append(@Events.Name);
        reason.append("' has the following changes:  ");

        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_date)
        {
            reason.append("The new date is '");
            reason.append(event_planner::convert_date(@Date));
            reason.append("'.");
        }
        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_location)
        {
            reason.append("The new location is in building '");
            reason.append(@BuildingName);
            reason.append("', room '");
            reason.append(@RoomName);
            reason.append("'.");
        }
        staff_email.append(reason);
        gaia_log::app().info(staff_email.c_str());
    }

    // Notify registered students of event changes
    {
        gaia_log::app().trace("Rule 10");
        std::string student_email = "Notifying student '";
        std::string reason = "' that event '";

        // Pull in field from Events table to get the related staff
        if (NotifyReason == event_planner::notify_reason_t::none)
        {
            return;
        }

        if (@RegistrationDate)
        {
            // Get the registrations for this event.
            auto registration = gaia::gaia_u::Registrations_t::get(Registrations.gaia_id());
            auto person = registration.Students().Persons();
            student_email.append(person.FirstName());
            student_email.append(" ");
            student_email.append(person.LastName());
        }

        reason.append(@Events.Name);
        reason.append("' has the following changes:  ");

        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_date)
        {
            reason.append("The new date is '");
            reason.append(event_planner::convert_date(@Date));
            reason.append("'.");
        }
        if (NotifyReason == event_planner::notify_reason_t::change_both || 
            NotifyReason == event_planner::notify_reason_t::change_location)
        {
            reason.append("The new location is in building '");
            reason.append(@BuildingName);
            reason.append("', room '");
            reason.append(@RoomName);
            reason.append("'.");
        }
        student_email.append(reason);
        gaia_log::app().info(student_email.c_str());
    }


    // We don't have a room anywhere on campus that can fit the number of enrollments so
    // we need to stop dropping enrollments
    {
        gaia_log::app().trace("Rule 11");
        // Send out notifications to all those who have registered
        if (!DropEnrollments)
        {
            return;
        }
        DropEnrollments = false;

        // If the room size can accomadate the number of students enrolled
        // then we are done.
        if (Enrolled <= @RestrictedCapacity)
        {
            return;
        }

        gaia_log::app().info("Dropping number of enrollments for event '{}' from '{}' to '{}'",
            @Events.Name, Enrolled, @RestrictedCapacity);

        uint32_t count_registrations_to_drop = Enrolled - @RestrictedCapacity;

        // Drop the enrollments to match the capacity we have.  Drop the people who registered the latest.
        Enrolled = @RestrictedCapacity;

        auto this_event = gaia::gaia_u::Events_t::get(Events.gaia_id());
        std::map<int64_t, gaia::gaia_u::Registrations_t> registrations_to_drop;

        // populate our map
        for (auto& registration : this_event.Registrations_list())
        {
            int64_t timestamp = event_planner::get_timestamp(registration.RegistrationDate(), registration.RegistrationTime());
            registrations_to_drop.insert(std::make_pair(timestamp, registration));
        }

        for (auto it = registrations_to_drop.rbegin(); 
            count_registrations_to_drop > 0 && it != registrations_to_drop.rend();
             ++it)
        {
            auto registration = it->second;
            auto w = registration.writer();
            w.NotifyDrop = true;
            w.update_row();
            count_registrations_to_drop--;
        }
    }

    // Notify student that they have been dropped from the enrollment
    // And delete the registration from the event
    {
        gaia_log::app().trace("Rule 12");
        std::string student_email = "Notifying student '";
        std::string reason = "' that they have been unregistered for event '";

        if (!NotifyDrop)
        {
            return;
        }

        student_email.append(@FirstName);
        student_email.append(" ");
        student_email.append(@LastName);
        reason.append(@Events.Name);
        reason.append("'.");
        student_email.append(reason);
        gaia_log::app().info(student_email.c_str());

        // Drop registration
        // Remove the event and the student and drop the registration
        //auto registration = gaia::gaia_u::Registrations_t::get(Registrations.gaia_id());
        //registration.Event_Events().Event_Registrations_list().erase(registration);
        //registration.Student_Students().Student_Registrations_list().erase(registration);
        //registration.delete_row();
    }
}
